commit b7d2c389e324f82d2c7e91d141fe8f6e0c44d0e2
Author: tthtlc <htmldeveloper@gmail.com>
Date:   Mon Sep 9 22:55:58 2024 +0800

     Changes to be committed:
            new file:   convert.py
            new file:   convert1.py
            new file:   convert1.sh
            new file:   convert1_orig.py
            new file:   dodecahedron.js
            modified:   dodecahedron1.html
            new file:   file.txt
            new file:   generalized.html
            new file:   generalized1.html
            new file:   generalized2.html
            new file:   generalized3.html
            new file:   line_graphics.html
            new file:   rubbish/chasing_square.html
            new file:   rubbish/chasing_square1.html
            new file:   rubbish/chasing_square2.html
            new file:   rubbish/circle.html
            new file:   rubbish/circle2.html
            new file:   rubbish/circle_color.html
            new file:   rubbish/concentric.html
            new file:   rubbish/counter_rotating_sector.html
            new file:   rubbish/css_3dcube.html
            new file:   rubbish/css_circle.html
            new file:   rubbish/css_circle1.html
            new file:   rubbish/d3_graph.html
            new file:   rubbish/double.html
            new file:   rubbish/double1.html
            new file:   rubbish/double3.html
            new file:   rubbish/double4.html
            new file:   rubbish/double5.html
            new file:   rubbish/double_motion.html
            new file:   rubbish/drawsector.html
            new file:   rubbish/ellipse.html
            new file:   rubbish/ellipse2.html
            new file:   rubbish/ellipse3.html
            new file:   rubbish/ellipse4.html
            new file:   rubbish/ellipse_color.html
            new file:   rubbish/ellipse_color2.html
            new file:   rubbish/ellipsical_line.html
            new file:   rubbish/ellipsical_line_rotate.html
            new file:   rubbish/figure_eight.html
            new file:   rubbish/figure_eight2.html
            new file:   rubbish/five_rotate_spoke.html
            new file:   rubbish/five_rotate_spoke_sector.html
            new file:   rubbish/four_petal.html
            new file:   rubbish/four_petal_double.html
            new file:   rubbish/four_petal_rotate.html
            new file:   rubbish/icosahedron2.html
            new file:   rubbish/index.html
            new file:   rubbish/klein.html
            new file:   rubbish/klein2.html
            new file:   rubbish/klein2_animation.html
            new file:   rubbish/klein2_animation2.html
            new file:   rubbish/klein2_animation3.html
            new file:   rubbish/klein3.html
            new file:   rubbish/klein4.html
            new file:   rubbish/klein5.html
            new file:   rubbish/klein6.html
            new file:   rubbish/klein7.html
            new file:   rubbish/line.html
            new file:   rubbish/line_drawing.html
            new file:   rubbish/mobius.html
            new file:   rubbish/moving_square.html
            new file:   rubbish/moving_square2.html
            new file:   rubbish/moving_square3.html
            new file:   rubbish/moving_square4.html
            new file:   rubbish/moving_square5.html
            new file:   rubbish/mywebgl.html
            new file:   rubbish/not_working.html
            new file:   rubbish/o.html
            new file:   rubbish/quart_motion.html
            new file:   rubbish/rotating_sector.html
            new file:   rubbish/rotating_spiral.html
            new file:   rubbish/rotating_spoke.html
            new file:   rubbish/sinsoidal5.html
            new file:   rubbish/sinusoidal.html
            new file:   rubbish/solid_torus.html
            new file:   rubbish/solid_torus1.html
            new file:   rubbish/special.html
            new file:   rubbish/spherical_sinusoid.html
            new file:   rubbish/spherical_sinusoid1.html
            new file:   rubbish/spherical_sinusoid2.html
            new file:   rubbish/spherical_sinusoid3.html
            new file:   rubbish/spiral.html
            new file:   rubbish/spoke_subspokes.html
            new file:   rubbish/static_concentric.html
            new file:   rubbish/three_petal.html
            new file:   rubbish/torus.html
            new file:   rubbish/torus2.html
            new file:   rubbish/triple_motion.html
            new file:   rubbish/try.html
            new file:   rubbish/try5.html
            new file:   rubbish/two_ellipse.html
            new file:   rubbish/two_petal.html
            new file:   rubbish/webgl.html
            new file:   rubbish/webgl_3dcube.html
            deleted:    script.js
            new file:   triangle.html
            new file:   wavy.js

diff --git a/convert.py b/convert.py
new file mode 100644
index 0000000..abdd9d7
--- /dev/null
+++ b/convert.py
@@ -0,0 +1,53 @@
+
+import os
+
+# Function to generate HTML content for each file
+def generate_html(filename):
+    # Read the content of the file
+    with open(filename, 'r') as file:
+        file_content = file.read()
+
+    # Generate the HTML content
+    html_content = f"""
+    <!DOCTYPE html>
+    <html lang="en">
+    <head>
+        <meta charset="UTF-8">
+        <meta name="viewport" content="width=device-width, initial-scale=1.0">
+        <title>{filename}</title>
+    </head>
+    <body>
+        <h1>File: {filename}</h1>
+        <a href="{filename}">{filename}</a>
+        <iframe srcdoc="{file_content.replace('"', '&quot;').replace("'", "&apos;")}" 
+                style="width:100%; height:500px; border:none;">
+        </iframe>
+    </body>
+    </html>
+    """
+    
+    # Save the HTML content to a new file
+    html_filename = f"{os.path.splitext(filename)[0]}.html"
+    with open(html_filename, 'w') as html_file:
+        html_file.write(html_content)
+    print(f"Generated: {html_filename}")
+
+# Main function to process the input file containing filenames
+def process_input_file(input_file):
+    with open(input_file, 'r') as file:
+        filenames = file.readlines()
+    
+    # Strip whitespace characters like \n at the end of each line
+    filenames = [f.strip() for f in filenames]
+    
+    # Generate HTML files for each filename
+    for filename in filenames:
+        if os.path.exists(filename):
+            generate_html(filename)
+        else:
+            print(f"File not found: {filename}")
+
+# Example usage
+input_file = 'file.txt'  # The file containing the list of filenames
+process_input_file(input_file)
+
diff --git a/convert1.py b/convert1.py
new file mode 100644
index 0000000..9d6fba8
--- /dev/null
+++ b/convert1.py
@@ -0,0 +1,55 @@
+
+import os
+
+def generate_html(input_file, output_html):
+    # Read the input file
+    with open(input_file, 'r') as file:
+        filenames = file.readlines()
+
+    # Start HTML content
+    html_content = """
+    <!DOCTYPE html>
+    <html lang="en">
+    <head>
+        <meta charset="UTF-8">
+        <meta name="viewport" content="width=device-width, initial-scale=1.0">
+        <title>Sansagraphics Jems</title>
+        <style>
+            body { font-family: Arial, sans-serif; margin: 20px; }
+            a { display: block; margin-bottom: 10px; text-decoration: none; color: blue; }
+            iframe { width: 100%; height: 500px; border: none; margin-top: 20px; }
+        </style>
+    </head>
+    <body>
+        <h1>Files</h1>
+    """
+
+    # Add each file as a link with an iframe
+    for filename in filenames:
+        filename = filename.strip()
+        if filename:
+            # Escape filename for safe HTML output
+            safe_filename = filename.replace('"', '&quot;').replace("'", "&apos;")
+            # Generate the HTML block for the link and iframe
+            html_content += f"""
+            <a href="{safe_filename}">{filename}</a>
+            <iframe src="{safe_filename}"></iframe>
+            """
+
+    # Close the HTML tags
+    html_content += """
+    </body>
+    </html>
+    """
+
+    # Write the HTML content to the output file
+    with open(output_html, 'w') as html_file:
+        html_file.write(html_content)
+    print(f"Generated {output_html}")
+
+# Example usage
+input_file = 'file.txt'  # The input file containing filenames
+output_html = 'output.html'  # The output HTML file
+
+generate_html(input_file, output_html)
+
diff --git a/convert1.sh b/convert1.sh
new file mode 100644
index 0000000..19c1884
--- /dev/null
+++ b/convert1.sh
@@ -0,0 +1,3 @@
+
+ls -1t *.html | sed '/index.html$/d'
+
diff --git a/convert1_orig.py b/convert1_orig.py
new file mode 100644
index 0000000..9711f0a
--- /dev/null
+++ b/convert1_orig.py
@@ -0,0 +1,55 @@
+
+import os
+
+def generate_html(input_file, output_html):
+    # Read the input file
+    with open(input_file, 'r') as file:
+        filenames = file.readlines()
+
+    # Start HTML content
+    html_content = """
+    <!DOCTYPE html>
+    <html lang="en">
+    <head>
+        <meta charset="UTF-8">
+        <meta name="viewport" content="width=device-width, initial-scale=1.0">
+        <title>Files List</title>
+        <style>
+            body { font-family: Arial, sans-serif; margin: 20px; }
+            a { display: block; margin-bottom: 10px; text-decoration: none; color: blue; }
+            iframe { width: 100%; height: 500px; border: none; margin-top: 20px; }
+        </style>
+    </head>
+    <body>
+        <h1>Files</h1>
+    """
+
+    # Add each file as a link with an iframe
+    for filename in filenames:
+        filename = filename.strip()
+        if filename:
+            # Escape filename for safe HTML output
+            safe_filename = filename.replace('"', '&quot;').replace("'", "&apos;")
+            # Generate the HTML block for the link and iframe
+            html_content += f"""
+            <a href="{safe_filename}" target="frame_{safe_filename}">{filename}</a>
+            <iframe name="frame_{safe_filename}" src="{safe_filename}"></iframe>
+            """
+
+    # Close the HTML tags
+    html_content += """
+    </body>
+    </html>
+    """
+
+    # Write the HTML content to the output file
+    with open(output_html, 'w') as html_file:
+        html_file.write(html_content)
+    print(f"Generated {output_html}")
+
+# Example usage
+input_file = 'file.txt'  # The input file containing filenames
+output_html = 'output.html'  # The output HTML file
+
+generate_html(input_file, output_html)
+
diff --git a/dodecahedron.js b/dodecahedron.js
new file mode 100644
index 0000000..c961fd5
--- /dev/null
+++ b/dodecahedron.js
@@ -0,0 +1,61 @@
+function project(vertex) {
+    return [
+        vertex[0], // x
+        vertex[1]  // y
+    ];
+}
+
+function rotate(angle, axis) {
+    const cosA = Math.cos(angle);
+    const sinA = Math.sin(angle);
+    
+    if (axis[0] === 1) { // Rotate around x-axis
+        return [
+            [1, 0, 0],
+            [0, cosA, -sinA],
+            [0, sinA, cosA]
+        ];
+    }
+    // Add y and z rotation as needed
+    return [
+        [1, 0, 0],
+        [0, 1, 0],
+        [0, 0, 1]
+    ];
+}
+
+function applyMatrix(matrix, vertex) {
+    return [
+        matrix[0][0] * vertex[0] + matrix[0][1] * vertex[1] + matrix[0][2] * vertex[2],
+        matrix[1][0] * vertex[0] + matrix[1][1] * vertex[1] + matrix[1][2] * vertex[2],
+        matrix[2][0] * vertex[0] + matrix[2][1] * vertex[1] + matrix[2][2] * vertex[2]
+    ];
+}
+
+function drawDodecahedron() {
+    ctx.clearRect(0, 0, canvas.width, canvas.height);
+
+    rotationMatrix = rotate(0.01, [1, 0, 0]); // Example: Rotate around x-axis
+
+    for (let i = 0; i < edges.length; i++) {
+        const vertex1 = vertices[edges[i][0]];
+        const vertex2 = vertices[edges[i][1]];
+
+        const rotatedVertex1 = applyMatrix(rotationMatrix, vertex1);
+        const rotatedVertex2 = applyMatrix(rotationMatrix, vertex2);
+
+        const projectedVertex1 = project(rotatedVertex1);
+        const projectedVertex2 = project(rotatedVertex2);
+
+        projectedVertex1[0] = (projectedVertex1[0] + 1) * canvas.width / 2;
+        projectedVertex1[1] = (projectedVertex1[1] + 1) * canvas.height / 2;
+        projectedVertex2[0] = (projectedVertex2[0] + 1) * canvas.width / 2;
+        projectedVertex2[1] = (projectedVertex2[1] + 1) * canvas.height / 2;
+
+        ctx.beginPath();
+        ctx.moveTo(projectedVertex1[0], projectedVertex1[1]);
+        ctx.lineTo(projectedVertex2[0], projectedVertex2[1]);
+        ctx.stroke();
+    }
+}
+
diff --git a/dodecahedron1.html b/dodecahedron1.html
index df55110..4852a8c 100644
--- a/dodecahedron1.html
+++ b/dodecahedron1.html
@@ -20,6 +20,6 @@
 </head>
 <body>
     <canvas id="myCanvas" width="500" height="500"></canvas>
-    <script src="script.js"></script>
+    <script src="dodecahedron.js"></script>
 </body>
 </html>
diff --git a/file.txt b/file.txt
new file mode 100644
index 0000000..c2a4ca8
--- /dev/null
+++ b/file.txt
@@ -0,0 +1,68 @@
+sphere.html
+ovalellipse.html
+klein2_animation3.html
+klein2_animation.html
+klein3.html
+klein4.html
+klein5.html
+klein6.html
+klein7.html
+klein.html
+line_drawing.html
+mobius.html
+moving_square2.html
+moving_square3.html
+moving_square4.html
+moving_square5.html
+moving_square.html
+quart_motion.html
+rotating_sector.html
+rotating_spiral.html
+rotating_spoke.html
+sinsoidal5.html
+sinusoidal.html
+solid_torus1.html
+special.html
+spherical_sinusoid1.html
+spherical_sinusoid3.html
+spherical_sinusoid.html
+spiral.html
+spoke_subspokes.html
+static_concentric.html
+three_petal.html
+torus2.html
+triple_motion.html
+try5.html
+two_ellipse.html
+two_petal.html
+double_motion.html
+drawsector.html
+ellipse2.html
+ellipse3.html
+ellipse4.html
+ellipsical_line.html
+ellipsical_line_rotate.html
+figure_eight2.html
+figure_eight.html
+five_rotate_spoke.html
+five_rotate_spoke_sector.html
+four_petal_double.html
+four_petal.html
+four_petal_rotate.html
+klein2_animation2.html
+chasing_square1.html
+chasing_square2.html
+chasing_square.html
+circle2.html
+circle_color.html
+circle.html
+concentric.html
+counter_rotating_sector.html
+css_3dcube.html
+css_circle1.html
+css_circle.html
+d3_graph.html
+double3.html
+double4.html
+double5.html
+double.html
diff --git a/generalized.html b/generalized.html
new file mode 100644
index 0000000..5ff05e4
--- /dev/null
+++ b/generalized.html
@@ -0,0 +1,109 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Shape Drawer</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+        #controls {
+            position: absolute;
+            top: 20px;
+            left: 20px;
+            display: flex;
+            flex-direction: column;
+        }
+        button {
+            margin-bottom: 10px;
+        }
+    </style>
+</head>
+<body>
+    <div id="controls">
+        <button onclick="setShape('triangle')">Triangle</button>
+        <button onclick="setShape('square')">Square</button>
+        <button onclick="setShape('pentagon')">Pentagon</button>
+        <button onclick="setShape('circle')">Circle</button>
+        <button onclick="setShape('ellipse')">Ellipse</button>
+        <button onclick="setShape('hexagon')">Hexagon</button>
+        <button onclick="drawShapes()">Draw</button>
+    </div>
+    <canvas id="canvas" width="800" height="600"></canvas>
+
+    <script>
+        const canvas = document.getElementById('canvas');
+        const context = canvas.getContext('2d');
+        let selectedShape = 'ellipse';  // Default shape
+        let shapes = [];
+
+        // Set the shape based on the clicked button
+        function setShape(shape) {
+            selectedShape = shape;
+        }
+
+        // Draw the selected shape at the given position
+        function drawShapeAtPosition(x, y) {
+            context.beginPath();
+            switch (selectedShape) {
+                case 'triangle':
+                    drawPolygon(x, y, 3, 50);
+                    break;
+                case 'square':
+                    drawPolygon(x, y, 4, 50);
+                    break;
+                case 'pentagon':
+                    drawPolygon(x, y, 5, 50);
+                    break;
+                case 'circle':
+                    context.arc(x, y, 50, 0, 2 * Math.PI);
+                    break;
+                case 'ellipse':
+                    context.ellipse(x, y, 50, 30, 0, 0, 2 * Math.PI);
+                    break;
+                case 'hexagon':
+                    drawPolygon(x, y, 6, 50);
+                    break;
+            }
+            context.fillStyle = getRandomColor();
+            context.fill();
+            context.stroke();
+        }
+
+        // Draw a regular polygon
+        function drawPolygon(x, y, sides, radius) {
+            const angle = 2 * Math.PI / sides;
+            context.moveTo(x + radius * Math.cos(0), y + radius * Math.sin(0));
+            for (let i = 1; i <= sides; i++) {
+                context.lineTo(x + radius * Math.cos(i * angle), y + radius * Math.sin(i * angle));
+            }
+        }
+
+        // Handle the "Draw" button click
+        function drawShapes() {
+            canvas.addEventListener('click', (event) => {
+                const rect = canvas.getBoundingClientRect();
+                const x = event.clientX - rect.left;
+                const y = event.clientY - rect.top;
+                shapes.push({ x: x, y: y, shape: selectedShape });
+                drawShapeAtPosition(x, y);
+            });
+        }
+
+        function getRandomColor() {
+            const colors = ["blue", "green", "red", "yellow", "purple", "orange", "pink"];
+            return colors[Math.floor(Math.random() * colors.length)];
+        }
+    </script>
+</body>
+</html>
+
diff --git a/generalized1.html b/generalized1.html
new file mode 100644
index 0000000..0d8117c
--- /dev/null
+++ b/generalized1.html
@@ -0,0 +1,108 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Shape Drawer</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+        #controls {
+            position: absolute;
+            top: 20px;
+            left: 20px;
+            display: flex;
+            flex-direction: column;
+        }
+        button {
+            margin-bottom: 10px;
+        }
+    </style>
+</head>
+<body>
+    <div id="controls">
+        <button onclick="setShape('triangle')">Triangle</button>
+        <button onclick="setShape('square')">Square</button>
+        <button onclick="setShape('pentagon')">Pentagon</button>
+        <button onclick="setShape('circle')">Circle</button>
+        <button onclick="setShape('ellipse')">Ellipse</button>
+        <button onclick="setShape('hexagon')">Hexagon</button>
+        <button onclick="startDrawing()">Draw</button>
+    </div>
+    <canvas id="canvas" width="800" height="600"></canvas>
+
+    <script>
+        const canvas = document.getElementById('canvas');
+        const context = canvas.getContext('2d');
+        let selectedShape = 'ellipse';  // Default shape
+
+        // Set the shape based on the clicked button
+        function setShape(shape) {
+            selectedShape = shape;
+        }
+
+        // Draw the selected shape at the given position
+        function drawShapeAtPosition(x, y) {
+            context.beginPath(); // Important to start a new path for each shape
+            switch (selectedShape) {
+                case 'triangle':
+                    drawPolygon(x, y, 3, 50);
+                    break;
+                case 'square':
+                    drawPolygon(x, y, 4, 50);
+                    break;
+                case 'pentagon':
+                    drawPolygon(x, y, 5, 50);
+                    break;
+                case 'circle':
+                    context.arc(x, y, 50, 0, 2 * Math.PI);
+                    break;
+                case 'ellipse':
+                    context.ellipse(x, y, 50, 30, 0, 0, 2 * Math.PI);
+                    break;
+                case 'hexagon':
+                    drawPolygon(x, y, 6, 50);
+                    break;
+            }
+            context.fillStyle = getRandomColor();
+            context.fill();
+            context.stroke();
+        }
+
+        // Draw a regular polygon
+        function drawPolygon(x, y, sides, radius) {
+            const angle = 2 * Math.PI / sides;
+            context.moveTo(x + radius * Math.cos(0), y + radius * Math.sin(0));
+            for (let i = 1; i <= sides; i++) {
+                context.lineTo(x + radius * Math.cos(i * angle), y + radius * Math.sin(i * angle));
+            }
+            context.closePath(); // Close the polygon path
+        }
+
+        // Start the drawing process when the "Draw" button is pressed
+        function startDrawing() {
+            canvas.addEventListener('click', (event) => {
+                const rect = canvas.getBoundingClientRect();
+                const x = event.clientX - rect.left;
+                const y = event.clientY - rect.top;
+                drawShapeAtPosition(x, y);
+            });
+        }
+
+        function getRandomColor() {
+            const colors = ["blue", "green", "red", "yellow", "purple", "orange", "pink"];
+            return colors[Math.floor(Math.random() * colors.length)];
+        }
+    </script>
+</body>
+</html>
+
diff --git a/generalized2.html b/generalized2.html
new file mode 100644
index 0000000..1b88f7c
--- /dev/null
+++ b/generalized2.html
@@ -0,0 +1,143 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Rotating Ellipses</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+        #controls {
+            position: absolute;
+            top: 20px;
+            left: 20px;
+        }
+    </style>
+</head>
+<body onload="drawEllipse()">
+    <div id="controls">
+        <label for="radiusX">Radius X: </label>
+        <input type="number" id="radiusX" value="100">
+        <label for="radiusY">Radius Y: </label>
+        <input type="number" id="radiusY" value="50">
+        <button onclick="drawEllipse()">Draw Ellipse</button>
+        <button onclick="drawTriangle()">Draw Triangle</button>
+    </div>
+    <canvas id="canvas" width="800" height="600"></canvas>
+    
+    <script>
+        const canvas = document.getElementById('canvas');
+        const context = canvas.getContext('2d');
+        let ellipses = [];
+
+        canvas.addEventListener('click', (event) => {
+            const rect = canvas.getBoundingClientRect();
+            const x = event.clientX - rect.left;
+            const y = event.clientY - rect.top;
+            const radiusX = parseInt(document.getElementById('radiusX').value, 10);
+            const radiusY = parseInt(document.getElementById('radiusY').value, 10);
+            ellipses.push({x: x, y: y, radiusX: radiusX, radiusY: radiusY, angle: 0});
+            drawEllipseAtPosition(x, y, radiusX, radiusY);
+        });
+
+        function drawEllipseAtPosition(x, y, radiusX, radiusY) {
+            context.beginPath();
+            context.ellipse(x, y, radiusX, radiusY, 0, 0, 2 * Math.PI);
+            context.fillStyle = getRandomColor();
+            context.fill();
+            context.stroke();
+        }
+
+        function drawEllipse() {
+            const radiusX = parseInt(document.getElementById('radiusX').value, 10);
+            const radiusY = parseInt(document.getElementById('radiusY').value, 10);
+            const x = canvas.width / 2;
+            const y = canvas.height / 2;
+            ellipses.push({x: x, y: y, radiusX: radiusX, radiusY: radiusY, angle: 0});
+            drawEllipseAtPosition(x, y, radiusX, radiusY);
+        }
+
+        function animateEllipses() {
+            ellipses.forEach(ellipse => {
+                context.save();
+                context.translate(ellipse.x, ellipse.y);
+                context.rotate(ellipse.angle);
+                context.beginPath();
+                context.ellipse(0, 0, ellipse.radiusX, ellipse.radiusY, 0, 0, 2 * Math.PI);
+                context.fillStyle = getRandomColor();
+                context.fill();
+                context.stroke();
+                context.restore();
+                ellipse.angle += 0.2;
+            });
+            requestAnimationFrame(animateEllipses);
+        }
+        canvas.addEventListener('click', (event) => {
+            const rect = canvas.getBoundingClientRect();
+            const x = event.clientX - rect.left;
+            const y = event.clientY - rect.top;
+            const radius = parseInt(document.getElementById('radius').value, 10);
+            triangles.push({x: x, y: y, radius: radius });
+            drawTriangleAtPosition(x, y, radius);
+        });
+
+        function drawTriangleAtPosition(x, y, radius) {
+            context.beginPath();
+            context.triangle(x, y, radius, radius, 0, 0, 2 * Math.PI);
+            context.fillStyle = getRandomColor();
+            context.fill();
+            context.stroke();
+        }
+
+        function drawTriangle() {
+            const radius = parseInt(document.getElementById('radius').value, 10);
+            const x = canvas.width / 2;
+            const y = canvas.height / 2;
+            triangles.push({x: x, y: y, radius: radius});
+            drawTriangleAtPosition(x, y, radius);
+        }
+
+        function animateTriangles() {
+            triangles.forEach(triangle => {
+                context.save();
+                context.translate(triangle.x, triangle.y);
+                context.rotate(triangle.angle);
+                context.beginPath();
+                context.triangle(0, 0, triangle.radius, 0, 0, 2 * Math.PI);
+                context.fillStyle = getRandomColor();
+                context.fill();
+                context.stroke();
+                context.restore();
+                triangle.angle += 0.2;
+            });
+            requestAnimationFrame(animateTriangles);
+        }
+
+        function getRandomColor() {
+          const colors = [
+            "blue", "green", "red", "yellow", "purple", "orange", "pink", "brown",
+            "black", "white", "gray", "cyan", "magenta", "lime", "indigo", "violet",
+            "gold", "silver", "beige", "maroon", "olive", "navy", "teal"
+          ];
+        
+          // Generate a random index to pick a color
+          const randomIndex = Math.floor(Math.random() * colors.length);
+        
+          // Return the randomly selected color
+          return colors[randomIndex];
+        }
+        
+        animateEllipses();
+    </script>
+</body>
+</html>
+
diff --git a/generalized3.html b/generalized3.html
new file mode 100644
index 0000000..0e0add4
--- /dev/null
+++ b/generalized3.html
@@ -0,0 +1,87 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Shape Drawer</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+        #controls {
+            position: absolute;
+            top: 20px;
+            left: 20px;
+            display: flex;
+            flex-direction: column;
+        }
+        button {
+            margin-bottom: 10px;
+        }
+    </style>
+</head>
+<body>
+    <div id="controls">
+        <label for="radiusX">Radius X: </label>
+        <input type="number" id="radiusX" value="100">
+        <label for="radiusY">Radius Y: </label>
+        <input type="number" id="radiusY" value="50">
+        <button onclick="drawEllipse()">Draw Ellipse</button>
+        <button onclick="changeToTriangle()">Change to Triangle</button>
+    </div>
+    <canvas id="canvas" width="800" height="600"></canvas>
+
+    <script>
+        const canvas = document.getElementById('canvas');
+        const context = canvas.getContext('2d');
+        let currentShape = 'ellipse'; // Default shape
+
+        // Draw the ellipse
+        function drawEllipse() {
+            const radiusX = parseInt(document.getElementById('radiusX').value, 10);
+            const radiusY = parseInt(document.getElementById('radiusY').value, 10);
+            const x = canvas.width / 2;
+            const y = canvas.height / 2;
+            context.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas before drawing
+            context.beginPath();
+            if (currentShape === 'ellipse') {
+                context.ellipse(x, y, radiusX, radiusY, 0, 0, 2 * Math.PI);
+            } else if (currentShape === 'triangle') {
+                drawTriangle(x, y, Math.min(radiusX, radiusY)); // Use radius as triangle size
+            }
+            context.fillStyle = getRandomColor();
+            context.fill();
+            context.stroke();
+        }
+
+        // Change shape to triangle
+        function changeToTriangle() {
+            currentShape = 'triangle'; // Change the shape to triangle
+            drawEllipse(); // Re-draw with the triangle instead
+        }
+
+        // Draw a triangle centered at (x, y) with a given size (radius)
+        function drawTriangle(x, y, radius) {
+            context.moveTo(x, y - radius); // Top vertex
+            context.lineTo(x - radius, y + radius); // Bottom left
+            context.lineTo(x + radius, y + radius); // Bottom right
+            context.closePath(); // Close the triangle path
+        }
+
+        // Random color generator
+        function getRandomColor() {
+            const colors = ["blue", "green", "red", "yellow", "purple", "orange", "pink"];
+            return colors[Math.floor(Math.random() * colors.length)];
+        }
+    </script>
+</body>
+</html>
+
diff --git a/line_graphics.html b/line_graphics.html
new file mode 100644
index 0000000..3ef44b9
--- /dev/null
+++ b/line_graphics.html
@@ -0,0 +1,66 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Complex Polygon Renderer</title>
+    <style>
+        canvas {
+            border: 1px solid black;
+        }
+    </style>
+</head>
+<body>
+    <h1>Polygon Renderer</h1>
+    <label for="sides">Number of Sides: </label>
+    <input type="number" id="sides" value="5" min="3">
+    <label for="angle">Angle Step (degrees): </label>
+    <input type="number" id="angle" value="0">
+    <button onclick="drawPolygon()">Draw Polygon</button>
+
+    <canvas id="polygonCanvas" width="500" height="500"></canvas>
+
+    <script>
+        function drawPolygon() {
+            const sides = parseInt(document.getElementById('sides').value);
+            const angleStep = parseFloat(document.getElementById('angle').value);
+            const canvas = document.getElementById('polygonCanvas');
+            const ctx = canvas.getContext('2d');
+
+            // Clear the canvas
+            ctx.clearRect(0, 0, canvas.width, canvas.height);
+
+            const centerX = canvas.width / 2;
+            const centerY = canvas.height / 2;
+            const radius = 200;
+
+            // Calculate polygon points
+            const points = [];
+            let angleOffset = angleStep * Math.PI / 180; // Convert degrees to radians
+
+            for (let i = 0; i < sides; i++) {
+                const angle = (i * 2 * Math.PI / sides) + angleOffset;
+                const x = centerX + radius * Math.cos(angle);
+                const y = centerY + radius * Math.sin(angle);
+                points.push({ x, y });
+                angleOffset += angleStep * Math.PI / 180;
+            }
+
+            // Draw the polygon
+            ctx.beginPath();
+            ctx.moveTo(points[0].x, points[0].y);
+
+            for (let i = 1; i < points.length; i++) {
+                ctx.lineTo(points[i].x, points[i].y);
+            }
+
+            ctx.closePath();
+            ctx.stroke();
+        }
+
+        // Initial draw
+        drawPolygon();
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/chasing_square.html b/rubbish/chasing_square.html
new file mode 100644
index 0000000..187d6da
--- /dev/null
+++ b/rubbish/chasing_square.html
@@ -0,0 +1,54 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Canvas Pattern</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #fff;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="patternCanvas" width="500" height="500"></canvas>
+    <script>
+        const canvas = document.getElementById('patternCanvas');
+        const ctx = canvas.getContext('2d');
+
+        function drawPattern() {
+            const radius = 100;
+            const spacing = 10;
+            const rows = 5;
+            const cols = 5;
+
+            for (let row = 0; row < rows; row++) {
+                for (let col = 0; col < cols; col++) {
+                    const x = col * 2 * radius * 0.5 + radius;
+                    const y = row * 2 * radius * 0.5 + radius;
+                    drawArcSet(x, y, radius, spacing);
+                }
+            }
+        }
+
+        function drawArcSet(x, y, radius, spacing) {
+            for (let i = 0; i < radius / spacing; i++) {
+                ctx.beginPath();
+                ctx.arc(x, y, radius - i * spacing, 0, Math.PI, false);
+                ctx.stroke();
+            }
+        }
+
+        drawPattern();
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/chasing_square1.html b/rubbish/chasing_square1.html
new file mode 100644
index 0000000..5938e61
--- /dev/null
+++ b/rubbish/chasing_square1.html
@@ -0,0 +1,58 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Canvas Pattern</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #fff;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="patternCanvas" width="500" height="500"></canvas>
+    <script>
+        const canvas = document.getElementById('patternCanvas');
+        const ctx = canvas.getContext('2d');
+        const width = canvas.width;
+        const height = canvas.height;
+        const radius = 100;
+        const lineWidth = 2;
+
+        ctx.lineWidth = lineWidth;
+        ctx.strokeStyle = '#000';
+
+        function drawPattern() {
+            const offsetX = radius;
+            const offsetY = radius;
+            const spacing = 10;
+
+            for (let i = 0; i <= width / radius; i++) {
+                for (let j = 0; j <= height / radius; j++) {
+                    drawArcs(i * offsetX, j * offsetY, radius, spacing);
+                }
+            }
+        }
+
+        function drawArcs(x, y, radius, spacing) {
+            for (let r = radius; r > 0; r -= spacing) {
+                ctx.beginPath();
+                ctx.arc(x, y, r, 0, Math.PI * 2, false);
+                ctx.stroke();
+            }
+        }
+
+        drawPattern();
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/chasing_square2.html b/rubbish/chasing_square2.html
new file mode 100644
index 0000000..5f39f53
--- /dev/null
+++ b/rubbish/chasing_square2.html
@@ -0,0 +1,64 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Canvas Pattern</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #fff;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="patternCanvas" width="500" height="500"></canvas>
+    <script>
+        const canvas = document.getElementById('patternCanvas');
+        const ctx = canvas.getContext('2d');
+        const width = canvas.width;
+        const height = canvas.height;
+        const radius = 100;
+        const lineWidth = 2;
+
+        ctx.lineWidth = lineWidth;
+
+        const colors = ['#FF5733', '#33FF57', '#3357FF', '#FF33A1', '#A133FF']; // Array of colors
+        const numColors = colors.length;
+
+        function drawPattern() {
+            const offsetX = radius;
+            const offsetY = radius;
+            const spacing = 10;
+
+            for (let i = 0; i <= width / radius; i++) {
+                for (let j = 0; j <= height / radius; j++) {
+                    drawArcs(i * offsetX, j * offsetY, radius, spacing);
+                }
+            }
+        }
+
+        function drawArcs(x, y, radius, spacing) {
+            let colorIndex = Math.floor(Math.random() * 16);
+
+            for (let r = radius; r > 0; r -= spacing) {
+                ctx.strokeStyle = colors[colorIndex % numColors];
+                ctx.beginPath();
+                ctx.arc(x, y, r, 0, Math.PI * 2, false);
+                ctx.stroke();
+                
+                colorIndex++; // Move to the next color in the array
+            }
+        }
+ 	drawPattern();
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/circle.html b/rubbish/circle.html
new file mode 100644
index 0000000..3be1287
--- /dev/null
+++ b/rubbish/circle.html
@@ -0,0 +1,51 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Circle Spokes</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="circleSpokesCanvas" width="500" height="500"></canvas>
+    <script>
+        const canvas = document.getElementById('circleSpokesCanvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const radius = 200;
+        const numberOfSpokes = 20;
+
+        // Draw the circle
+        ctx.beginPath();
+        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
+        ctx.stroke();
+
+        // Draw the spokes
+        for (let i = 0; i < numberOfSpokes; i++) {
+            const angle = (i / numberOfSpokes) * 2 * Math.PI;
+            const x = centerX + radius * Math.cos(angle);
+            const y = centerY + radius * Math.sin(angle);
+
+            ctx.beginPath();
+            ctx.moveTo(centerX, centerY);
+            ctx.lineTo(x, y);
+            ctx.stroke();
+        }
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/circle2.html b/rubbish/circle2.html
new file mode 100644
index 0000000..c3c7a44
--- /dev/null
+++ b/rubbish/circle2.html
@@ -0,0 +1,85 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Draw Circles with Polar Coordinates</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+        #controls {
+            position: absolute;
+            top: 20px;
+            left: 20px;
+        }
+    </style>
+</head>
+<body>
+    <div id="controls">
+        <label for="radius">Radius: </label>
+        <input type="number" id="radius" value="50">
+        <input type="number" id="nodenumber" value="2">
+        <button onclick="drawCircle()">Draw Circle</button>
+    </div>
+    <canvas id="canvas" width="800" height="600"></canvas>
+
+    <script>
+        const canvas = document.getElementById('canvas');
+        const context = canvas.getContext('2d');
+
+        canvas.addEventListener('click', (event) => {
+            const rect = canvas.getBoundingClientRect();
+            const x = event.clientX - rect.left;
+            const y = event.clientY - rect.top;
+            const radius = parseInt(document.getElementById('radius').value, 10);
+            const radius2 = 2 * parseInt(document.getElementById('radius').value, 10);
+            const nodenumber = parseInt(document.getElementById('nodenumber').value, 2);
+            const delta0 = (Math.PI / 15);
+            for (let delta = 0; delta <= Math.PI * 2; delta += delta0) {
+            	drawCirclePolar(x, y, radius, radius2, nodenumber, delta);
+	    }
+        });
+
+        function drawCirclePolar(centerX, centerY, radius, radius2, nodenumber, delta) {
+            context.beginPath();
+            for (let angle = 0; angle <= 360; angle++) {
+                const theta = angle * (Math.PI / 180);
+                const x = centerX + ( radius2 + radius * Math.cos(nodenumber*theta + delta)) * Math.cos(theta + delta);
+                const y = centerY + ( radius2 + radius * Math.cos(nodenumber*theta + delta)) * Math.sin(theta + delta);
+                if (angle === 0) {
+                    context.moveTo(x, y);
+                } else {
+                    context.lineTo(x, y);
+                }
+            }
+            context.closePath();
+            //context.fillStyle = 'blue';
+            //context.fill();
+            context.stroke();
+        }
+
+        function drawCircle() {
+            const radius = parseInt(document.getElementById('radius').value, 10);
+            const radius2 = 2 * parseInt(document.getElementById('radius').value, 10);
+            const nodenumber = parseInt(document.getElementById('nodenumber').value, 2);
+            const x = canvas.width / 2;
+            const y = canvas.height / 2;
+            const delta0 = (Math.PI / 15);
+            for (let delta = 0; delta <= Math.PI * 2; delta += delta0) {
+            	drawCirclePolar(x, y, radius, radius2, nodenumber, delta);
+	    }
+        }
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/circle_color.html b/rubbish/circle_color.html
new file mode 100644
index 0000000..38b532a
--- /dev/null
+++ b/rubbish/circle_color.html
@@ -0,0 +1,61 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Circle Spokes with Different Colors</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="circleSpokesCanvas" width="500" height="500"></canvas>
+    <script>
+        const canvas = document.getElementById('circleSpokesCanvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const radius = 200;
+        const numberOfSpokes = 20;
+
+        // Function to generate a random color
+        function getRandomColor() {
+            const letters = '0123456789ABCDEF';
+            let color = '#';
+            for (let i = 0; i < 6; i++) {
+                color += letters[Math.floor(Math.random() * 16)];
+            }
+            return color;
+        }
+
+        // Draw the circle
+        ctx.beginPath();
+        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
+        ctx.stroke();
+
+        // Draw the spokes
+        for (let i = 0; i < numberOfSpokes; i++) {
+            const angle = (i / numberOfSpokes) * 2 * Math.PI;
+            const x = centerX + radius * Math.cos(angle);
+            const y = centerY + radius * Math.sin(angle);
+
+            ctx.beginPath();
+            ctx.moveTo(centerX, centerY);
+            ctx.lineTo(x, y);
+            ctx.strokeStyle = getRandomColor();
+            ctx.stroke();
+        }
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/concentric.html b/rubbish/concentric.html
new file mode 100644
index 0000000..2d6fe57
--- /dev/null
+++ b/rubbish/concentric.html
@@ -0,0 +1,67 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Canvas Pattern</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #fff;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="patternCanvas" width="500" height="500"></canvas>
+    <script>
+        const canvas = document.getElementById('patternCanvas');
+        const ctx = canvas.getContext('2d');
+        const width = canvas.width;
+        const height = canvas.height;
+        const radius = 100;
+        const lineWidth = 2;
+
+        ctx.lineWidth = lineWidth;
+
+        const colors = ['#FF5733', '#33FF57', '#3357FF', '#FF33A1', '#A133FF']; // Array of colors
+        const numColors = colors.length;
+        let baseColorIndex = 0;
+
+        function drawPattern() {
+            ctx.clearRect(0, 0, width, height); // Clear the canvas
+
+            const offsetX = width / 2;
+            const offsetY = height / 2;
+            const spacing = 10;
+
+            drawArcs(offsetX, offsetY, radius, spacing);
+        }
+
+        function drawArcs(x, y, radius, spacing) {
+            let colorIndex = baseColorIndex;
+
+            for (let r = radius; r > 0; r -= spacing) {
+                ctx.strokeStyle = colors[colorIndex % numColors];
+                ctx.beginPath();
+                ctx.arc(x, y, r, 0, Math.PI * 2, false);
+                ctx.stroke();
+                
+                colorIndex++; // Move to the next color in the array
+            }
+
+            baseColorIndex = (baseColorIndex + 1) % numColors; // Shift the base color index for the next frame
+        }
+
+        setInterval(drawPattern, 100); // Redraw the pattern every 100ms
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/counter_rotating_sector.html b/rubbish/counter_rotating_sector.html
new file mode 100644
index 0000000..ced0a92
--- /dev/null
+++ b/rubbish/counter_rotating_sector.html
@@ -0,0 +1,59 @@
+<!DOCTYPE html>
+<html>
+<body>
+
+<canvas id="illusionCanvas" width="1200" height="1200"></canvas>
+
+<script>
+// Function to draw a sector of a circle and radially cut it into half
+function drawSector(ctx, x, y, radius, startAngle, endAngle, fillColor) {
+    ctx.beginPath(); // Start a new path
+    ctx.moveTo(x, y); // Move to the center of the circle
+    ctx.arc(x, y, radius, startAngle, endAngle); // Draw the outer arc
+    ctx.closePath(); // Create a straight line back to the center of the circle
+    ctx.fillStyle = fillColor; // Set the fill color
+    ctx.fill(); // Fill the sector with color
+    ctx.strokeStyle = 'white'; // Fill the sector with color
+    ctx.stroke(); // Draw the line
+}
+
+// Get the canvas element and its context
+const canvas = document.getElementById('illusionCanvas');
+const ctx = canvas.getContext('2d');
+var shift_angle = 0;
+var shift_angle1 = 0; // counter-rotating
+var sub_shift_angle = 2 * Math.PI / 180; // Slow rotation for the pentagon
+
+function draw() {
+
+    shift_angle += sub_shift_angle;
+    shift_angle1 -= sub_shift_angle;
+    ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
+
+    //draw_rotating_spoke(spokeCenterX, spokeCenterY, maxRadius / 5, sub_shift_angle); // Draw each spoke
+// Example usage: Draw a sector of a circle and radially cut it into half
+// Parameters: context, centerX, centerY, radius, startAngle, endAngle, fillColor
+var ngon = 6;
+var mysize = Math.PI * 2/ngon;
+var mysize_diff = mysize/10;
+
+for (let angle = 0.0; angle < 2*Math.PI; angle += mysize) {
+drawSector(ctx, 200, 200, 100, angle+shift_angle, angle+mysize-mysize_diff+shift_angle, 'blue'); // Drawing and cutting a quarter circle sector
+drawSector(ctx, 200, 200, 3*100/4, angle+shift_angle, angle+mysize-mysize_diff+shift_angle, 'white'); // Drawing and cutting a quarter circle sector
+drawSector(ctx, 200, 200, 100/2, angle+shift_angle1, angle+mysize-mysize_diff+shift_angle1, 'blue'); // Drawing and cutting a quarter circle sector
+drawSector(ctx, 200, 200, 100/4, angle+shift_angle1, angle+mysize-mysize_diff+shift_angle1, 'white'); // Drawing and cutting a quarter circle sector
+drawSector(ctx, 400, 400, 100/2, angle+shift_angle1, angle+mysize-mysize_diff+shift_angle1, 'blue'); // Drawing and cutting a quarter circle sector
+drawSector(ctx, 400, 400, 100/4, angle+shift_angle1, angle+mysize-mysize_diff+shift_angle1, 'white'); // Drawing and cutting a quarter circle sector
+}
+    window.requestAnimationFrame(draw); // Continue the animation
+}
+
+
+
+
+draw();
+</script>
+
+</body>
+</html>
+
diff --git a/rubbish/css_3dcube.html b/rubbish/css_3dcube.html
new file mode 100644
index 0000000..d726af2
--- /dev/null
+++ b/rubbish/css_3dcube.html
@@ -0,0 +1,78 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+  <meta charset="UTF-8">
+  <meta name="viewport" content="width=device-width, initial-scale=1.0">
+  <title>3D Rotating Cube</title>
+  <style>
+    /* Add the CSS code here */
+body {
+  display: flex;
+  justify-content: center;
+  align-items: center;
+  height: 100vh;
+  background-color: #f0f0f0;
+  margin: 0;
+  perspective: 1000px;
+}
+
+.cube {
+  position: relative;
+  width: 200px;
+  transform-style: preserve-3d;
+  animation: rotateCube 2s infinite linear;
+}
+
+.face {
+  position: absolute;
+  width: 200px;
+  height: 200px;
+  background: rgba(0, 128, 255, 0.7);
+  border: 1px solid #000;
+  display: flex;
+  justify-content: center;
+  align-items: center;
+  font-size: 24px;
+  color: white;
+}
+
+.front  { transform: translateZ(100px); }
+.back   { transform: rotateY(180deg) translateZ(100px); }
+.right  { transform: rotateY(90deg) translateZ(100px); }
+.left   { transform: rotateY(-90deg) translateZ(100px); }
+.top    { transform: rotateX(90deg) translateZ(100px); }
+.bottom { transform: rotateX(-90deg) translateZ(100px); }
+
+@keyframes rotateCube {
+  0% {
+    transform: rotateX(0deg) rotateY(0deg) rotateZ(0deg);
+  }
+  33% {
+    transform: rotateX(360deg) rotateY(0deg) rotateZ(0deg);
+  }
+  66% {
+    transform: rotateX(360deg) rotateY(360deg) rotateZ(0deg);
+  }
+  100% {
+    transform: rotateX(360deg) rotateY(360deg) rotateZ(360deg);
+  }
+}
+
+
+  </style>
+</head>
+<body>
+  <div class="cube">
+    <div class="face front">Front</div>
+    <div class="face back">Back</div>
+    <div class="face right">Right</div>
+    <div class="face left">Left</div>
+    <div class="face top">Top</div>
+    <div class="face bottom">Bottom</div>
+  </div>
+</body>
+</html>
+
+
+
diff --git a/rubbish/css_circle.html b/rubbish/css_circle.html
new file mode 100644
index 0000000..442e404
--- /dev/null
+++ b/rubbish/css_circle.html
@@ -0,0 +1,19 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Circle Slider</title>
+    <link rel="stylesheet" href="css_style.css">
+</head>
+<body>
+    <div class="container">
+        <input type="range" id="radiusSlider" min="10" max="200" value="50">
+        <button id="startButton">Start</button>
+        <canvas id="circleCanvas"></canvas>
+    </div>
+    <script src="css_script.js"></script>
+</body>
+</html>
+
diff --git a/rubbish/css_circle1.html b/rubbish/css_circle1.html
new file mode 100644
index 0000000..5eb5f9a
--- /dev/null
+++ b/rubbish/css_circle1.html
@@ -0,0 +1,20 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Circle Slider</title>
+    <link rel="stylesheet" href="css_style1.css">
+</head>
+<body>
+    <div class="container">
+        <input type="range" id="radiusSlider" min="10" max="200" value="100">
+        <input type="number" id="innerCircleCount" min="1" max="100" value="20">
+        <button id="startButton">Start</button>
+        <canvas id="circleCanvas"></canvas>
+    </div>
+    <script src="css_script1.js"></script>
+</body>
+</html>
+
diff --git a/rubbish/d3_graph.html b/rubbish/d3_graph.html
new file mode 100644
index 0000000..6cb3629
--- /dev/null
+++ b/rubbish/d3_graph.html
@@ -0,0 +1,18 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <title>Scatter Plot with D3.js</title>
+    <script src="https://d3js.org/d3.v7.min.js"></script>
+    <style>
+        .dot {
+            fill: steelblue;
+        }
+    </style>
+</head>
+<body>
+    <svg width="800" height="600"></svg>
+    <script src="d3_graph.js"></script>
+</body>
+</html>
+
diff --git a/rubbish/double.html b/rubbish/double.html
new file mode 100644
index 0000000..dc4252e
--- /dev/null
+++ b/rubbish/double.html
@@ -0,0 +1,55 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Complex Line Drawing</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #333;
+        }
+        canvas {
+            border: 1px solid black;
+            background-color: #333;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="complexLineCanvas" width="600" height="600"></canvas>
+    <script>
+        const canvas = document.getElementById('complexLineCanvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const numLines = 160;
+
+        // Function to draw the complex pattern
+        function drawComplexPattern() {
+            ctx.strokeStyle = '#ffffff';
+            ctx.lineWidth = 0.5;
+            for (let i = 0; i < numLines; i++) {
+                const angle1 = (i / numLines) * 2 * Math.PI;
+                const angle2 = ((i + 180) / numLines) * 2 * Math.PI;
+                const x1 = centerX + 100 * Math.cos(angle1) * Math.sin(angle2);
+                const y1 = centerY + 200 * Math.sin(angle1) * Math.sin(angle2);
+                const x2 = centerX + 300 * Math.cos(angle2) * Math.sin(angle1);
+                const y2 = centerY + 400 * Math.sin(angle2) * Math.sin(angle1);
+
+                ctx.beginPath();
+                ctx.moveTo(x1, y1);
+                ctx.lineTo(x2, y2);
+                ctx.stroke();
+            }
+        }
+
+        drawComplexPattern();
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/double1.html b/rubbish/double1.html
new file mode 100644
index 0000000..70d5931
--- /dev/null
+++ b/rubbish/double1.html
@@ -0,0 +1,55 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Complex Line Drawing</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #333;
+        }
+        canvas {
+            border: 1px solid black;
+            background-color: #333;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="complexLineCanvas" width="600" height="600"></canvas>
+    <script>
+        const canvas = document.getElementById('complexLineCanvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const numLines = 360;
+
+        // Function to draw the complex pattern
+        function drawComplexPattern() {
+            ctx.strokeStyle = '#ffffff';
+            ctx.lineWidth = 0.5;
+            for (let i = 0; i < numLines; i++) {
+                const angle1 = (i / numLines) * 2 * Math.PI;
+                const angle2 = ((i + 180) / numLines) * 2 * Math.PI;
+                const x1 = centerX + 100 * Math.cos(angle1) * Math.sin(angle2);
+                const y1 = centerY + 100 * Math.sin(angle1) * Math.sin(angle2);
+                const x2 = centerX + 100 * Math.cos(angle2) * Math.sin(angle1);
+                const y2 = centerY + 100 * Math.sin(angle2) * Math.sin(angle1);
+
+                ctx.beginPath();
+                ctx.moveTo(x1, y1);
+                ctx.lineTo(x2, y2);
+                ctx.stroke();
+            }
+        }
+
+        drawComplexPattern();
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/double3.html b/rubbish/double3.html
new file mode 100644
index 0000000..c1cb63d
--- /dev/null
+++ b/rubbish/double3.html
@@ -0,0 +1,55 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Complex Line Drawing</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #333;
+        }
+        canvas {
+            border: 1px solid black;
+            background-color: #333;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="complexLineCanvas" width="600" height="600"></canvas>
+    <script>
+        const canvas = document.getElementById('complexLineCanvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const numLines = 360;
+
+        // Function to draw the complex pattern
+        function drawComplexPattern() {
+            ctx.strokeStyle = '#ffffff';
+            ctx.lineWidth = 0.5;
+            for (let i = 0; i < numLines; i++) {
+                const angle1 = (i / numLines) * 2 * Math.PI;
+                const angle2 = ((i + 180) / numLines) * 2 * Math.PI;
+                const x1 = centerX + 100 * Math.cos(2*angle1) * Math.sin(angle2);
+                const y1 = centerY + 200 * Math.sin(3*angle1) * Math.sin(angle2);
+                const x2 = centerX + 300 * Math.cos(angle2) * Math.sin(angle1);
+                const y2 = centerY + 400 * Math.sin(angle2) * Math.sin(angle1);
+
+                ctx.beginPath();
+                ctx.moveTo(x1, y1);
+                ctx.lineTo(x2, y2);
+                ctx.stroke();
+            }
+        }
+
+        drawComplexPattern();
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/double4.html b/rubbish/double4.html
new file mode 100644
index 0000000..57f833b
--- /dev/null
+++ b/rubbish/double4.html
@@ -0,0 +1,55 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Complex Line Drawing</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #333;
+        }
+        canvas {
+            border: 1px solid black;
+            background-color: #333;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="complexLineCanvas" width="600" height="600"></canvas>
+    <script>
+        const canvas = document.getElementById('complexLineCanvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const numLines = 360;
+
+        // Function to draw the complex pattern
+        function drawComplexPattern() {
+            ctx.strokeStyle = '#ffffff';
+            ctx.lineWidth = 0.5;
+            for (let i = 0; i < numLines; i++) {
+                const angle1 = (i / numLines) * 2 * Math.PI;
+                const angle2 = ((i + 180) / numLines) * 2 * Math.PI;
+                const x1 = centerX + 100 * Math.cos(2*angle1) * Math.sin(angle2);
+                const y1 = centerY + 200 * Math.sin(4*angle1) * Math.sin(angle2);
+                const x2 = centerX + 300 * Math.cos(angle2) * Math.sin(angle1);
+                const y2 = centerY + 400 * Math.sin(angle2) * Math.sin(angle1);
+
+                ctx.beginPath();
+                ctx.moveTo(x1, y1);
+                ctx.lineTo(x2, y2);
+                ctx.stroke();
+            }
+        }
+
+        drawComplexPattern();
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/double5.html b/rubbish/double5.html
new file mode 100644
index 0000000..219e083
--- /dev/null
+++ b/rubbish/double5.html
@@ -0,0 +1,55 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Complex Line Drawing</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #333;
+        }
+        canvas {
+            border: 1px solid black;
+            background-color: #333;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="complexLineCanvas" width="600" height="600"></canvas>
+    <script>
+        const canvas = document.getElementById('complexLineCanvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const numLines = 360;
+
+        // Function to draw the complex pattern
+        function drawComplexPattern() {
+            ctx.strokeStyle = '#ffffff';
+            ctx.lineWidth = 0.5;
+            for (let i = 0; i < numLines; i++) {
+                const angle1 = (i / numLines) * 2 * Math.PI;
+                const angle2 = ((i + 180) / numLines) * 2 * Math.PI;
+                const x1 = centerX + 100 * Math.cos(angle1) * Math.sin(angle2);
+                const y1 = centerY + 100 * Math.sin(angle1) * Math.sin(angle2);
+                const x2 = centerX + 400 * Math.cos(angle2) * Math.sin(angle1);
+                const y2 = centerY + 400 * Math.sin(angle2) * Math.sin(angle1);
+
+                ctx.beginPath();
+                ctx.moveTo(x1, y1);
+                ctx.lineTo(x2, y2);
+                ctx.stroke();
+            }
+        }
+
+        drawComplexPattern();
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/double_motion.html b/rubbish/double_motion.html
new file mode 100644
index 0000000..45e845c
--- /dev/null
+++ b/rubbish/double_motion.html
@@ -0,0 +1,71 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Dynamic Complex Line Drawing</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #333;
+        }
+        canvas {
+            border: 1px solid black;
+            background-color: #333;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="complexLineCanvas" width="600" height="600"></canvas>
+    <script>
+        const canvas = document.getElementById('complexLineCanvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const numLines = 360;
+
+        let angleMultiplier1 = 2;
+        let angleMultiplier2 = 4;
+        let radius1 = 100;
+        let radius2 = 400;
+        let angleOffset = 0;
+
+        // Function to draw the complex pattern
+        function drawComplexPattern() {
+            ctx.clearRect(0, 0, canvas.width, canvas.height);
+            ctx.strokeStyle = '#ffffff';
+            ctx.lineWidth = 0.5;
+
+            for (let i = 0; i < numLines; i++) {
+                const angle1 = (i / numLines) * 2 * Math.PI;
+                const angle2 = ((i + 180) / numLines) * 2 * Math.PI;
+                const x1 = centerX + radius1 * Math.cos(angleMultiplier1 * (angle1 + angleOffset)) * Math.sin(angle2 + angleOffset);
+                const y1 = centerY + radius1 * Math.sin(angleMultiplier2 * (angle1 + angleOffset)) * Math.sin(angle2 + angleOffset);
+                const x2 = centerX + radius2 * Math.cos(angle2 + angleOffset) * Math.sin(angle1 + angleOffset);
+                const y2 = centerY + radius2 * Math.sin(angle2 + angleOffset) * Math.sin(angle1 + angleOffset);
+
+                ctx.beginPath();
+                ctx.moveTo(x1, y1);
+                ctx.lineTo(x2, y2);
+                ctx.stroke();
+            }
+
+            // Update parameters to create animation
+            angleOffset += 0.01;
+            angleMultiplier1 = 2 + Math.sin(angleOffset) * 2;
+            angleMultiplier2 = 4 + Math.cos(angleOffset) * 2;
+            radius1 = 100 + Math.sin(angleOffset) * 50;
+            radius2 = 400 + Math.cos(angleOffset) * 50;
+
+            requestAnimationFrame(drawComplexPattern);
+        }
+
+        drawComplexPattern();
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/drawsector.html b/rubbish/drawsector.html
new file mode 100644
index 0000000..da0f186
--- /dev/null
+++ b/rubbish/drawsector.html
@@ -0,0 +1,13 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <title>Sector of a Circle</title>
+</head>
+<body>
+    <canvas id="circleSector" width="400" height="400"></canvas>
+    <script src="drawsector2.js"></script>
+</body>
+</html>
+
diff --git a/rubbish/ellipse.html b/rubbish/ellipse.html
new file mode 100644
index 0000000..327e8d4
--- /dev/null
+++ b/rubbish/ellipse.html
@@ -0,0 +1,51 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Circle Spokes</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="circleSpokesCanvas" width="500" height="500"></canvas>
+    <script>
+        const canvas = document.getElementById('circleSpokesCanvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const radius = 200;
+        const numberOfSpokes = 50;
+
+        // Draw the circle
+        ctx.beginPath();
+        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
+        ctx.stroke();
+
+        // Draw the spokes
+        for (let i = 0; i < numberOfSpokes; i++) {
+            const angle = (i / numberOfSpokes) * 2 * Math.PI;
+            const x = centerX + 1.5 * radius * Math.cos(angle);
+            const y = centerY + radius * Math.sin(2*angle);
+
+            ctx.beginPath();
+            ctx.moveTo(centerX, centerY);
+            ctx.lineTo(x, y);
+            ctx.stroke();
+        }
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/ellipse2.html b/rubbish/ellipse2.html
new file mode 100644
index 0000000..43d1021
--- /dev/null
+++ b/rubbish/ellipse2.html
@@ -0,0 +1,80 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Rotating Ellipses</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+        #controls {
+            position: absolute;
+            top: 20px;
+            left: 20px;
+        }
+    </style>
+</head>
+<body>
+    <div id="controls">
+        <label for="radiusX">Radius X: </label>
+        <input type="number" id="radiusX" value="100">
+        <label for="radiusY">Radius Y: </label>
+        <input type="number" id="radiusY" value="50">
+        <button onclick="drawEllipse()">Draw Ellipse</button>
+    </div>
+    <canvas id="canvas" width="800" height="600"></canvas>
+
+    <script>
+        const canvas = document.getElementById('canvas');
+        const context = canvas.getContext('2d');
+        let ellipses = [];
+
+        canvas.addEventListener('click', (event) => {
+            const rect = canvas.getBoundingClientRect();
+            const x = event.clientX - rect.left;
+            const y = event.clientY - rect.top;
+            const radiusX = parseInt(document.getElementById('radiusX').value, 10);
+            const radiusY = parseInt(document.getElementById('radiusY').value, 10);
+            ellipses.push({x: x, y: y, radiusX: radiusX, radiusY: radiusY, angle: 0});
+        });
+
+        function drawEllipse() {
+            const radiusX = parseInt(document.getElementById('radiusX').value, 10);
+            const radiusY = parseInt(document.getElementById('radiusY').value, 10);
+            const x = canvas.width / 2;
+            const y = canvas.height / 2;
+            ellipses.push({x: x, y: y, radiusX: radiusX, radiusY: radiusY, angle: 0});
+        }
+
+        function drawEllipses() {
+            context.clearRect(0, 0, canvas.width, canvas.height);
+            ellipses.forEach(ellipse => {
+                context.save();
+                context.translate(ellipse.x, ellipse.y);
+                context.rotate(ellipse.angle);
+                context.beginPath();
+                context.ellipse(0, 0, ellipse.radiusX, ellipse.radiusY, 0, 0, 2 * Math.PI);
+                context.fillStyle = 'blue';
+                context.fill();
+                context.stroke();
+                context.restore();
+                ellipse.angle += 0.01;
+            });
+            requestAnimationFrame(drawEllipses);
+        }
+
+        drawEllipses();
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/ellipse3.html b/rubbish/ellipse3.html
new file mode 100644
index 0000000..183ed7f
--- /dev/null
+++ b/rubbish/ellipse3.html
@@ -0,0 +1,88 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Rotating Ellipses</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+        #controls {
+            position: absolute;
+            top: 20px;
+            left: 20px;
+        }
+    </style>
+</head>
+<body>
+    <div id="controls">
+        <label for="radiusX">Radius X: </label>
+        <input type="number" id="radiusX" value="100">
+        <label for="radiusY">Radius Y: </label>
+        <input type="number" id="radiusY" value="50">
+        <button onclick="drawEllipse()">Draw Ellipse</button>
+    </div>
+    <canvas id="canvas" width="800" height="600"></canvas>
+    
+    <script>
+        const canvas = document.getElementById('canvas');
+        const context = canvas.getContext('2d');
+        let ellipses = [];
+
+        canvas.addEventListener('click', (event) => {
+            const rect = canvas.getBoundingClientRect();
+            const x = event.clientX - rect.left;
+            const y = event.clientY - rect.top;
+            const radiusX = parseInt(document.getElementById('radiusX').value, 10);
+            const radiusY = parseInt(document.getElementById('radiusY').value, 10);
+            ellipses.push({x: x, y: y, radiusX: radiusX, radiusY: radiusY, angle: 0});
+            drawEllipseAtPosition(x, y, radiusX, radiusY);
+        });
+
+        function drawEllipseAtPosition(x, y, radiusX, radiusY) {
+            context.beginPath();
+            context.ellipse(x, y, radiusX, radiusY, 0, 0, 2 * Math.PI);
+            context.fillStyle = 'blue';
+            context.fill();
+            context.stroke();
+        }
+
+        function drawEllipse() {
+            const radiusX = parseInt(document.getElementById('radiusX').value, 10);
+            const radiusY = parseInt(document.getElementById('radiusY').value, 10);
+            const x = canvas.width / 2;
+            const y = canvas.height / 2;
+            ellipses.push({x: x, y: y, radiusX: radiusX, radiusY: radiusY, angle: 0});
+            drawEllipseAtPosition(x, y, radiusX, radiusY);
+        }
+
+        function animateEllipses() {
+            ellipses.forEach(ellipse => {
+                context.save();
+                context.translate(ellipse.x, ellipse.y);
+                context.rotate(ellipse.angle);
+                context.beginPath();
+                context.ellipse(0, 0, ellipse.radiusX, ellipse.radiusY, 0, 0, 2 * Math.PI);
+                context.fillStyle = 'blue';
+                context.fill();
+                context.stroke();
+                context.restore();
+                ellipse.angle += 0.2;
+            });
+            requestAnimationFrame(animateEllipses);
+        }
+
+        animateEllipses();
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/ellipse4.html b/rubbish/ellipse4.html
new file mode 100644
index 0000000..6500d9b
--- /dev/null
+++ b/rubbish/ellipse4.html
@@ -0,0 +1,96 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Rotating Ellipses</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+        #controls {
+            position: absolute;
+            top: 20px;
+            left: 20px;
+        }
+    </style>
+</head>
+<body>
+    <div id="controls">
+        <label for="radiusX">Radius X: </label>
+        <input type="number" id="radiusX" value="100">
+        <label for="radiusY">Radius Y: </label>
+        <input type="number" id="radiusY" value="50">
+        <button onclick="drawEllipse()">Draw Ellipse</button>
+    </div>
+    <canvas id="canvas" width="800" height="600"></canvas>
+    
+    <script>
+        const canvas = document.getElementById('canvas');
+        const context = canvas.getContext('2d');
+        let ellipses = [];
+        let centerX = canvas.width / 2;
+        let centerY = canvas.height / 2;
+        let traverseAngle = 0;
+        const traverseRadius = 50;
+
+        canvas.addEventListener('click', (event) => {
+            const radiusX = parseInt(document.getElementById('radiusX').value, 10);
+            const radiusY = parseInt(document.getElementById('radiusY').value, 10);
+            drawEllipseAtPosition(centerX, centerY, radiusX, radiusY);
+            ellipses.push({x: centerX, y: centerY, radiusX: radiusX, radiusY: radiusY, angle: 0});
+            updateCenter();
+        });
+
+        function drawEllipseAtPosition(x, y, radiusX, radiusY) {
+            context.beginPath();
+            context.ellipse(x, y, radiusX, radiusY, 0, 0, 2 * Math.PI);
+            context.fillStyle = 'blue';
+            context.fill();
+            context.stroke();
+        }
+
+        function drawEllipse() {
+            const radiusX = parseInt(document.getElementById('radiusX').value, 10);
+            const radiusY = parseInt(document.getElementById('radiusY').value, 10);
+            drawEllipseAtPosition(centerX, centerY, radiusX, radiusY);
+            ellipses.push({x: centerX, y: centerY, radiusX: radiusX, radiusY: radiusY, angle: 0});
+            updateCenter();
+        }
+
+        function updateCenter() {
+            traverseAngle += Math.PI / 12;  // Update the angle by 30 degrees
+            centerX = canvas.width / 2 + traverseRadius * Math.cos(4*traverseAngle);
+            centerY = canvas.height / 2 + traverseRadius * Math.sin(4*traverseAngle);
+        }
+
+        function animateEllipses() {
+            ellipses.forEach(ellipse => {
+                context.save();
+                context.translate(ellipse.x, ellipse.y);
+                context.rotate(ellipse.angle);
+                context.beginPath();
+                context.ellipse(0, 0, ellipse.radiusX, ellipse.radiusY, 0, 0, 2 * Math.PI);
+                context.fillStyle = 'blue';
+                context.fill();
+                context.stroke();
+                context.restore();
+                ellipse.angle += 0.2;
+            	updateCenter();
+            	//ellipses.push({x: centerX, y: centerY, radiusX: radiusX, radiusY: radiusY, angle: 0});
+            });
+            requestAnimationFrame(animateEllipses);
+        }
+
+        animateEllipses();
+    </script>
+</body>
+</html>
diff --git a/rubbish/ellipse_color.html b/rubbish/ellipse_color.html
new file mode 100644
index 0000000..0864dec
--- /dev/null
+++ b/rubbish/ellipse_color.html
@@ -0,0 +1,61 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Circle Spokes with Different Colors</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="circleSpokesCanvas" width="500" height="500"></canvas>
+    <script>
+        const canvas = document.getElementById('circleSpokesCanvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const radius = 200;
+        const numberOfSpokes = 20;
+
+        // Function to generate a random color
+        function getRandomColor() {
+            const letters = '0123456789ABCDEF';
+            let color = '#';
+            for (let i = 0; i < 6; i++) {
+                color += letters[Math.floor(Math.random() * 16)];
+            }
+            return color;
+        }
+
+        // Draw the circle
+        ctx.beginPath();
+        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
+        ctx.stroke();
+
+        // Draw the spokes
+        for (let i = 0; i < numberOfSpokes; i++) {
+            const angle = (i / numberOfSpokes) * 2 * Math.PI;
+            const x = centerX + 2 * radius * Math.cos(angle);
+            const y = centerY + radius * Math.sin(3*angle);
+
+            ctx.beginPath();
+            ctx.moveTo(centerX, centerY);
+            ctx.lineTo(x, y);
+            ctx.strokeStyle = getRandomColor();
+            ctx.stroke();
+        }
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/ellipse_color2.html b/rubbish/ellipse_color2.html
new file mode 100644
index 0000000..42b3fbc
--- /dev/null
+++ b/rubbish/ellipse_color2.html
@@ -0,0 +1,63 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Circle Spokes with Different Colors</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="circleSpokesCanvas" width="500" height="500"></canvas>
+    <script>
+        const canvas = document.getElementById('circleSpokesCanvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const radius = 200;
+        const numberOfSpokes = 20;
+
+        // Function to generate a random color
+        function getRandomColor() {
+            const letters = '0123456789ABCDEF';
+            let color = '#';
+            for (let i = 0; i < 6; i++) {
+                color += letters[Math.floor(Math.random() * 16)];
+            }
+            return color;
+        }
+
+        // Draw the circle
+        ctx.beginPath();
+        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
+        ctx.stroke();
+
+        // Draw the spokes
+        for (let i = 0; i < numberOfSpokes; i++) {
+            const angle = (i / numberOfSpokes) * 2 * Math.PI;
+            centerX =  2 * radius * Math.cos(angle);
+            centerY = radius * Math.sin(3*angle);
+            const x = centerX + 2 * radius * Math.cos(angle);
+            const y = centerY + radius * Math.sin(3*angle);
+
+            ctx.beginPath();
+            ctx.moveTo(centerX, centerY);
+            ctx.lineTo(x, y);
+            ctx.strokeStyle = getRandomColor();
+            ctx.stroke();
+        }
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/ellipsical_line.html b/rubbish/ellipsical_line.html
new file mode 100644
index 0000000..4731aae
--- /dev/null
+++ b/rubbish/ellipsical_line.html
@@ -0,0 +1,28 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Ellipse Animation</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            background-color: white;
+            border: 1px solid #ccc;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="animationCanvas" width="600" height="600"></canvas>
+    <script src="ellipsical_line.js"></script>
+</body>
+</html>
+
diff --git a/rubbish/ellipsical_line_rotate.html b/rubbish/ellipsical_line_rotate.html
new file mode 100644
index 0000000..2ef239d
--- /dev/null
+++ b/rubbish/ellipsical_line_rotate.html
@@ -0,0 +1,28 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Ellipse Animation</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            background-color: white;
+            border: 1px solid #ccc;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="animationCanvas" width="600" height="600"></canvas>
+    <script src="ellipsical_line_rotate.js"></script>
+</body>
+</html>
+
diff --git a/rubbish/figure_eight.html b/rubbish/figure_eight.html
new file mode 100644
index 0000000..d7b3ab5
--- /dev/null
+++ b/rubbish/figure_eight.html
@@ -0,0 +1,60 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>3D Figure Eight with Circles</title>
+    <style>
+        body { margin: 0; }
+        canvas { display: block; }
+    </style>
+</head>
+<body>
+    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
+    <script>
+        // Set up the scene, camera, and renderer
+        const scene = new THREE.Scene();
+        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
+        const renderer = new THREE.WebGLRenderer();
+        renderer.setSize(window.innerWidth, window.innerHeight);
+        document.body.appendChild(renderer.domElement);
+
+        // Create two circular curves
+        const radius = 5;
+        const segments = 64;
+        const curve1 = new THREE.EllipseCurve(0, 0, radius, radius, Math.PI, -Math.PI, true, 0);
+        const curve2 = new THREE.EllipseCurve(0, 0, radius, radius, 0, Math.PI, true, 0);
+
+        // Create points for each curve and join them together
+        const points1 = curve1.getPoints(segments);
+        const points2 = curve2.getPoints(segments);
+        const points = points1.concat(points2);
+
+        // Create geometry and material for the figure-eight line
+        const geometry = new THREE.BufferGeometry().setFromPoints(points);
+        const material = new THREE.LineBasicMaterial({ color: 0xff0000 });
+
+        // Create the figure-eight line
+        const figureEight = new THREE.Line(geometry, material);
+        scene.add(figureEight);
+
+        // Set the camera position
+        camera.position.z = 20;
+
+        // Animation loop
+        function animate() {
+            requestAnimationFrame(animate);
+            renderer.render(scene, camera);
+        }
+        animate();
+
+        // Handle window resize
+        window.addEventListener('resize', () => {
+            camera.aspect = window.innerWidth / window.innerHeight;
+            camera.updateProjectionMatrix();
+            renderer.setSize(window.innerWidth, window.innerHeight);
+        });
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/figure_eight2.html b/rubbish/figure_eight2.html
new file mode 100644
index 0000000..075a948
--- /dev/null
+++ b/rubbish/figure_eight2.html
@@ -0,0 +1,81 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>3D Figure Eight with Rotating Wheel</title>
+    <style>
+        body { margin: 0; }
+        canvas { display: block; }
+    </style>
+</head>
+<body>
+    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
+    <script>
+        // Set up the scene, camera, and renderer
+        const scene = new THREE.Scene();
+        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
+        const renderer = new THREE.WebGLRenderer();
+        renderer.setSize(window.innerWidth, window.innerHeight);
+        document.body.appendChild(renderer.domElement);
+
+        // Create the figure-eight path
+        const curve = new THREE.CatmullRomCurve3([
+            new THREE.Vector3(10, 0, 0),
+            new THREE.Vector3(5, 5, 0),
+            new THREE.Vector3(0, 0, 0),
+            new THREE.Vector3(-5, -5, 0),
+            new THREE.Vector3(-10, 0, 0),
+            new THREE.Vector3(-5, 5, 0),
+            new THREE.Vector3(0, 0, 0),
+            new THREE.Vector3(5, -5, 0),
+            new THREE.Vector3(10, 0, 0),
+        ]);
+        curve.closed = true;
+
+        const points = curve.getPoints(50);
+        const geometry = new THREE.BufferGeometry().setFromPoints(points);
+        const material = new THREE.LineBasicMaterial({ color: 0xff0000 });
+
+        // Create the figure-eight line
+        const figureEight = new THREE.Line(geometry, material);
+        scene.add(figureEight);
+
+        // Create a wheel
+        const wheelGeometry = new THREE.TorusGeometry(0.5, 0.2, 16, 100);
+        const wheelMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
+        const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
+        scene.add(wheel);
+
+        // Set the camera position
+        camera.position.z = 20;
+
+        // Animation loop
+        let t = 0;
+        function animate() {
+            requestAnimationFrame(animate);
+
+            // Update the wheel position
+            const point = curve.getPointAt(t);
+            wheel.position.set(point.x, point.y, point.z);
+
+            // Update the wheel rotation
+            const tangent = curve.getTangentAt(t).normalize();
+            wheel.quaternion.setFromUnitVectors(new THREE.Vector3(1, 0, 0), tangent);
+
+            t = (t + 0.001) % 1;  // Move along the curve
+
+            renderer.render(scene, camera);
+        }
+        animate();
+
+        // Handle window resize
+        window.addEventListener('resize', () => {
+            camera.aspect = window.innerWidth / window.innerHeight;
+            camera.updateProjectionMatrix();
+            renderer.setSize(window.innerWidth, window.innerHeight);
+        });
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/five_rotate_spoke.html b/rubbish/five_rotate_spoke.html
new file mode 100644
index 0000000..2913d23
--- /dev/null
+++ b/rubbish/five_rotate_spoke.html
@@ -0,0 +1,58 @@
+<!DOCTYPE html>
+<html>
+<body>
+
+<canvas id="illusionCanvas" width="1200" height="1200"></canvas>
+
+<script>
+const canvas = document.getElementById('illusionCanvas');
+const ctx = canvas.getContext('2d');
+
+const centerX = canvas.width / 2;
+const centerY = canvas.height / 2;
+const sector = 30; // Number of sectors in a spoke
+const maxRadius = Math.min(canvas.width, canvas.height) / 2;
+const pentagonRadius = maxRadius / 3; // Radius of the pentagon
+var sub_shift_angle = 0; // Angle for rotating the main spoke
+var pentagon_shift_angle = 0; // Angle for rotating the pentagon
+
+function draw_rotating_spoke(centerX, centerY, maxRadius, sub_shift_angle) {
+    for (let i = 0; i < sector; i++) {
+        let angle = (i / sector) * 2 * Math.PI;
+        let x = centerX + maxRadius * Math.cos(angle + sub_shift_angle);
+        let y = centerY + maxRadius * Math.sin(angle + sub_shift_angle);
+
+        ctx.strokeStyle = (i % 2 === 0) ? 'black' : 'blue';
+        ctx.lineWidth = 2;
+
+        ctx.beginPath();
+        ctx.moveTo(centerX, centerY);
+        ctx.lineTo(x, y);
+        ctx.stroke();
+    }
+}
+
+function draw() {
+    sub_shift_angle += 2 * Math.PI / sector / 10;
+    pentagon_shift_angle += 2 * Math.PI / 360; // Slow rotation for the pentagon
+
+    ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
+
+    // Draw 5 spokes, each at a vertex of a rotating pentagon
+    for (let i = 0; i < 5; i++) {
+        let angle = (i / 5) * 2 * Math.PI + pentagon_shift_angle; // Angle for pentagon vertices
+        let spokeCenterX = centerX + pentagonRadius * Math.cos(angle);
+        let spokeCenterY = centerY + pentagonRadius * Math.sin(angle);
+
+        draw_rotating_spoke(spokeCenterX, spokeCenterY, maxRadius / 5, sub_shift_angle); // Draw each spoke
+    }
+
+    window.requestAnimationFrame(draw); // Continue the animation
+}
+
+draw();
+</script>
+
+</body>
+</html>
+
diff --git a/rubbish/five_rotate_spoke_sector.html b/rubbish/five_rotate_spoke_sector.html
new file mode 100644
index 0000000..8cf6b80
--- /dev/null
+++ b/rubbish/five_rotate_spoke_sector.html
@@ -0,0 +1,65 @@
+<!DOCTYPE html>
+<html>
+<body>
+
+<canvas id="illusionCanvas" width="1200" height="1200"></canvas>
+
+<script>
+const canvas = document.getElementById('illusionCanvas');
+const ctx = canvas.getContext('2d');
+
+const centerX = canvas.width / 2;
+const centerY = canvas.height / 2;
+const sector = 30; // Number of sectors in a spoke
+const maxRadius = Math.min(canvas.width, canvas.height) / 2;
+const pentagonRadius = maxRadius / 3; // Radius of the pentagon
+var sub_shift_angle = 0; // Angle for rotating the main spoke
+var pentagon_shift_angle = 0; // Angle for rotating the pentagon
+
+// Define a set of colors for the sectors
+const colors = ['red', 'green', 'blue', 'yellow', 'purple'];
+
+function draw_rotating_spoke(centerX, centerY, maxRadius, sub_shift_angle) {
+    for (let i = 0; i < sector; i++) {
+        let angle = (i / sector) * 2 * Math.PI;
+        let endAngle = ((i + 1) / sector) * 2 * Math.PI;
+        let x1 = centerX + maxRadius * Math.cos(angle + sub_shift_angle);
+        let y1 = centerY + maxRadius * Math.sin(angle + sub_shift_angle);
+        let x2 = centerX + maxRadius * Math.cos(endAngle + sub_shift_angle);
+        let y2 = centerY + maxRadius * Math.sin(endAngle + sub_shift_angle);
+
+        ctx.fillStyle = colors[i % colors.length];
+
+        ctx.beginPath();
+        ctx.moveTo(centerX, centerY);
+        ctx.lineTo(x1, y1);
+        ctx.lineTo(x2, y2);
+        ctx.closePath();
+        ctx.fill();
+    }
+}
+
+function draw() {
+    sub_shift_angle += 2 * Math.PI / sector / 10;
+    pentagon_shift_angle += 2 * Math.PI / 360; // Slow rotation for the pentagon
+
+    ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
+
+    // Draw 5 spokes, each at a vertex of a rotating pentagon
+    for (let i = 0; i < 5; i++) {
+        let angle = (i / 5) * 2 * Math.PI + pentagon_shift_angle; // Angle for pentagon vertices
+        let spokeCenterX = centerX + pentagonRadius * Math.cos(angle);
+        let spokeCenterY = centerY + pentagonRadius * Math.sin(angle);
+
+        draw_rotating_spoke(spokeCenterX, spokeCenterY, maxRadius / 5, sub_shift_angle); // Draw each spoke
+    }
+
+    window.requestAnimationFrame(draw); // Continue the animation
+}
+
+draw();
+</script>
+
+</body>
+</html>
+
diff --git a/rubbish/four_petal.html b/rubbish/four_petal.html
new file mode 100644
index 0000000..b61f8ca
--- /dev/null
+++ b/rubbish/four_petal.html
@@ -0,0 +1,28 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Four-Petal Shape Animation</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            background-color: white;
+            border: 1px solid #ccc;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="animationCanvas" width="600" height="600"></canvas>
+    <script src="four_petal.js"></script>
+</body>
+</html>
+
diff --git a/rubbish/four_petal_double.html b/rubbish/four_petal_double.html
new file mode 100644
index 0000000..4c2bde2
--- /dev/null
+++ b/rubbish/four_petal_double.html
@@ -0,0 +1,28 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Four Petal Lines Animation</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            background-color: white;
+            border: 1px solid #ccc;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="animationCanvas" width="600" height="600"></canvas>
+    <script src="four_petal_double.js"></script>
+</body>
+</html>
+
diff --git a/rubbish/four_petal_rotate.html b/rubbish/four_petal_rotate.html
new file mode 100644
index 0000000..8676bcb
--- /dev/null
+++ b/rubbish/four_petal_rotate.html
@@ -0,0 +1,28 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Four Petal Lines Animation</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            background-color: white;
+            border: 1px solid #ccc;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="animationCanvas" width="600" height="600"></canvas>
+    <script src="four_petal_rotate.js"></script>
+</body>
+</html>
+
diff --git a/rubbish/icosahedron2.html b/rubbish/icosahedron2.html
new file mode 100644
index 0000000..825e019
--- /dev/null
+++ b/rubbish/icosahedron2.html
@@ -0,0 +1,182 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Icosahedron with Centroid Extensions</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="canvas" width="800" height="800"></canvas>
+    <script>
+        const canvas = document.getElementById('canvas');
+        const ctx = canvas.getContext('2d');
+        const width = canvas.width;
+        const height = canvas.height;
+        const centerX = width / 2;
+        const centerY = height / 2;
+        const scale = 100;
+
+        let angleX = 0;
+        let angleY = 0;
+
+        const vertices = [];
+        const faces = [];
+
+        function initIcosahedron() {
+            const phi = (1 + Math.sqrt(5)) / 2;
+
+            vertices.push([-1, phi, 0]);
+            vertices.push([1, phi, 0]);
+            vertices.push([-1, -phi, 0]);
+            vertices.push([1, -phi, 0]);
+
+            vertices.push([0, -1, phi]);
+            vertices.push([0, 1, phi]);
+            vertices.push([0, -1, -phi]);
+            vertices.push([0, 1, -phi]);
+
+            vertices.push([phi, 0, -1]);
+            vertices.push([phi, 0, 1]);
+            vertices.push([-phi, 0, -1]);
+            vertices.push([-phi, 0, 1]);
+
+            faces.push([0, 11, 5]);
+            faces.push([0, 5, 1]);
+            faces.push([0, 1, 7]);
+            faces.push([0, 7, 10]);
+            faces.push([0, 10, 11]);
+
+            faces.push([1, 5, 9]);
+            faces.push([5, 11, 4]);
+            faces.push([11, 10, 2]);
+            faces.push([10, 7, 6]);
+            faces.push([7, 1, 8]);
+
+            faces.push([3, 9, 4]);
+            faces.push([3, 4, 2]);
+            faces.push([3, 2, 6]);
+            faces.push([3, 6, 8]);
+            faces.push([3, 8, 9]);
+
+            faces.push([4, 9, 5]);
+            faces.push([2, 4, 11]);
+            faces.push([6, 2, 10]);
+            faces.push([8, 6, 7]);
+            faces.push([9, 8, 1]);
+        }
+
+        function rotateX(point, angle) {
+            const cos = Math.cos(angle);
+            const sin = Math.sin(angle);
+            const [x, y, z] = point;
+            return [
+                x,
+                y * cos - z * sin,
+                y * sin + z * cos
+            ];
+        }
+
+        function rotateY(point, angle) {
+            const cos = Math.cos(angle);
+            const sin = Math.sin(angle);
+            const [x, y, z] = point;
+            return [
+                x * cos + z * sin,
+                y,
+                -x * sin + z * cos
+            ];
+        }
+
+        function project(point) {
+            const [x, y, z] = point;
+            const perspective = 1 / (1 - z / 4);
+            return [
+                centerX + x * scale * perspective,
+                centerY - y * scale * perspective
+            ];
+        }
+
+        function calculateCentroid(face) {
+            const [v1, v2, v3] = face.map(i => vertices[i]);
+            const x = (v1[0] + v2[0] + v3[0]) / 3;
+            const y = (v1[1] + v2[1] + v3[1]) / 3;
+            const z = (v1[2] + v2[2] + v3[2]) / 3;
+            return [x, y, z];
+        }
+
+        function extendVector(point, scaleFactor) {
+            const [x, y, z] = point;
+            const length = Math.sqrt(x * x, y * y, z * z);
+            return [x * scaleFactor / length, y * scaleFactor / length, z * scaleFactor / length];
+        }
+
+        function drawIcosahedron() {
+            ctx.clearRect(0, 0, width, height);
+            ctx.strokeStyle = 'black';
+
+            const rotatedVertices = vertices.map(v => rotateY(rotateX(v, angleX), angleY));
+
+            faces.forEach(face => {
+                ctx.beginPath();
+                const projectedPoint = project(rotatedVertices[face[0]]);
+                ctx.moveTo(projectedPoint[0], projectedPoint[1]);
+
+                face.forEach(index => {
+                    const [x, y] = project(rotatedVertices[index]);
+                    ctx.lineTo(x, y);
+                });
+
+                ctx.closePath();
+                ctx.stroke();
+
+                // Calculate centroid and extend the vector
+                const centroid = calculateCentroid(face.map(i => rotatedVertices[i]));
+                const extendedPoint = extendVector(centroid, 1.2);
+
+                const projectedCentroid = project(centroid);
+                const projectedExtended = project(extendedPoint);
+
+                // Draw line from centroid to extended point
+                ctx.beginPath();
+                ctx.moveTo(projectedCentroid[0], projectedCentroid[1]);
+                ctx.lineTo(projectedExtended[0], projectedExtended[1]);
+                ctx.stroke();
+
+                // Draw lines from extended point to each vertex
+                face.forEach(index => {
+                    const [x, y] = project(rotatedVertices[index]);
+                    ctx.beginPath();
+                    ctx.moveTo(projectedExtended[0], projectedExtended[1]);
+                    ctx.lineTo(x, y);
+                    ctx.stroke();
+                });
+            });
+        }
+
+        function animate() {
+            angleX += 0.01;
+            angleY += 0.01;
+            drawIcosahedron();
+            requestAnimationFrame(animate);
+        }
+
+        initIcosahedron();
+        animate();
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/index.html b/rubbish/index.html
new file mode 100644
index 0000000..8080f18
--- /dev/null
+++ b/rubbish/index.html
@@ -0,0 +1,80 @@
+<li><a href="four_petal_rotate.html"> four_petal_rotate.html </a></li>
+<li><a href="four_petal_double.html"> four_petal_double.html </a></li>
+<li><a href="two_ellipse.html"> two_ellipse.html </a></li>
+<li><a href="ellipsical_line_rotate.html"> ellipsical_line_rotate.html </a></li>
+<li><a href="ellipsical_line.html"> ellipsical_line.html </a></li>
+<li><a href="three_petal.html"> three_petal.html </a></li>
+<li><a href="four_petal.html"> four_petal.html </a></li>
+<li><a href="two_petal.html"> two_petal.html </a></li>
+<li><a href="chasing_square2.html"> chasing_square2.html </a></li>
+<li><a href="concentric.html"> concentric.html </a></li>
+<li><a href="static_concentric.html"> static_concentric.html </a></li>
+<li><a href="2d_surface.html"> 2d_surface.html </a></li>
+<li><a href="chasing_square1.html"> chasing_square1.html </a></li>
+<li><a href="chasing_square.html"> chasing_square.html </a></li>
+<li><a href="spherical_sinusoid3.html"> spherical_sinusoid3.html </a></li>
+<li><a href="spherical_sinusoid2.html"> spherical_sinusoid2.html </a></li>
+<li><a href="spherical_sinusoid.html"> spherical_sinusoid.html </a></li>
+<li><a href="spherical_sinusoid1.html"> spherical_sinusoid1.html </a></li>
+<li><a href="sinsoidal5.html"> sinsoidal5.html </a></li>
+<li><a href="sinusoidal.html"> sinusoidal.html </a></li>
+<li><a href="solid_torus1.html"> solid_torus1.html </a></li>
+<li><a href="solid_torus.html"> solid_torus.html </a></li>
+<li><a href="ellipse4.html"> ellipse4.html </a></li>
+<li><a href="o.html"> o.html </a></li>
+<li><a href="torus.html"> torus.html </a></li>
+<li><a href="circle2.html"> circle2.html </a></li>
+<li><a href="css_circle1.html"> css_circle1.html </a></li>
+<li><a href="css_circle.html"> css_circle.html </a></li>
+<li><a href="d3_graph.html"> d3_graph.html </a></li>
+<li><a href="ellipse2.html"> ellipse2.html </a></li>
+<li><a href="ellipse3.html"> ellipse3.html </a></li>
+<li><a href="figure_eight2.html"> figure_eight2.html </a></li>
+<li><a href="figure_eight.html"> figure_eight.html </a></li>
+<li><a href="klein3.html"> klein3.html </a></li>
+<li><a href="klein4.html"> klein4.html </a></li>
+<li><a href="klein5.html"> klein5.html </a></li>
+<li><a href="klein6.html"> klein6.html </a></li>
+<li><a href="klein7.html"> klein7.html </a></li>
+<li><a href="mobius.html"> mobius.html </a></li>
+<li><a href="webgl_3dcube.html"> webgl_3dcube.html </a></li>
+<li><a href="css_3dcube.html"> css_3dcube.html </a></li>
+<li><a href="line_drawing.html"> line_drawing.html </a></li>
+<li><a href="webgl.html"> webgl.html </a></li>
+<li><a href="circle_color.html"> circle_color.html </a></li>
+<li><a href="circle.html"> circle.html </a></li>
+<li><a href="double1.html"> double1.html </a></li>
+<li><a href="double3.html"> double3.html </a></li>
+<li><a href="double4.html"> double4.html </a></li>
+<li><a href="double5.html"> double5.html </a></li>
+<li><a href="double_globe.html"> double_globe.html </a></li>
+<li><a href="double.html"> double.html </a></li>
+<li><a href="double_motion.html"> double_motion.html </a></li>
+<li><a href="drawsector.html"> drawsector.html </a></li>
+<li><a href="ellipse_color2.html"> ellipse_color2.html </a></li>
+<li><a href="ellipse_color.html"> ellipse_color.html </a></li>
+<li><a href="ellipse.html"> ellipse.html </a></li>
+<li><a href="klein2_animation2.html"> klein2_animation2.html </a></li>
+<li><a href="klein2_animation3.html"> klein2_animation3.html </a></li>
+<li><a href="klein2_animation.html"> klein2_animation.html </a></li>
+<li><a href="klein2.html"> klein2.html </a></li>
+<li><a href="klein.html"> klein.html </a></li>
+<li><a href="quart_motion.html"> quart_motion.html </a></li>
+<li><a href="special.html"> special.html </a></li>
+<li><a href="triple_motion.html"> triple_motion.html </a></li>
+<li><a href="mywebgl.html"> mywebgl.html </a></li>
+<li><a href="counter_rotating_sector.html"> counter_rotating_sector.html </a></li>
+<li><a href="rotating_sector.html"> rotating_sector.html </a></li>
+<li><a href="five_rotate_spoke_sector.html"> five_rotate_spoke_sector.html </a></li>
+<li><a href="not_working.html"> not_working.html </a></li>
+<li><a href="five_rotate_spoke.html"> five_rotate_spoke.html </a></li>
+<li><a href="rotating_spoke.html"> rotating_spoke.html </a></li>
+<li><a href="rotating_spiral.html"> rotating_spiral.html </a></li>
+<li><a href="spiral.html"> spiral.html </a></li>
+<li><a href="spoke_subspokes.html"> spoke_subspokes.html </a></li>
+<li><a href="moving_square5.html"> moving_square5.html </a></li>
+<li><a href="moving_square4.html"> moving_square4.html </a></li>
+<li><a href="moving_square3.html"> moving_square3.html </a></li>
+<li><a href="moving_square2.html"> moving_square2.html </a></li>
+<li><a href="moving_square.html"> moving_square.html </a></li>
+<li><a href="line.html"> line.html </a></li>
diff --git a/rubbish/klein.html b/rubbish/klein.html
new file mode 100644
index 0000000..f7f2339
--- /dev/null
+++ b/rubbish/klein.html
@@ -0,0 +1,81 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Klein Bottle Line Drawing</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+            background-color: #fff;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="kleinBottleCanvas" width="600" height="600"></canvas>
+    <script>
+        const canvas = document.getElementById('kleinBottleCanvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const scale = 60;
+        const numU = 50;
+        const numV = 50;
+
+        function drawKleinBottle() {
+            ctx.clearRect(0, 0, canvas.width, canvas.height);
+            ctx.strokeStyle = '#000000';
+            ctx.lineWidth = 0.5;
+
+            for (let i = 0; i <= numU; i++) {
+                const u = (i / numU) * 2 * Math.PI;
+                ctx.beginPath();
+                for (let j = 0; j <= numV; j++) {
+                    const v = (j / numV) * 2 * Math.PI;
+                    const x = (scale * (Math.cos(u) * (1 + Math.sin(u)) + (v - Math.PI) * Math.cos(u) / 2));
+                    const y = (scale * (Math.sin(u) * (1 + Math.sin(u)) + (v - Math.PI) * Math.sin(u) / 2));
+                    const z = scale * (Math.cos(u) * Math.sin(u) + Math.cos(v));
+                    const xProj = centerX + x * Math.cos(u) - z * Math.sin(u);
+                    const yProj = centerY + y * Math.cos(v) - z * Math.sin(v);
+                    if (j === 0) {
+                        ctx.moveTo(xProj, yProj);
+                    } else {
+                        ctx.lineTo(xProj, yProj);
+                    }
+                }
+                ctx.stroke();
+            }
+
+            for (let j = 0; j <= numV; j++) {
+                const v = (j / numV) * 2 * Math.PI;
+                ctx.beginPath();
+                for (let i = 0; i <= numU; i++) {
+                    const u = (i / numU) * 2 * Math.PI;
+                    const x = (scale * (Math.cos(u) * (1 + Math.sin(u)) + (v - Math.PI) * Math.cos(u) / 2));
+                    const y = (scale * (Math.sin(u) * (1 + Math.sin(u)) + (v - Math.PI) * Math.sin(u) / 2));
+                    const z = scale * (Math.cos(u) * Math.sin(u) + Math.cos(v));
+                    const xProj = centerX + x * Math.cos(u) - z * Math.sin(u);
+                    const yProj = centerY + y * Math.cos(v) - z * Math.sin(v);
+                    if (i === 0) {
+                        ctx.moveTo(xProj, yProj);
+                    } else {
+                        ctx.lineTo(xProj, yProj);
+                    }
+                }
+                ctx.stroke();
+            }
+        }
+
+        drawKleinBottle();
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/klein2.html b/rubbish/klein2.html
new file mode 100644
index 0000000..673538d
--- /dev/null
+++ b/rubbish/klein2.html
@@ -0,0 +1,111 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Klein Bottle Line Drawing</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+            background-color: #fff;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="kleinBottleCanvas" width="600" height="600"></canvas>
+    <script>
+        const canvas = document.getElementById('kleinBottleCanvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const scale = 100;
+        const numU = 60;
+        const numV = 60;
+
+        function drawKleinBottle() {
+            ctx.clearRect(0, 0, canvas.width, canvas.height);
+            ctx.strokeStyle = '#000000';
+            ctx.lineWidth = 0.5;
+
+            function kleinBottleX(u, v) {
+                if (u < Math.PI) {
+                    return 3 * Math.cos(u) * (1 + Math.sin(u)) + scale * Math.cos(u) * Math.cos(v);
+                } else {
+                    return 3 * Math.cos(u) * (1 + Math.sin(u)) + scale * Math.cos(v + Math.PI);
+                }
+            }
+
+            function kleinBottleY(u, v) {
+                if (u < Math.PI) {
+                    return 3 * Math.sin(u) * (1 + Math.sin(u)) + scale * Math.sin(u) * Math.cos(v);
+                } else {
+                    return 3 * Math.sin(u) * (1 + Math.sin(u));
+                }
+            }
+
+            function kleinBottleZ(u, v) {
+                if (u < Math.PI) {
+                    return scale * Math.sin(v);
+                } else {
+                    return scale * Math.sin(v + Math.PI);
+                }
+            }
+
+            for (let i = 0; i <= numU; i++) {
+                const u = (i / numU) * 2 * Math.PI;
+                ctx.beginPath();
+                for (let j = 0; j <= numV; j++) {
+                    const v = (j / numV) * 2 * Math.PI;
+                    const x = kleinBottleX(u, v);
+                    const y = kleinBottleY(u, v);
+                    const z = kleinBottleZ(u, v);
+
+                    // Simple 2D projection
+                    const xProj = centerX + x - z * 0.5;
+                    const yProj = centerY + y - z * 0.5;
+
+                    if (j === 0) {
+                        ctx.moveTo(xProj, yProj);
+                    } else {
+                        ctx.lineTo(xProj, yProj);
+                    }
+                }
+                ctx.stroke();
+            }
+
+            for (let j = 0; j <= numV; j++) {
+                const v = (j / numV) * 2 * Math.PI;
+                ctx.beginPath();
+                for (let i = 0; i <= numU; i++) {
+                    const u = (i / numU) * 2 * Math.PI;
+                    const x = kleinBottleX(u, v);
+                    const y = kleinBottleY(u, v);
+                    const z = kleinBottleZ(u, v);
+
+                    // Simple 2D projection
+                    const xProj = centerX + x - z * 0.5;
+                    const yProj = centerY + y - z * 0.5;
+
+                    if (i === 0) {
+                        ctx.moveTo(xProj, yProj);
+                    } else {
+                        ctx.lineTo(xProj, yProj);
+                    }
+                }
+                ctx.stroke();
+            }
+        }
+
+        drawKleinBottle();
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/klein2_animation.html b/rubbish/klein2_animation.html
new file mode 100644
index 0000000..c530c75
--- /dev/null
+++ b/rubbish/klein2_animation.html
@@ -0,0 +1,121 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Klein Bottle Line Drawing</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+            background-color: #fff;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="kleinBottleCanvas" width="600" height="600"></canvas>
+    <script>
+        const canvas = document.getElementById('kleinBottleCanvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        let scale = 50;
+        let scale2 = 50;
+        const numU = 60;
+        const numV = 60;
+        let time = 0;
+
+        function drawKleinBottle() {
+            ctx.clearRect(0, 0, canvas.width, canvas.height);
+            ctx.strokeStyle = '#000000';
+            ctx.lineWidth = 0.5;
+
+            function kleinBottleX(u, v) {
+                if (u < Math.PI) {
+                    return scale2 * Math.cos(u) * (1 + Math.sin(u)) + scale * Math.cos(u) * Math.cos(v + time);
+                } else {
+                    return scale2 * Math.cos(u) * (1 + Math.sin(u)) + scale * Math.cos(v + Math.PI + time);
+                }
+            }
+
+            function kleinBottleY(u, v) {
+                if (u < Math.PI) {
+                    return scale2 * Math.sin(u) * (1 + Math.sin(u)) + scale * Math.sin(u) * Math.cos(v + time);
+                } else {
+                    return scale2 * Math.sin(u) * (1 + Math.sin(u));
+                }
+            }
+
+            function kleinBottleZ(u, v) {
+                if (u < Math.PI) {
+                    return scale * Math.sin(v + time);
+                } else {
+                    return scale * Math.sin(v + Math.PI + time);
+                }
+            }
+
+            for (let i = 0; i <= numU; i++) {
+                const u = (i / numU) * 2 * Math.PI;
+                ctx.beginPath();
+                for (let j = 0; j <= numV; j++) {
+                    const v = (j / numV) * 2 * Math.PI;
+                    const x = kleinBottleX(u, v);
+                    const y = kleinBottleY(u, v);
+                    const z = kleinBottleZ(u, v);
+
+                    // Simple 2D projection
+                    const xProj = centerX + x - z * 0.5;
+                    const yProj = centerY + y - z * 0.5;
+
+                    if (j === 0) {
+                        ctx.moveTo(xProj, yProj);
+                    } else {
+                        ctx.lineTo(xProj, yProj);
+                    }
+                }
+                ctx.stroke();
+            }
+
+            for (let j = 0; j <= numV; j++) {
+                const v = (j / numV) * 2 * Math.PI;
+                ctx.beginPath();
+                for (let i = 0; i <= numU; i++) {
+                    const u = (i / numU) * 2 * Math.PI;
+                    const x = kleinBottleX(u, v);
+                    const y = kleinBottleY(u, v);
+                    const z = kleinBottleZ(u, v);
+
+                    // Simple 2D projection
+                    const xProj = centerX + x - z * 0.5;
+                    const yProj = centerY + y - z * 0.5;
+
+                    if (i === 0) {
+                        ctx.moveTo(xProj, yProj);
+                    } else {
+                        ctx.lineTo(xProj, yProj);
+                    }
+                }
+                ctx.stroke();
+            }
+        }
+
+        function animate() {
+            time += 0.01;
+            scale = 50 + 50 * Math.sin(time * Math.PI);
+            scale2 = 50 + 50 * Math.cos(2 * time * Math.PI);
+            drawKleinBottle();
+            requestAnimationFrame(animate);
+        }
+
+        animate();
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/klein2_animation2.html b/rubbish/klein2_animation2.html
new file mode 100644
index 0000000..673538d
--- /dev/null
+++ b/rubbish/klein2_animation2.html
@@ -0,0 +1,111 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Klein Bottle Line Drawing</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+            background-color: #fff;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="kleinBottleCanvas" width="600" height="600"></canvas>
+    <script>
+        const canvas = document.getElementById('kleinBottleCanvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const scale = 100;
+        const numU = 60;
+        const numV = 60;
+
+        function drawKleinBottle() {
+            ctx.clearRect(0, 0, canvas.width, canvas.height);
+            ctx.strokeStyle = '#000000';
+            ctx.lineWidth = 0.5;
+
+            function kleinBottleX(u, v) {
+                if (u < Math.PI) {
+                    return 3 * Math.cos(u) * (1 + Math.sin(u)) + scale * Math.cos(u) * Math.cos(v);
+                } else {
+                    return 3 * Math.cos(u) * (1 + Math.sin(u)) + scale * Math.cos(v + Math.PI);
+                }
+            }
+
+            function kleinBottleY(u, v) {
+                if (u < Math.PI) {
+                    return 3 * Math.sin(u) * (1 + Math.sin(u)) + scale * Math.sin(u) * Math.cos(v);
+                } else {
+                    return 3 * Math.sin(u) * (1 + Math.sin(u));
+                }
+            }
+
+            function kleinBottleZ(u, v) {
+                if (u < Math.PI) {
+                    return scale * Math.sin(v);
+                } else {
+                    return scale * Math.sin(v + Math.PI);
+                }
+            }
+
+            for (let i = 0; i <= numU; i++) {
+                const u = (i / numU) * 2 * Math.PI;
+                ctx.beginPath();
+                for (let j = 0; j <= numV; j++) {
+                    const v = (j / numV) * 2 * Math.PI;
+                    const x = kleinBottleX(u, v);
+                    const y = kleinBottleY(u, v);
+                    const z = kleinBottleZ(u, v);
+
+                    // Simple 2D projection
+                    const xProj = centerX + x - z * 0.5;
+                    const yProj = centerY + y - z * 0.5;
+
+                    if (j === 0) {
+                        ctx.moveTo(xProj, yProj);
+                    } else {
+                        ctx.lineTo(xProj, yProj);
+                    }
+                }
+                ctx.stroke();
+            }
+
+            for (let j = 0; j <= numV; j++) {
+                const v = (j / numV) * 2 * Math.PI;
+                ctx.beginPath();
+                for (let i = 0; i <= numU; i++) {
+                    const u = (i / numU) * 2 * Math.PI;
+                    const x = kleinBottleX(u, v);
+                    const y = kleinBottleY(u, v);
+                    const z = kleinBottleZ(u, v);
+
+                    // Simple 2D projection
+                    const xProj = centerX + x - z * 0.5;
+                    const yProj = centerY + y - z * 0.5;
+
+                    if (i === 0) {
+                        ctx.moveTo(xProj, yProj);
+                    } else {
+                        ctx.lineTo(xProj, yProj);
+                    }
+                }
+                ctx.stroke();
+            }
+        }
+
+        drawKleinBottle();
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/klein2_animation3.html b/rubbish/klein2_animation3.html
new file mode 100644
index 0000000..5b9113d
--- /dev/null
+++ b/rubbish/klein2_animation3.html
@@ -0,0 +1,121 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Klein Bottle Line Drawing</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+            background-color: #fff;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="kleinBottleCanvas" width="600" height="600"></canvas>
+    <script>
+        const canvas = document.getElementById('kleinBottleCanvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        let scale = 50;
+        let scale2 = 50;
+        const numU = 60;
+        const numV = 60;
+        let time = 0;
+
+        function drawKleinBottle() {
+            ctx.clearRect(0, 0, canvas.width, canvas.height);
+            ctx.strokeStyle = '#000000';
+            ctx.lineWidth = 0.5;
+
+            function kleinBottleX(u, v) {
+                if (u < Math.PI) {
+                    return scale2 * Math.cos(u) * (1 + Math.sin(u)) + scale * Math.cos(u) * Math.cos(v + time);
+                } else {
+                    return scale2 * Math.cos(u) * (1 + Math.sin(u)) + scale * Math.cos(v + Math.PI + time);
+                }
+            }
+
+            function kleinBottleY(u, v) {
+                if (u < Math.PI) {
+                    return scale2 * Math.sin(u) * (1 + Math.sin(u)) + scale * Math.sin(u) * Math.cos(v + time);
+                } else {
+                    return scale2 * Math.sin(u) * (1 + Math.sin(u));
+                }
+            }
+
+            function kleinBottleZ(u, v) {
+                if (u < Math.PI) {
+                    return scale * Math.sin(v + time);
+                } else {
+                    return scale * Math.sin(v + Math.PI + time);
+                }
+            }
+
+            for (let i = 0; i <= numU; i++) {
+                const u = (i / numU) * 2 * Math.PI;
+                ctx.beginPath();
+                for (let j = 0; j <= numV; j++) {
+                    const v = (j / numV) * 2 * Math.PI;
+                    const x = kleinBottleX(u, v);
+                    const y = kleinBottleY(u, v);
+                    const z = kleinBottleZ(u, v);
+
+                    // Simple 2D projection
+                    const xProj = centerX + x - z * 0.5;
+                    const yProj = centerY + y - z * 0.5;
+
+                    if (j === 0) {
+                        ctx.moveTo(xProj, yProj);
+                    } else {
+                        ctx.lineTo(xProj, yProj);
+                    }
+                }
+                ctx.stroke();
+            }
+
+            for (let j = 0; j <= numV; j++) {
+                const v = (j / numV) * 2 * Math.PI;
+                ctx.beginPath();
+                for (let i = 0; i <= numU; i++) {
+                    const u = (i / numU) * 2 * Math.PI;
+                    const x = kleinBottleX(u, v);
+                    const y = kleinBottleY(u, v);
+                    const z = kleinBottleZ(u, v);
+
+                    // Simple 2D projection
+                    const xProj = centerX + x - z * 0.5;
+                    const yProj = centerY + y - z * 0.5;
+
+                    if (i === 0) {
+                        ctx.moveTo(xProj, yProj);
+                    } else {
+                        ctx.lineTo(xProj, yProj);
+                    }
+                }
+                ctx.stroke();
+            }
+        }
+
+        function animate() {
+            time += 0.005;
+            scale = 90 + 80 * Math.sin(4*time * Math.PI);
+            scale2 = 90 + 80 * Math.cos(2 * time * Math.PI);
+            drawKleinBottle();
+            requestAnimationFrame(animate);
+        }
+
+        animate();
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/klein3.html b/rubbish/klein3.html
new file mode 100644
index 0000000..e1a8341
--- /dev/null
+++ b/rubbish/klein3.html
@@ -0,0 +1,112 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Klein Bottle Wireframe</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="canvas" width="800" height="800"></canvas>
+    <script>
+        const canvas = document.getElementById('canvas');
+        const ctx = canvas.getContext('2d');
+        const width = canvas.width;
+        const height = canvas.height;
+        const centerX = width / 2;
+        const centerY = height / 2;
+        const scale = 80;
+
+        // Rotation angles
+        const angleX = Math.PI / 6; // Rotate around the X-axis
+        const angleY = Math.PI / 6; // Rotate around the Y-axis
+        const angleZ = Math.PI / 6; // Rotate around the Z-axis
+
+        function rotateX(x, y, z, angle) {
+            const cos = Math.cos(angle);
+            const sin = Math.sin(angle);
+            return [x, y * cos - z * sin, y * sin + z * cos];
+        }
+
+        function rotateY(x, y, z, angle) {
+            const cos = Math.cos(angle);
+            const sin = Math.sin(angle);
+            return [x * cos + z * sin, y, -x * sin + z * cos];
+        }
+
+        function rotateZ(x, y, z, angle) {
+            const cos = Math.cos(angle);
+            const sin = Math.sin(angle);
+            return [x * cos - y * sin, x * sin + y * cos, z];
+        }
+
+        function drawKleinBottle() {
+            const uStep = Math.PI / 18;
+            const vStep = 2 * Math.PI / 36;
+
+            for (let u = 0; u < 2 * Math.PI; u += uStep) {
+                for (let v = 0; v < 2 * Math.PI; v += vStep) {
+                    let x = (4 + 2 * Math.cos(u)) * Math.cos(v);
+                    let y = (4 + 2 * Math.cos(u)) * Math.sin(v);
+                    let z = 2 * Math.sin(u) * Math.cos(v / 2);
+
+                    [x, y, z] = rotateX(x, y, z, angleX);
+                    [x, y, z] = rotateY(x, y, z, angleY);
+                    [x, y, z] = rotateZ(x, y, z, angleZ);
+
+                    let nextX = (4 + 2 * Math.cos(u + uStep)) * Math.cos(v);
+                    let nextY = (4 + 2 * Math.cos(u + uStep)) * Math.sin(v);
+                    let nextZ = 2 * Math.sin(u + uStep) * Math.cos(v / 2);
+
+                    [nextX, nextY, nextZ] = rotateX(nextX, nextY, nextZ, angleX);
+                    [nextX, nextY, nextZ] = rotateY(nextX, nextY, nextZ, angleY);
+                    [nextX, nextY, nextZ] = rotateZ(nextX, nextY, nextZ, angleZ);
+
+                    let nextX2 = (4 + 2 * Math.cos(u)) * Math.cos(v + vStep);
+                    let nextY2 = (4 + 2 * Math.cos(u)) * Math.sin(v + vStep);
+                    let nextZ2 = 2 * Math.sin(u) * Math.cos((v + vStep) / 2);
+
+                    [nextX2, nextY2, nextZ2] = rotateX(nextX2, nextY2, nextZ2, angleX);
+                    [nextX2, nextY2, nextZ2] = rotateY(nextX2, nextY2, nextZ2, angleY);
+                    [nextX2, nextY2, nextZ2] = rotateZ(nextX2, nextY2, nextZ2, angleZ);
+
+                    drawLine(project(x, y, z), project(nextX, nextY, nextZ));
+                    drawLine(project(x, y, z), project(nextX2, nextY2, nextZ2));
+                }
+            }
+        }
+
+        function project(x, y, z) {
+            const perspective = 500 / (500 + z);
+            return [
+                centerX + x * scale * perspective,
+                centerY - y * scale * perspective
+            ];
+        }
+
+        function drawLine(start, end) {
+            ctx.beginPath();
+            ctx.moveTo(start[0], start[1]);
+            ctx.lineTo(end[0], end[1]);
+            ctx.stroke();
+        }
+
+        ctx.clearRect(0, 0, width, height);
+        ctx.strokeStyle = 'black';
+        drawKleinBottle();
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/klein4.html b/rubbish/klein4.html
new file mode 100644
index 0000000..7ac464e
--- /dev/null
+++ b/rubbish/klein4.html
@@ -0,0 +1,115 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Klein Bottle Transformation</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="canvas" width="800" height="800"></canvas>
+    <script>
+        const canvas = document.getElementById('canvas');
+        const ctx = canvas.getContext('2d');
+        const width = canvas.width;
+        const height = canvas.height;
+        const centerX = width / 2;
+        const centerY = height / 2;
+        const scale = 80;
+
+        // Rotation angles
+        const angleX = Math.PI / 6; // Rotate around the X-axis
+        const angleY = Math.PI / 6; // Rotate around the Y-axis
+        const angleZ = Math.PI / 6; // Rotate around the Z-axis
+
+        function rotateX(x, y, z, angle) {
+            const cos = Math.cos(angle);
+            const sin = Math.sin(angle);
+            return [x, y * cos - z * sin, y * sin + z * cos];
+        }
+
+        function rotateY(x, y, z, angle) {
+            const cos = Math.cos(angle);
+            const sin = Math.sin(angle);
+            return [x * cos + z * sin, y, -x * sin + z * cos];
+        }
+
+        function rotateZ(x, y, z, angle) {
+            const cos = Math.cos(angle);
+            const sin = Math.sin(angle);
+            return [x * cos - y * sin, x * sin + y * cos, z];
+        }
+
+        function drawKleinBottle() {
+            const uStep = Math.PI / 18;
+            const vStep = 2 * Math.PI / 36;
+
+            for (let u = 0; u < 2 * Math.PI; u += uStep) {
+                for (let v = 0; v < 2 * Math.PI; v += vStep) {
+                    const [x, y, z] = torusToKleinBottle(u, v);
+                    const [nextX, nextY, nextZ] = torusToKleinBottle(u + uStep, v);
+                    const [nextX2, nextY2, nextZ2] = torusToKleinBottle(u, v + vStep);
+
+                    drawLine(project(x, y, z), project(nextX, nextY, nextZ));
+                    drawLine(project(x, y, z), project(nextX2, nextY2, nextZ2));
+                }
+            }
+        }
+
+        function torusToKleinBottle(u, v) {
+            const R = 4; // Major radius
+            const r = 2; // Minor radius
+
+            // Parametric equations for a torus
+            let x = (R + r * Math.cos(v)) * Math.cos(u);
+            let y = (R + r * Math.cos(v)) * Math.sin(u);
+            let z = r * Math.sin(v);
+
+            // Transformation to create a Klein bottle
+            if (u > Math.PI) {
+                x = (R + r * Math.cos(v)) * Math.cos(u);
+                y = (R + r * Math.cos(v)) * Math.sin(u);
+                z = r * Math.sin(v);
+            }
+
+            [x, y, z] = rotateX(x, y, z, angleX);
+            [x, y, z] = rotateY(x, y, z, angleY);
+            [x, y, z] = rotateZ(x, y, z, angleZ);
+
+            return [x, y, z];
+        }
+
+        function project(x, y, z) {
+            const perspective = 500 / (500 + z);
+            return [
+                centerX + x * scale * perspective,
+                centerY - y * scale * perspective
+            ];
+        }
+
+        function drawLine(start, end) {
+            ctx.beginPath();
+            ctx.moveTo(start[0], start[1]);
+            ctx.lineTo(end[0], end[1]);
+            ctx.stroke();
+        }
+
+        ctx.clearRect(0, 0, width, height);
+        ctx.strokeStyle = 'black';
+        drawKleinBottle();
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/klein5.html b/rubbish/klein5.html
new file mode 100644
index 0000000..7ac464e
--- /dev/null
+++ b/rubbish/klein5.html
@@ -0,0 +1,115 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Klein Bottle Transformation</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="canvas" width="800" height="800"></canvas>
+    <script>
+        const canvas = document.getElementById('canvas');
+        const ctx = canvas.getContext('2d');
+        const width = canvas.width;
+        const height = canvas.height;
+        const centerX = width / 2;
+        const centerY = height / 2;
+        const scale = 80;
+
+        // Rotation angles
+        const angleX = Math.PI / 6; // Rotate around the X-axis
+        const angleY = Math.PI / 6; // Rotate around the Y-axis
+        const angleZ = Math.PI / 6; // Rotate around the Z-axis
+
+        function rotateX(x, y, z, angle) {
+            const cos = Math.cos(angle);
+            const sin = Math.sin(angle);
+            return [x, y * cos - z * sin, y * sin + z * cos];
+        }
+
+        function rotateY(x, y, z, angle) {
+            const cos = Math.cos(angle);
+            const sin = Math.sin(angle);
+            return [x * cos + z * sin, y, -x * sin + z * cos];
+        }
+
+        function rotateZ(x, y, z, angle) {
+            const cos = Math.cos(angle);
+            const sin = Math.sin(angle);
+            return [x * cos - y * sin, x * sin + y * cos, z];
+        }
+
+        function drawKleinBottle() {
+            const uStep = Math.PI / 18;
+            const vStep = 2 * Math.PI / 36;
+
+            for (let u = 0; u < 2 * Math.PI; u += uStep) {
+                for (let v = 0; v < 2 * Math.PI; v += vStep) {
+                    const [x, y, z] = torusToKleinBottle(u, v);
+                    const [nextX, nextY, nextZ] = torusToKleinBottle(u + uStep, v);
+                    const [nextX2, nextY2, nextZ2] = torusToKleinBottle(u, v + vStep);
+
+                    drawLine(project(x, y, z), project(nextX, nextY, nextZ));
+                    drawLine(project(x, y, z), project(nextX2, nextY2, nextZ2));
+                }
+            }
+        }
+
+        function torusToKleinBottle(u, v) {
+            const R = 4; // Major radius
+            const r = 2; // Minor radius
+
+            // Parametric equations for a torus
+            let x = (R + r * Math.cos(v)) * Math.cos(u);
+            let y = (R + r * Math.cos(v)) * Math.sin(u);
+            let z = r * Math.sin(v);
+
+            // Transformation to create a Klein bottle
+            if (u > Math.PI) {
+                x = (R + r * Math.cos(v)) * Math.cos(u);
+                y = (R + r * Math.cos(v)) * Math.sin(u);
+                z = r * Math.sin(v);
+            }
+
+            [x, y, z] = rotateX(x, y, z, angleX);
+            [x, y, z] = rotateY(x, y, z, angleY);
+            [x, y, z] = rotateZ(x, y, z, angleZ);
+
+            return [x, y, z];
+        }
+
+        function project(x, y, z) {
+            const perspective = 500 / (500 + z);
+            return [
+                centerX + x * scale * perspective,
+                centerY - y * scale * perspective
+            ];
+        }
+
+        function drawLine(start, end) {
+            ctx.beginPath();
+            ctx.moveTo(start[0], start[1]);
+            ctx.lineTo(end[0], end[1]);
+            ctx.stroke();
+        }
+
+        ctx.clearRect(0, 0, width, height);
+        ctx.strokeStyle = 'black';
+        drawKleinBottle();
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/klein6.html b/rubbish/klein6.html
new file mode 100644
index 0000000..3b110b0
--- /dev/null
+++ b/rubbish/klein6.html
@@ -0,0 +1,84 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Klein Bottle Wireframe</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="canvas" width="800" height="800"></canvas>
+    <script>
+        const canvas = document.getElementById('canvas');
+        const ctx = canvas.getContext('2d');
+        const width = canvas.width;
+        const height = canvas.height;
+        const centerX = width / 2;
+        const centerY = height / 2;
+        const scale = 50;
+
+        function drawKleinBottle() {
+            const uStep = Math.PI / 18;
+            const vStep = 2 * Math.PI / 36;
+
+            for (let u = 0; u < 2 * Math.PI; u += uStep) {
+                for (let v = 0; v < 2 * Math.PI; v += vStep) {
+                    const [x, y, z] = kleinCoordinates(u, v);
+                    const [nextX, nextY, nextZ] = kleinCoordinates(u + uStep, v);
+                    const [nextX2, nextY2, nextZ2] = kleinCoordinates(u, v + vStep);
+
+                    drawLine(project(x, y, z), project(nextX, nextY, nextZ));
+                    drawLine(project(x, y, z), project(nextX2, nextY2, nextZ2));
+                }
+            }
+        }
+
+        function kleinCoordinates(u, v) {
+            let x, y, z;
+            if (u < Math.PI) {
+                x = 3 * Math.cos(u) * (1 + Math.sin(u)) + 2 * (1 - Math.cos(u) / 2) * Math.cos(v);
+                y = 8 * Math.sin(u) + 2 * (1 - Math.cos(u) / 2) * Math.sin(v);
+                z = 2 * (1 - Math.cos(u) / 2) * Math.sin(v);
+            } else {
+                x = 3 * Math.cos(u) * (1 + Math.sin(u)) + 2 * (1 - Math.cos(u) / 2) * Math.cos(v + Math.PI);
+                y = 8 * Math.sin(u);
+                z = 2 * (1 - Math.cos(u) / 2) * Math.sin(v + Math.PI);
+            }
+            return [x, y, z];
+        }
+
+        function project(x, y, z) {
+            const perspective = 500 / (500 + z);
+            return [
+                centerX + x * scale * perspective,
+                centerY - y * scale * perspective
+            ];
+        }
+
+        function drawLine(start, end) {
+            ctx.beginPath();
+            ctx.moveTo(start[0], start[1]);
+            ctx.lineTo(end[0], end[1]);
+            ctx.stroke();
+        }
+
+        ctx.clearRect(0, 0, width, height);
+        ctx.strokeStyle = 'black';
+        drawKleinBottle();
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/klein7.html b/rubbish/klein7.html
new file mode 100644
index 0000000..5663326
--- /dev/null
+++ b/rubbish/klein7.html
@@ -0,0 +1,78 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Klein Bottle Wireframe</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="canvas" width="800" height="800"></canvas>
+    <script>
+        const canvas = document.getElementById('canvas');
+        const ctx = canvas.getContext('2d');
+        const width = canvas.width;
+        const height = canvas.height;
+        const centerX = width / 2;
+        const centerY = height / 2;
+        const scale = 50;
+
+        function drawKleinBottle() {
+            const uStep = Math.PI / 18;
+            const vStep = 2 * Math.PI / 36;
+
+            for (let u = 0; u < 2 * Math.PI; u += uStep) {
+                for (let v = 0; v < 2 * Math.PI; v += vStep) {
+                    const [x, y, z] = kleinCoordinates(u, v);
+                    const [nextX, nextY, nextZ] = kleinCoordinates(u + uStep, v);
+                    const [nextX2, nextY2, nextZ2] = kleinCoordinates(u, v + vStep);
+
+                    drawLine(project(x, y, z), project(nextX, nextY, nextZ));
+                    drawLine(project(x, y, z), project(nextX2, nextY2, nextZ2));
+                }
+            }
+        }
+
+        function kleinCoordinates(u, v) {
+            let x, y, z;
+                x = (1 + Math.cos(u/2) * Math.sin(v) - Math.sin(u/2) * Math.sin(2*v))*Math.cos(u);
+                y = (1 + Math.cos(u/2) * Math.sin(v) - Math.sin(u/2) * Math.sin(2*v))*Math.sin(u);
+                z = Math.sin(u/2) * Math.sin(v) + Math.cos(u/2) * Math.sin(2*v);
+            return [x, y, z];
+        }
+
+        function project(x, y, z) {
+            const perspective = 500 / (200 + z);
+            return [
+                centerX + x * scale * perspective,
+                centerY - y * scale * perspective
+            ];
+        }
+
+        function drawLine(start, end) {
+            ctx.beginPath();
+            ctx.moveTo(start[0], start[1]);
+            ctx.lineTo(end[0], end[1]);
+            ctx.stroke();
+        }
+
+        ctx.clearRect(0, 0, width, height);
+        ctx.strokeStyle = 'black';
+        drawKleinBottle();
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/line.html b/rubbish/line.html
new file mode 100644
index 0000000..4b8775e
--- /dev/null
+++ b/rubbish/line.html
@@ -0,0 +1,47 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+<meta charset="UTF-8">
+<title>Animated Line Drawing</title>
+<style>
+    canvas {
+        border: 1px solid black;
+    }
+</style>
+</head>
+<body>
+
+<canvas id="myCanvas" width="480" height="320"></canvas>
+
+<script>
+    var canvas = document.getElementById('myCanvas');
+    var ctx = canvas.getContext('2d');
+
+    var startX = 0;
+    var startY = 160;
+    var endX = 0;
+    var endY = 160;
+    var speed = 2;
+
+    function drawLine() {
+        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
+
+        ctx.beginPath();
+        ctx.moveTo(startX, startY);
+        ctx.lineTo(endX, endY);
+        ctx.stroke();
+
+        endX += speed; // Update the end X position for animation
+
+        if (endX < canvas.width) {
+            window.requestAnimationFrame(drawLine); // Recursively call drawLine to animate
+        }
+    }
+
+    drawLine(); // Initial call to start the animation
+</script>
+
+</body>
+</html>
+
diff --git a/rubbish/line_drawing.html b/rubbish/line_drawing.html
new file mode 100644
index 0000000..4c49352
--- /dev/null
+++ b/rubbish/line_drawing.html
@@ -0,0 +1,57 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Geometric Line Drawing</title>
+    <style>
+        body {
+            margin: 0;
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            background-color: black;
+        }
+        canvas {
+            display: block;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="lineCanvas"></canvas>
+    <script>
+        const canvas = document.getElementById('lineCanvas');
+        const ctx = canvas.getContext('2d');
+        canvas.width = window.innerWidth;
+        canvas.height = window.innerHeight;
+
+        function drawLines() {
+            ctx.clearRect(0, 0, canvas.width, canvas.height);
+            const numLines = 50;
+            const spacing = canvas.width / numLines;
+            const colors = ['#FF4500', '#FF6347', '#FF7F50', '#FFA07A'];
+
+            for (let i = 0; i < numLines; i++) {
+                const color = colors[i % colors.length];
+                ctx.strokeStyle = color;
+                ctx.beginPath();
+                ctx.moveTo(i * spacing, 0);
+                ctx.lineTo(canvas.width / 2, canvas.height / 2);
+                ctx.lineTo(canvas.width - i * spacing, canvas.height);
+                ctx.stroke();
+            }
+        }
+
+        drawLines();
+
+        window.addEventListener('resize', () => {
+            canvas.width = window.innerWidth;
+            canvas.height = window.innerHeight;
+            drawLines();
+        });
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/mobius.html b/rubbish/mobius.html
new file mode 100644
index 0000000..74a806c
--- /dev/null
+++ b/rubbish/mobius.html
@@ -0,0 +1,76 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Mbius Strip Wireframe</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="canvas" width="800" height="800"></canvas>
+    <script>
+        const canvas = document.getElementById('canvas');
+        const ctx = canvas.getContext('2d');
+        const width = canvas.width;
+        const height = canvas.height;
+        const centerX = width / 2;
+        const centerY = height / 2;
+        const scale = 150;
+
+        function drawMobiusStrip() {
+            const uStep = Math.PI / 36; // u step
+            const vStep = 0.1; // v step
+
+            for (let u = 0; u < 2 * Math.PI; u += uStep) {
+                for (let v = -0.5; v <= 0.5; v += vStep) {
+                    const [x, y, z] = mobiusCoordinates(u, v);
+                    const [nextX, nextY, nextZ] = mobiusCoordinates(u + uStep, v);
+                    const [nextX2, nextY2, nextZ2] = mobiusCoordinates(u, v + vStep);
+
+                    drawLine(project(x, y, z), project(nextX, nextY, nextZ));
+                    drawLine(project(x, y, z), project(nextX2, nextY2, nextZ2));
+                }
+            }
+        }
+
+        function mobiusCoordinates(u, v) {
+            const x = Math.cos(u) * (1 + v * Math.cos(u / 2));
+            const y = Math.sin(u) * (1 + v * Math.cos(u / 2));
+            const z = v * Math.sin(u / 2);
+            return [x, y, z];
+        }
+
+        function project(x, y, z) {
+            const perspective = 500 / (500 + z);
+            return [
+                centerX + x * scale * perspective,
+                centerY - y * scale * perspective
+            ];
+        }
+
+        function drawLine(start, end) {
+            ctx.beginPath();
+            ctx.moveTo(start[0], start[1]);
+            ctx.lineTo(end[0], end[1]);
+            ctx.stroke();
+        }
+
+        ctx.clearRect(0, 0, width, height);
+        ctx.strokeStyle = 'black';
+        drawMobiusStrip();
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/moving_square.html b/rubbish/moving_square.html
new file mode 100644
index 0000000..5bdb27d
--- /dev/null
+++ b/rubbish/moving_square.html
@@ -0,0 +1,47 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+<meta charset="UTF-8">
+<title>Animated Expanding Square</title>
+<style>
+    canvas {
+        border: 1px solid black;
+    }
+</style>
+</head>
+<body>
+
+<canvas id="myCanvas" width="480" height="320"></canvas>
+
+<script>
+    var canvas = document.getElementById('myCanvas');
+    var ctx = canvas.getContext('2d');
+
+    var size = 20; // Initial size of the square
+    var maxSize = 300; // Maximum size of the square
+    var increase = 2; // Amount to increase the size of the square each frame
+
+    function drawSquare() {
+        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
+
+        var x = (canvas.width - size) / 2; // Calculate the x position to keep the square centered
+        var y = (canvas.height - size) / 2; // Calculate the y position to keep the square centered
+
+        ctx.beginPath();
+        ctx.rect(x, y, size, size);
+        ctx.stroke();
+
+        size += increase; // Increase the size for the next frame
+
+        if (size < maxSize) {
+            window.requestAnimationFrame(drawSquare); // Continue the animation if the square is not yet at its max size
+        }
+    }
+
+    drawSquare(); // Initial call to start the animation
+</script>
+
+</body>
+</html>
+
diff --git a/rubbish/moving_square2.html b/rubbish/moving_square2.html
new file mode 100644
index 0000000..971c9fc
--- /dev/null
+++ b/rubbish/moving_square2.html
@@ -0,0 +1,51 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+<meta charset="UTF-8">
+<title>Animated Expanding Square</title>
+<style>
+    canvas {
+        border: 1px solid black;
+    }
+</style>
+</head>
+<body>
+
+<canvas id="myCanvas" width="480" height="320"></canvas>
+
+<script>
+    var canvas = document.getElementById('myCanvas');
+    var ctx = canvas.getContext('2d');
+
+    var size = 20; // Initial size of the square
+    var maxSize = 300; // Maximum size of the square
+    var increase = 2; // Amount to increase the size of the square each frame
+
+    function drawSquare() {
+        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
+
+        var x = (canvas.width - size) / 2; // Calculate the x position to keep the square centered
+        var y = (canvas.height - size) / 2; // Calculate the y position to keep the square centered
+
+        ctx.beginPath();
+        ctx.rect(x, y, size, size);
+        ctx.stroke();
+
+        size += increase; // Increase the size for the next frame
+
+        if (size < maxSize) {
+            window.requestAnimationFrame(drawSquare); // Continue the animation if the square is not yet at its max size
+        }
+	    else {
+		size=0;
+            	window.requestAnimationFrame(drawSquare); // Continue the animation if the square is not yet at its max size
+	   }
+    }
+
+    drawSquare(); // Initial call to start the animation
+</script>
+
+</body>
+</html>
+
diff --git a/rubbish/moving_square3.html b/rubbish/moving_square3.html
new file mode 100644
index 0000000..6f9edc0
--- /dev/null
+++ b/rubbish/moving_square3.html
@@ -0,0 +1,55 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+<meta charset="UTF-8">
+<title>Animated Expanding Square</title>
+<style>
+    canvas {
+        border: 1px solid black;
+    }
+</style>
+</head>
+<body>
+
+<canvas id="myCanvas" width="480" height="320"></canvas>
+
+<script>
+    var canvas = document.getElementById('myCanvas');
+    var ctx = canvas.getContext('2d');
+
+    var size = 20; // Initial size of the square
+    var maxSize = 300; // Maximum size of the square
+    var increase = 10; // Amount to increase the size of the square each frame
+
+    function drawSquare() {
+        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
+
+        var x = (canvas.width - size) / 2; // Calculate the x position to keep the square centered
+        var y = (canvas.height - size) / 2; // Calculate the y position to keep the square centered
+
+        ctx.beginPath();
+        ctx.rect(x, y, size, size);
+        ctx.rect(x, y, size+10, size+10);
+        ctx.rect(x, y, size+20, size+20);
+        ctx.rect(x, y, size+30, size+30);
+        ctx.rect(x, y, size+40, size+40);
+        ctx.stroke();
+
+        size += increase; // Increase the size for the next frame
+
+        if (size < maxSize) {
+            window.requestAnimationFrame(drawSquare); // Continue the animation if the square is not yet at its max size
+        }
+	    else {
+		size=0;
+            	window.requestAnimationFrame(drawSquare); // Continue the animation if the square is not yet at its max size
+	   }
+    }
+
+    drawSquare(); // Initial call to start the animation
+</script>
+
+</body>
+</html>
+
diff --git a/rubbish/moving_square4.html b/rubbish/moving_square4.html
new file mode 100644
index 0000000..cb12a09
--- /dev/null
+++ b/rubbish/moving_square4.html
@@ -0,0 +1,55 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+<meta charset="UTF-8">
+<title>Animated Expanding Square</title>
+<style>
+    canvas {
+        border: 1px solid black;
+    }
+</style>
+</head>
+<body>
+
+<canvas id="myCanvas" width="480" height="320"></canvas>
+
+<script>
+    var canvas = document.getElementById('myCanvas');
+    var ctx = canvas.getContext('2d');
+
+    var size = 20; // Initial size of the square
+    var maxSize = 300; // Maximum size of the square
+    var increase = 10; // Amount to increase the size of the square each frame
+
+    function drawSquare() {
+        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
+
+        var x = (canvas.width - size) / 2; // Calculate the x position to keep the square centered
+        var y = (canvas.height - size) / 2; // Calculate the y position to keep the square centered
+
+        ctx.beginPath();
+        ctx.rect(x, y, size, size);
+        ctx.rect(x-10, y-10, size+10, size+10);
+        ctx.rect(x-20, y-20, size+20, size+20);
+        ctx.rect(x-30, y-30, size+30, size+30);
+        ctx.rect(x-40, y-40, size+40, size+40);
+        ctx.stroke();
+
+        size += increase; // Increase the size for the next frame
+
+        if (size < maxSize) {
+            window.requestAnimationFrame(drawSquare); // Continue the animation if the square is not yet at its max size
+        }
+	    else {
+		size=0;
+            	window.requestAnimationFrame(drawSquare); // Continue the animation if the square is not yet at its max size
+	   }
+    }
+
+    drawSquare(); // Initial call to start the animation
+</script>
+
+</body>
+</html>
+
diff --git a/rubbish/moving_square5.html b/rubbish/moving_square5.html
new file mode 100644
index 0000000..74d7769
--- /dev/null
+++ b/rubbish/moving_square5.html
@@ -0,0 +1,55 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+<meta charset="UTF-8">
+<title>Animated Expanding Square</title>
+<style>
+    canvas {
+        border: 1px solid black;
+    }
+</style>
+</head>
+<body>
+
+<canvas id="myCanvas" width="480" height="320"></canvas>
+
+<script>
+    var canvas = document.getElementById('myCanvas');
+    var ctx = canvas.getContext('2d');
+
+    var size = 20; // Initial size of the square
+    var maxSize = 300; // Maximum size of the square
+    var increase = 10; // Amount to increase the size of the square each frame
+
+    function drawSquare() {
+        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
+
+        var x = (canvas.width - size) / 2; // Calculate the x position to keep the square centered
+        var y = (canvas.height - size) / 2; // Calculate the y position to keep the square centered
+
+        ctx.beginPath();
+        ctx.rect(x, y, size, size);
+        ctx.rect(x-5, y-5, size+10, size+10);
+        ctx.rect(x-10, y-10, size+20, size+20);
+        ctx.rect(x-15, y-15, size+30, size+30);
+        ctx.rect(x-20, y-20, size+40, size+40);
+        ctx.stroke();
+
+        size += increase; // Increase the size for the next frame
+
+        if (size < maxSize) {
+            window.requestAnimationFrame(drawSquare); // Continue the animation if the square is not yet at its max size
+        }
+	    else {
+		size=0;
+            	window.requestAnimationFrame(drawSquare); // Continue the animation if the square is not yet at its max size
+	   }
+    }
+
+    drawSquare(); // Initial call to start the animation
+</script>
+
+</body>
+</html>
+
diff --git a/rubbish/mywebgl.html b/rubbish/mywebgl.html
new file mode 100644
index 0000000..a57b06d
--- /dev/null
+++ b/rubbish/mywebgl.html
@@ -0,0 +1,13 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <title>Sector of a Circle</title>
+</head>
+<body>
+    <canvas id="webgl-canvas" width="400" height="400"></canvas>
+    <script src="mywebgl.js"></script>
+</body>
+</html>
+
diff --git a/rubbish/not_working.html b/rubbish/not_working.html
new file mode 100644
index 0000000..00703e1
--- /dev/null
+++ b/rubbish/not_working.html
@@ -0,0 +1,58 @@
+<!DOCTYPE html>
+<html>
+<body>
+
+<canvas id="illusionCanvas" width="1200" height="1200"></canvas>
+
+<script>
+const canvas = document.getElementById('illusionCanvas');
+const ctx = canvas.getContext('2d');
+
+const centerX = canvas.width / 2;
+const centerY = canvas.height / 2;
+const sector = 30;
+const star_ngon = 5;
+const maxRadius = Math.min(canvas.width, canvas.height) / 2;
+var sub_shift_angle = 0;
+
+	sub_shift_angle += 2*Math.PI/sector/10;
+function draw_main_spoke(cx, cy, sub_shift_angle) {
+        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
+for (let i = 0; i < star_ngon; i++) {
+	let angle = (i / star_ngon) * 2 * Math.PI;
+    let x = centerX + maxRadius * Math.cos(angle+sub_shift_angle);
+    let y = centerY + maxRadius * Math.sin(angle+sub_shift_angle);
+
+    ctx.strokeStyle = (i % 2 === 0) ? 'black' : 'blue';
+    ctx.lineWidth = 2;
+
+    ctx.beginPath();
+    ctx.moveTo(centerX, centerY);
+    ctx.lineTo(x, y);
+    ctx.stroke();
+}
+        window.requestAnimationFrame(draw_main_spoke); // Continue the animation if the square is not yet at its max size
+}
+
+function draw_spoke(myx, myy, radius, mysector) {
+    for (let i = 0; i < mysector; i++) {
+        let angle = (i / mysector) * 2 * Math.PI;
+
+        let x = myx + radius * Math.cos(angle);
+        let y = myy + radius * Math.sin(angle);
+
+        ctx.strokeStyle = (i % 2 === 0) ? 'black' : 'red';
+
+        ctx.beginPath();
+        ctx.moveTo(myx, myy);
+        ctx.lineTo(x, y);
+        ctx.stroke();
+    }
+}
+
+draw_main_spoke();
+</script>
+
+</body>
+</html>
+
diff --git a/rubbish/o.html b/rubbish/o.html
new file mode 100644
index 0000000..673538d
--- /dev/null
+++ b/rubbish/o.html
@@ -0,0 +1,111 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Klein Bottle Line Drawing</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+            background-color: #fff;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="kleinBottleCanvas" width="600" height="600"></canvas>
+    <script>
+        const canvas = document.getElementById('kleinBottleCanvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const scale = 100;
+        const numU = 60;
+        const numV = 60;
+
+        function drawKleinBottle() {
+            ctx.clearRect(0, 0, canvas.width, canvas.height);
+            ctx.strokeStyle = '#000000';
+            ctx.lineWidth = 0.5;
+
+            function kleinBottleX(u, v) {
+                if (u < Math.PI) {
+                    return 3 * Math.cos(u) * (1 + Math.sin(u)) + scale * Math.cos(u) * Math.cos(v);
+                } else {
+                    return 3 * Math.cos(u) * (1 + Math.sin(u)) + scale * Math.cos(v + Math.PI);
+                }
+            }
+
+            function kleinBottleY(u, v) {
+                if (u < Math.PI) {
+                    return 3 * Math.sin(u) * (1 + Math.sin(u)) + scale * Math.sin(u) * Math.cos(v);
+                } else {
+                    return 3 * Math.sin(u) * (1 + Math.sin(u));
+                }
+            }
+
+            function kleinBottleZ(u, v) {
+                if (u < Math.PI) {
+                    return scale * Math.sin(v);
+                } else {
+                    return scale * Math.sin(v + Math.PI);
+                }
+            }
+
+            for (let i = 0; i <= numU; i++) {
+                const u = (i / numU) * 2 * Math.PI;
+                ctx.beginPath();
+                for (let j = 0; j <= numV; j++) {
+                    const v = (j / numV) * 2 * Math.PI;
+                    const x = kleinBottleX(u, v);
+                    const y = kleinBottleY(u, v);
+                    const z = kleinBottleZ(u, v);
+
+                    // Simple 2D projection
+                    const xProj = centerX + x - z * 0.5;
+                    const yProj = centerY + y - z * 0.5;
+
+                    if (j === 0) {
+                        ctx.moveTo(xProj, yProj);
+                    } else {
+                        ctx.lineTo(xProj, yProj);
+                    }
+                }
+                ctx.stroke();
+            }
+
+            for (let j = 0; j <= numV; j++) {
+                const v = (j / numV) * 2 * Math.PI;
+                ctx.beginPath();
+                for (let i = 0; i <= numU; i++) {
+                    const u = (i / numU) * 2 * Math.PI;
+                    const x = kleinBottleX(u, v);
+                    const y = kleinBottleY(u, v);
+                    const z = kleinBottleZ(u, v);
+
+                    // Simple 2D projection
+                    const xProj = centerX + x - z * 0.5;
+                    const yProj = centerY + y - z * 0.5;
+
+                    if (i === 0) {
+                        ctx.moveTo(xProj, yProj);
+                    } else {
+                        ctx.lineTo(xProj, yProj);
+                    }
+                }
+                ctx.stroke();
+            }
+        }
+
+        drawKleinBottle();
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/quart_motion.html b/rubbish/quart_motion.html
new file mode 100644
index 0000000..e63c35a
--- /dev/null
+++ b/rubbish/quart_motion.html
@@ -0,0 +1,73 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Dynamic Complex Line Drawing</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #333;
+        }
+        canvas {
+            border: 1px solid black;
+            background-color: #333;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="complexLineCanvas" width="600" height="600"></canvas>
+    <script>
+        const canvas = document.getElementById('complexLineCanvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const numLines = 360;
+
+        let angleMultiplier1 = 2;
+        let angleMultiplier2 = 4;
+        let radius1 = 100;
+        let radius2 = 400;
+        let radius_multiplier = 10;
+        let angleOffset = 0;
+
+        // Function to draw the complex pattern
+        function drawComplexPattern() {
+            ctx.clearRect(0, 0, canvas.width, canvas.height);
+            ctx.strokeStyle = '#ffffff';
+            ctx.lineWidth = 0.5;
+
+            for (let i = 0; i < numLines; i++) {
+                const angle1 = (i / numLines) * 2 * Math.PI;
+                const angle2 = ((i + 180) / numLines) * 2 * Math.PI;
+                const x1 = centerX + radius_multiplier * radius1 * Math.cos(angleMultiplier1 * (angle1 + angleOffset)) * Math.sin(angle2 + angleOffset);
+                const y1 = centerY + radius_multiplier * radius1 * Math.sin(angleMultiplier2 * (angle1 + angleOffset)) * Math.sin(angle2 + angleOffset);
+                const x2 = centerX + radius2 * Math.cos(angle2 + angleOffset) * Math.sin(angle1 + angleOffset);
+                const y2 = centerY + radius2 * Math.sin(angle2 + angleOffset) * Math.sin(angle1 + angleOffset);
+
+                ctx.beginPath();
+                ctx.moveTo(x1, y1);
+                ctx.lineTo(x2, y2);
+                ctx.stroke();
+            }
+
+            // Update parameters to create animation
+            angleOffset += 0.01;
+            radius_multiplier = 10*Math.sin(angleOffset);
+            angleMultiplier1 = 2 + Math.sin(angleOffset) * 2;
+            angleMultiplier2 = 4 + Math.cos(angleOffset) * 2;
+            radius1 = 100 + Math.sin(3*angleOffset) * 50;
+            radius2 = 400 + Math.cos(angleOffset) * 50;
+
+            requestAnimationFrame(drawComplexPattern);
+        }
+
+        drawComplexPattern();
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/rotating_sector.html b/rubbish/rotating_sector.html
new file mode 100644
index 0000000..84cc14b
--- /dev/null
+++ b/rubbish/rotating_sector.html
@@ -0,0 +1,60 @@
+<!DOCTYPE html>
+<html>
+<body>
+
+<canvas id="illusionCanvas" width="1200" height="1200"></canvas>
+
+<script>
+
+
+
+// Function to draw a sector of a circle and radially cut it into half
+function drawSector(ctx, x, y, radius, startAngle, endAngle, fillColor) {
+    ctx.beginPath(); // Start a new path
+    ctx.moveTo(x, y); // Move to the center of the circle
+    ctx.arc(x, y, radius, startAngle, endAngle); // Draw the outer arc
+    ctx.closePath(); // Create a straight line back to the center of the circle
+    ctx.fillStyle = fillColor; // Set the fill color
+    ctx.fill(); // Fill the sector with color
+    ctx.strokeStyle = 'white'; // Fill the sector with color
+
+    ctx.stroke(); // Draw the line
+}
+
+// Get the canvas element and its context
+const canvas = document.getElementById('illusionCanvas');
+const ctx = canvas.getContext('2d');
+var shift_angle = 0;
+var sub_shift_angle = 2 * Math.PI / 180; // Slow rotation for the pentagon
+
+function draw() {
+
+    shift_angle += sub_shift_angle;
+    ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
+
+    //draw_rotating_spoke(spokeCenterX, spokeCenterY, maxRadius / 5, sub_shift_angle); // Draw each spoke
+// Example usage: Draw a sector of a circle and radially cut it into half
+// Parameters: context, centerX, centerY, radius, startAngle, endAngle, fillColor
+var ngon = 6;
+var mysize = Math.PI * 2/ngon;
+var mysize_diff = mysize/10;
+
+for (let angle = 0.0; angle < 2*Math.PI; angle += mysize) {
+drawSector(ctx, 200, 200, 100, angle+shift_angle, angle+mysize-mysize_diff+shift_angle, 'blue'); // Drawing and cutting a quarter circle sector
+drawSector(ctx, 200, 200, 3*100/4, angle+shift_angle, angle+mysize-mysize_diff+shift_angle, 'white'); // Drawing and cutting a quarter circle sector
+drawSector(ctx, 200, 200, 100/2, angle+shift_angle, angle+mysize-mysize_diff+shift_angle, 'blue'); // Drawing and cutting a quarter circle sector
+drawSector(ctx, 200, 200, 100/4, angle+shift_angle, angle+mysize-mysize_diff+shift_angle, 'white'); // Drawing and cutting a quarter circle sector
+}
+
+    window.requestAnimationFrame(draw); // Continue the animation
+}
+
+
+
+
+draw();
+</script>
+
+</body>
+</html>
+
diff --git a/rubbish/rotating_spiral.html b/rubbish/rotating_spiral.html
new file mode 100644
index 0000000..e5fca82
--- /dev/null
+++ b/rubbish/rotating_spiral.html
@@ -0,0 +1,101 @@
+<!DOCTYPE html>
+<html>
+<body>
+
+<canvas id="illusionCanvas" width="1200" height="1200"></canvas>
+
+<script>
+const canvas = document.getElementById('illusionCanvas');
+const ctx = canvas.getContext('2d');
+
+const centerX = canvas.width / 2;
+const centerY = canvas.height / 2;
+const sector = 30;
+const maxRadius = Math.min(canvas.width, canvas.height) / 2;
+
+var sub_shift_angle = 0;
+
+function multi_spiral() {
+
+	sub_shift_angle += 2*Math.PI/sector/10;
+        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
+	for (let shift_angle = 0; shift_angle < 4*Math.PI; shift_angle += 2*Math.PI/sector) {
+		draw_spiral(centerX, centerY, maxRadius/20, maxRadius/6, sector, shift_angle);
+	}
+        window.requestAnimationFrame(multi_spiral); // Continue the animation if the square is not yet at its max size
+}
+
+function myloop() {
+
+for (let i = 0; i < sector; i++) {
+    let angle = (i / sector) * 2 * Math.PI;
+    let x = centerX + maxRadius * Math.cos(angle);
+    let y = centerY + maxRadius * Math.sin(angle);
+
+    ctx.strokeStyle = (i % 2 === 0) ? 'black' : 'blue';
+    ctx.lineWidth = 2;
+
+    ctx.beginPath();
+    ctx.moveTo(centerX, centerY);
+    ctx.lineTo(x, y);
+    ctx.stroke();
+
+}
+}
+
+function draw_center_spiral(centerx, centery, small_rad, large_rad, mysector) {
+    for (let i = 0; i < mysector; i++) {
+        let angle = (i / mysector) * 2 * Math.PI;
+
+        let x = centerx + (small_rad+large_rad*angle) * Math.cos(angle);
+        let y = centery + (small_rad+large_rad*angle) * Math.sin(angle);
+
+        ctx.strokeStyle = (i % 2 === 0) ? 'black' : 'red';
+
+        ctx.beginPath();
+        ctx.moveTo(centerx, centery);
+        ctx.lineTo(x, y);
+        ctx.stroke();
+    }
+}
+
+function draw_spiral(centerx, centery, small_rad, large_rad, mysector, shift_angle) {
+
+        ctx.strokeStyle = 'black';
+        ctx.beginPath();
+        ctx.moveTo(centerx, centery);
+    for (let i = 0; i < mysector; i++) {
+        let angle = (i / mysector) * 2 * Math.PI;
+
+        let x = centerx + (small_rad+large_rad*angle) * Math.cos(angle+shift_angle+sub_shift_angle);
+        let y = centery + (small_rad+large_rad*angle) * Math.sin(angle+shift_angle+sub_shift_angle);
+
+
+        ctx.lineTo(x, y);
+    }
+        ctx.stroke();
+}
+
+function draw_spoke(myx, myy, radius, mysector) {
+    for (let i = 0; i < mysector; i++) {
+        let angle = (i / mysector) * 2 * Math.PI;
+
+        let x = myx + radius * Math.cos(angle);
+        let y = myy + radius * Math.sin(angle);
+
+        ctx.strokeStyle = (i % 2 === 0) ? 'black' : 'red';
+
+        ctx.beginPath();
+        ctx.moveTo(myx, myy);
+        ctx.lineTo(x, y);
+        ctx.stroke();
+    }
+}
+
+multi_spiral();
+
+</script>
+
+</body>
+</html>
+
diff --git a/rubbish/rotating_spoke.html b/rubbish/rotating_spoke.html
new file mode 100644
index 0000000..e4c949f
--- /dev/null
+++ b/rubbish/rotating_spoke.html
@@ -0,0 +1,57 @@
+<!DOCTYPE html>
+<html>
+<body>
+
+<canvas id="illusionCanvas" width="1200" height="1200"></canvas>
+
+<script>
+const canvas = document.getElementById('illusionCanvas');
+const ctx = canvas.getContext('2d');
+
+const centerX = canvas.width / 2;
+const centerY = canvas.height / 2;
+const sector = 30;
+const maxRadius = Math.min(canvas.width, canvas.height) / 2;
+var sub_shift_angle = 0;
+
+function draw_main_spoke() {
+	sub_shift_angle += 2*Math.PI/sector/10;
+        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
+for (let i = 0; i < sector; i++) {
+    let angle = (i / sector) * 2 * Math.PI;
+    let x = centerX + maxRadius * Math.cos(angle+sub_shift_angle);
+    let y = centerY + maxRadius * Math.sin(angle+sub_shift_angle);
+
+    ctx.strokeStyle = (i % 2 === 0) ? 'black' : 'blue';
+    ctx.lineWidth = 2;
+
+    ctx.beginPath();
+    ctx.moveTo(centerX, centerY);
+    ctx.lineTo(x, y);
+    ctx.stroke();
+}
+        window.requestAnimationFrame(draw_main_spoke); // Continue the animation if the square is not yet at its max size
+}
+
+function draw_spoke(myx, myy, radius, mysector) {
+    for (let i = 0; i < mysector; i++) {
+        let angle = (i / mysector) * 2 * Math.PI;
+
+        let x = myx + radius * Math.cos(angle);
+        let y = myy + radius * Math.sin(angle);
+
+        ctx.strokeStyle = (i % 2 === 0) ? 'black' : 'red';
+
+        ctx.beginPath();
+        ctx.moveTo(myx, myy);
+        ctx.lineTo(x, y);
+        ctx.stroke();
+    }
+}
+
+draw_main_spoke();
+</script>
+
+</body>
+</html>
+
diff --git a/rubbish/sinsoidal5.html b/rubbish/sinsoidal5.html
new file mode 100644
index 0000000..b129226
--- /dev/null
+++ b/rubbish/sinsoidal5.html
@@ -0,0 +1,73 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Sinusoidal Wave Animation</title>
+    <style>
+        body, html {
+            margin: 0;
+            padding: 0;
+            overflow: hidden;
+            background-color: #000;
+        }
+        canvas {
+            display: block;
+            background-color: #111;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="waveCanvas"></canvas>
+
+    <script>
+        const canvas = document.getElementById('waveCanvas');
+        const ctx = canvas.getContext('2d');
+
+        canvas.width = window.innerWidth;
+        canvas.height = window.innerHeight;
+
+        let waveOffset1 = 0;
+        let waveOffset2 = 0;
+        let waveOffset3 = 0;
+        let waveOffset4 = 0;
+        let waveOffset5 = 0;
+
+        function drawWave(frequency, amplitude, offset, speed, color, shift) {
+            ctx.beginPath();
+            ctx.moveTo(0, canvas.height / 2);
+
+            for (let x = 0; x < canvas.width; x++) {
+                let y = amplitude * Math.sin((x + offset + shift) * frequency) + (canvas.height / 2);
+                ctx.lineTo(x, y);
+            }
+
+            ctx.strokeStyle = color;
+            ctx.stroke();
+        }
+
+        function animate() {
+            ctx.clearRect(0, 0, canvas.width, canvas.height);
+
+            // Draw 5 different waves with different frequencies, amplitudes, speeds, and colors
+            drawWave(0.01, 50, waveOffset1, 0.5, 'rgba(255, 255, 255, 0.5)', 0);
+            drawWave(0.02, 40, waveOffset2, 1, 'rgba(0, 255, 0, 0.5)', 100);
+            drawWave(0.03, 30, waveOffset3, 1.5, 'rgba(0, 0, 255, 0.5)', 200);
+            drawWave(0.04, 20, waveOffset4, 2, 'rgba(255, 0, 255, 0.5)', 300);
+            drawWave(0.05, 10, waveOffset5, 2.5, 'rgba(255, 255, 0, 0.5)', 400);
+
+            // Increment the offsets at different speeds
+            waveOffset1 += 0.5; 
+            waveOffset2 += 1; 
+            waveOffset3 += 1.5; 
+            waveOffset4 += 2; 
+            waveOffset5 += 2.5;
+
+            requestAnimationFrame(animate);
+        }
+
+        animate();
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/sinusoidal.html b/rubbish/sinusoidal.html
new file mode 100644
index 0000000..6d10017
--- /dev/null
+++ b/rubbish/sinusoidal.html
@@ -0,0 +1,62 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Sinusoidal Wave Animation</title>
+    <style>
+        body, html {
+            margin: 0;
+            padding: 0;
+            overflow: hidden;
+            background-color: #000;
+        }
+        canvas {
+            display: block;
+            background-color: #111;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="waveCanvas"></canvas>
+
+    <script>
+        const canvas = document.getElementById('waveCanvas');
+        const ctx = canvas.getContext('2d');
+
+        canvas.width = window.innerWidth;
+        canvas.height = window.innerHeight;
+
+        let waveOffset = 0;
+
+        function drawWave(frequency, amplitude, speed, color, shift) {
+            ctx.beginPath();
+            ctx.moveTo(0, canvas.height / 2);
+
+            for (let x = 0; x < canvas.width; x++) {
+                let y = amplitude * Math.sin((x + waveOffset + shift) * frequency) + (canvas.height / 2);
+                ctx.lineTo(x, y);
+            }
+
+            ctx.strokeStyle = color;
+            ctx.stroke();
+        }
+
+        function animate() {
+            ctx.clearRect(0, 0, canvas.width, canvas.height);
+
+            // Draw multiple waves with different frequencies, amplitudes, and colors
+            drawWave(0.01, 50, 0.5, 'rgba(255, 255, 255, 0.5)', 0); // base wave
+            drawWave(0.02, 30, 1, 'rgba(0, 255, 0, 0.5)', 100); // secondary wave
+            drawWave(0.03, 20, 1.5, 'rgba(0, 0, 255, 0.5)', 200); // tertiary wave
+
+            waveOffset += 2; // Increase to make the wave move faster
+
+            requestAnimationFrame(animate);
+        }
+
+        animate();
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/solid_torus.html b/rubbish/solid_torus.html
new file mode 100644
index 0000000..4af7c1d
--- /dev/null
+++ b/rubbish/solid_torus.html
@@ -0,0 +1,157 @@
+
+
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>3D Shapes with Three.js</title>
+    <style>
+        body { margin: 0; }
+        canvas { display: block; }
+    </style>
+</head>
+<body>
+    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
+    <script>
+        let scene, camera, renderer;
+        let xrot = 0.2, yrot = 0.0, zrot = 0.0;
+        let mouseDown = false;
+        let xdiff = 0.0, ydiff = 0.0;
+        let counter = 0;
+
+        function init() {
+            scene = new THREE.Scene();
+            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 100);
+            camera.position.z = 10;
+
+            renderer = new THREE.WebGLRenderer();
+            renderer.setSize(window.innerWidth, window.innerHeight);
+            document.body.appendChild(renderer.domElement);
+
+            // Wireframe sphere
+            const wireframeSphere = new THREE.Mesh(
+                new THREE.SphereGeometry(2, 10, 10),
+                new THREE.MeshBasicMaterial({ color: 0x800080, wireframe: true })
+            );
+            scene.add(wireframeSphere);
+
+            // Wireframe cube
+            const wireframeCube = new THREE.Mesh(
+                new THREE.BoxGeometry(1, 1, 1),
+                new THREE.MeshBasicMaterial({ color: 0x805050, wireframe: true })
+            );
+            scene.add(wireframeCube);
+
+            // Wireframe torus
+            const wireframeTorus = new THREE.Mesh(
+                new THREE.TorusGeometry(3, 1, 5, 5),
+                new THREE.MeshBasicMaterial({ color: 0x809999, wireframe: true })
+            );
+            scene.add(wireframeTorus);
+
+            // Solid torus
+            const solidTorus = new THREE.Mesh(
+                new THREE.TorusGeometry(4, 2, 6, 18),
+                new THREE.MeshBasicMaterial({ color: 0x80e6ff })
+            );
+            scene.add(solidTorus);
+
+            // Solid shapes
+            const solidDodecahedron = new THREE.Mesh(
+                new THREE.DodecahedronGeometry(),
+                new THREE.MeshBasicMaterial({ color: 0xff0000 })
+            );
+            scene.add(solidDodecahedron);
+
+            const solidOctahedron = new THREE.Mesh(
+                new THREE.OctahedronGeometry(),
+                new THREE.MeshBasicMaterial({ color: 0x00ff00 })
+            );
+            scene.add(solidOctahedron);
+
+            const solidTetrahedron = new THREE.Mesh(
+                new THREE.TetrahedronGeometry(),
+                new THREE.MeshBasicMaterial({ color: 0xffff00 })
+            );
+            scene.add(solidTetrahedron);
+
+            const solidIcosahedron = new THREE.Mesh(
+                new THREE.IcosahedronGeometry(),
+                new THREE.MeshBasicMaterial({ color: 0xff0000 })
+            );
+            scene.add(solidIcosahedron);
+
+            // Conditional teapot shape (approximated with a torus knot for demo)
+            const teapotGeometry = new THREE.TorusKnotGeometry(0.5, 0.2, 100, 16);
+            const teapotMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
+            const solidTeapot = new THREE.Mesh(teapotGeometry, teapotMaterial);
+            scene.add(solidTeapot);
+
+            // Solid cone
+            const solidCone = new THREE.Mesh(
+                new THREE.ConeGeometry(1, 1, 10),
+                new THREE.MeshBasicMaterial({ color: 0x00ff00 })
+            );
+            scene.add(solidCone);
+
+            // Solid cube
+            const solidCube = new THREE.Mesh(
+                new THREE.BoxGeometry(1, 1, 1),
+                new THREE.MeshBasicMaterial({ color: 0xffff00 })
+            );
+            scene.add(solidCube);
+
+            window.addEventListener('resize', onWindowResize, false);
+            document.addEventListener('mousemove', onMouseMove, false);
+            document.addEventListener('mousedown', onMouseDown, false);
+            document.addEventListener('mouseup', onMouseUp, false);
+
+            animate();
+        }
+
+        function animate() {
+            requestAnimationFrame(animate);
+
+            if (!mouseDown) {
+                xrot += 0.3;
+                yrot += 0.3;
+                zrot += 1.0;
+            }
+
+            scene.rotation.x = xrot * Math.PI / 180;
+            scene.rotation.y = yrot * Math.PI / 180;
+            scene.rotation.z = zrot * Math.PI / 180;
+
+            renderer.render(scene, camera);
+        }
+
+        function onWindowResize() {
+            camera.aspect = window.innerWidth / window.innerHeight;
+            camera.updateProjectionMatrix();
+            renderer.setSize(window.innerWidth, window.innerHeight);
+        }
+
+        function onMouseMove(event) {
+            if (mouseDown) {
+                yrot = event.clientX - xdiff;
+                xrot = event.clientY + ydiff;
+            }
+        }
+
+        function onMouseDown(event) {
+            mouseDown = true;
+            xdiff = event.clientX - yrot;
+            ydiff = event.clientY - xrot;
+        }
+
+        function onMouseUp() {
+            mouseDown = false;
+        }
+
+        init();
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/solid_torus1.html b/rubbish/solid_torus1.html
new file mode 100644
index 0000000..bec4a9b
--- /dev/null
+++ b/rubbish/solid_torus1.html
@@ -0,0 +1,156 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>3D Wireframe Shapes with Three.js</title>
+    <style>
+        body { margin: 0; }
+        canvas { display: block; }
+    </style>
+</head>
+<body>
+    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
+    <script>
+        let scene, camera, renderer;
+        let xrot = 0.2, yrot = 0.0, zrot = 0.0;
+        let mouseDown = false;
+        let xdiff = 0.0, ydiff = 0.0;
+        let counter = 0;
+
+        function init() {
+            scene = new THREE.Scene();
+            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 100);
+            camera.position.z = 10;
+
+            renderer = new THREE.WebGLRenderer();
+            renderer.setSize(window.innerWidth, window.innerHeight);
+            document.body.appendChild(renderer.domElement);
+
+            // Wireframe materials
+            const wireframeMaterial = new THREE.MeshBasicMaterial({ color: 0x808080, wireframe: true });
+
+            // Wireframe sphere
+            const wireframeSphere = new THREE.Mesh(
+                new THREE.SphereGeometry(2, 10, 10),
+                wireframeMaterial
+            );
+            scene.add(wireframeSphere);
+
+            // Wireframe cube
+            const wireframeCube = new THREE.Mesh(
+                new THREE.BoxGeometry(1, 1, 1),
+                wireframeMaterial
+            );
+            scene.add(wireframeCube);
+
+            // Wireframe torus
+            const wireframeTorus = new THREE.Mesh(
+                new THREE.TorusGeometry(3, 1, 5, 5),
+                wireframeMaterial
+            );
+            scene.add(wireframeTorus);
+
+            // Solid torus (also wireframe for consistency)
+            const solidTorus = new THREE.Mesh(
+                new THREE.TorusGeometry(4, 2, 6, 18),
+                wireframeMaterial
+            );
+            scene.add(solidTorus);
+
+            // Solid shapes (all wireframe)
+            const solidDodecahedron = new THREE.Mesh(
+                new THREE.DodecahedronGeometry(),
+                wireframeMaterial
+            );
+            scene.add(solidDodecahedron);
+
+            const solidOctahedron = new THREE.Mesh(
+                new THREE.OctahedronGeometry(),
+                wireframeMaterial
+            );
+            scene.add(solidOctahedron);
+
+            const solidTetrahedron = new THREE.Mesh(
+                new THREE.TetrahedronGeometry(),
+                wireframeMaterial
+            );
+            scene.add(solidTetrahedron);
+
+            const solidIcosahedron = new THREE.Mesh(
+                new THREE.IcosahedronGeometry(),
+                wireframeMaterial
+            );
+            scene.add(solidIcosahedron);
+
+            // Conditional teapot shape (approximated with a torus knot for demo)
+            const teapotGeometry = new THREE.TorusKnotGeometry(0.5, 0.2, 100, 16);
+            const solidTeapot = new THREE.Mesh(teapotGeometry, wireframeMaterial);
+            scene.add(solidTeapot);
+
+            // Solid cone
+            const solidCone = new THREE.Mesh(
+                new THREE.ConeGeometry(1, 1, 10),
+                wireframeMaterial
+            );
+            scene.add(solidCone);
+
+            // Solid cube
+            const solidCube = new THREE.Mesh(
+                new THREE.BoxGeometry(1, 1, 1),
+                wireframeMaterial
+            );
+            scene.add(solidCube);
+
+            window.addEventListener('resize', onWindowResize, false);
+            document.addEventListener('mousemove', onMouseMove, false);
+            document.addEventListener('mousedown', onMouseDown, false);
+            document.addEventListener('mouseup', onMouseUp, false);
+
+            animate();
+        }
+
+        function animate() {
+            requestAnimationFrame(animate);
+
+            if (!mouseDown) {
+                xrot += 0.3;
+                yrot += 0.3;
+                zrot += 1.0;
+            }
+
+            scene.rotation.x = xrot * Math.PI / 180;
+            scene.rotation.y = yrot * Math.PI / 180;
+            scene.rotation.z = zrot * Math.PI / 180;
+
+            renderer.render(scene, camera);
+        }
+
+        function onWindowResize() {
+            camera.aspect = window.innerWidth / window.innerHeight;
+            camera.updateProjectionMatrix();
+            renderer.setSize(window.innerWidth, window.innerHeight);
+        }
+
+        function onMouseMove(event) {
+            if (mouseDown) {
+                yrot = event.clientX - xdiff;
+                xrot = event.clientY + ydiff;
+            }
+        }
+
+        function onMouseDown(event) {
+            mouseDown = true;
+            xdiff = event.clientX - yrot;
+            ydiff = event.clientY - xrot;
+        }
+
+        function onMouseUp() {
+            mouseDown = false;
+        }
+
+        init();
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/special.html b/rubbish/special.html
new file mode 100644
index 0000000..1ae2119
--- /dev/null
+++ b/rubbish/special.html
@@ -0,0 +1,99 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>3D Mesh Line Drawing</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+            background-color: #fff;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="meshCanvas" width="600" height="600"></canvas>
+    <script>
+        const canvas = document.getElementById('meshCanvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const scale = 100;
+        const numU = 200;
+        const numV = 100;
+
+        function drawMesh() {
+            ctx.clearRect(0, 0, canvas.width, canvas.height);
+            ctx.strokeStyle = '#FF0000';
+            ctx.lineWidth = 0.5;
+
+            function meshX(u, v) {
+                return Math.cos(2*u) * (3 + Math.cos(v));
+            }
+
+            function meshY(u, v) {
+                return Math.sin(6*u) * (3 + Math.cos(v));
+            }
+
+            function meshZ(u, v) {
+                return Math.sin(v) + Math.sin(u);
+            }
+
+            for (let i = 0; i <= numU; i++) {
+                const u = (i / numU) * 2 * Math.PI;
+                ctx.beginPath();
+                for (let j = 0; j <= numV; j++) {
+                    const v = (j / numV) * 2 * Math.PI;
+                    const x = meshX(u, v);
+                    const y = meshY(u, v);
+                    const z = meshZ(u, v);
+
+                    // Simple 2D projection
+                    const xProj = centerX + x * scale;
+                    const yProj = centerY - y * scale;
+
+                    if (j === 0) {
+                        ctx.moveTo(xProj, yProj);
+                    } else {
+                        ctx.lineTo(xProj, yProj);
+                    }
+                }
+                ctx.stroke();
+            }
+
+            for (let j = 0; j <= numV; j++) {
+                const v = (j / numV) * 2 * Math.PI;
+                ctx.beginPath();
+                for (let i = 0; i <= numU; i++) {
+                    const u = (i / numU) * 2 * Math.PI;
+                    const x = meshX(u, v);
+                    const y = meshY(u, v);
+                    const z = meshZ(u, v);
+
+                    // Simple 2D projection
+                    const xProj = centerX + x * scale;
+                    const yProj = centerY - y * scale;
+
+                    if (i === 0) {
+                        ctx.moveTo(xProj, yProj);
+                    } else {
+                        ctx.lineTo(xProj, yProj);
+                    }
+                }
+                ctx.stroke();
+            }
+        }
+
+        drawMesh();
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/spherical_sinusoid.html b/rubbish/spherical_sinusoid.html
new file mode 100644
index 0000000..7d62879
--- /dev/null
+++ b/rubbish/spherical_sinusoid.html
@@ -0,0 +1,94 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Sinusoidal Waves Around a Sphere with Perspective Control</title>
+    <style>
+        body, html {
+            margin: 0;
+            padding: 0;
+            overflow: hidden;
+            background-color: #000;
+        }
+        canvas {
+            display: block;
+            background-color: #111;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="waveCanvas"></canvas>
+
+    <script>
+        const canvas = document.getElementById('waveCanvas');
+        const ctx = canvas.getContext('2d');
+
+        canvas.width = window.innerWidth;
+        canvas.height = window.innerHeight;
+
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const radius = Math.min(canvas.width, canvas.height) / 3;
+
+        let waveOffset1 = 0;
+        let waveOffset2 = 0;
+        let waveOffset3 = 0;
+        let waveOffset4 = 0;
+        let waveOffset5 = 0;
+
+        let perspectiveAngle = 0; // Angle in radians
+
+        function drawWaveAroundSphere(frequency, amplitude, offset, speed, color, shift) {
+            ctx.beginPath();
+
+            for (let angle = 0; angle <= 360; angle += 1) {
+                let radian = angle * (Math.PI / 180);
+                let x = centerX + radius * Math.cos(radian) * Math.cos(perspectiveAngle);
+                let y = centerY + radius * Math.sin(radian) + amplitude * Math.sin((radian * frequency) + offset + shift);
+                
+                if (angle === 0) {
+                    ctx.moveTo(x, y);
+                } else {
+                    ctx.lineTo(x, y);
+                }
+            }
+
+            ctx.strokeStyle = color;
+            ctx.stroke();
+        }
+
+        function animate() {
+            ctx.clearRect(0, 0, canvas.width, canvas.height);
+
+            // Draw 5 different waves moving around the sphere with perspective
+            drawWaveAroundSphere(3, 20, waveOffset1, 0.5, 'rgba(255, 255, 255, 0.5)', 0);
+            drawWaveAroundSphere(4, 15, waveOffset2, 1, 'rgba(0, 255, 0, 0.5)', 100);
+            drawWaveAroundSphere(5, 10, waveOffset3, 1.5, 'rgba(0, 0, 255, 0.5)', 200);
+            drawWaveAroundSphere(6, 5, waveOffset4, 2, 'rgba(255, 0, 255, 0.5)', 300);
+            drawWaveAroundSphere(7, 3, waveOffset5, 2.5, 'rgba(255, 255, 0, 0.5)', 400);
+
+            // Increment the offsets at different speeds
+            waveOffset1 += 0.05; 
+            waveOffset2 += 0.08; 
+            waveOffset3 += 0.12; 
+            waveOffset4 += 0.15; 
+            waveOffset5 += 0.2;
+
+            requestAnimationFrame(animate);
+        }
+
+        function onMouseMove(event) {
+            const rect = canvas.getBoundingClientRect();
+            const mouseX = event.clientX - rect.left;
+            perspectiveAngle = (mouseX - centerX) / canvas.width * Math.PI * 2;
+        }
+
+        // Event listener to change perspective based on mouse movement
+        canvas.addEventListener('mousemove', onMouseMove);
+
+        animate();
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/spherical_sinusoid1.html b/rubbish/spherical_sinusoid1.html
new file mode 100644
index 0000000..7d62879
--- /dev/null
+++ b/rubbish/spherical_sinusoid1.html
@@ -0,0 +1,94 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Sinusoidal Waves Around a Sphere with Perspective Control</title>
+    <style>
+        body, html {
+            margin: 0;
+            padding: 0;
+            overflow: hidden;
+            background-color: #000;
+        }
+        canvas {
+            display: block;
+            background-color: #111;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="waveCanvas"></canvas>
+
+    <script>
+        const canvas = document.getElementById('waveCanvas');
+        const ctx = canvas.getContext('2d');
+
+        canvas.width = window.innerWidth;
+        canvas.height = window.innerHeight;
+
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const radius = Math.min(canvas.width, canvas.height) / 3;
+
+        let waveOffset1 = 0;
+        let waveOffset2 = 0;
+        let waveOffset3 = 0;
+        let waveOffset4 = 0;
+        let waveOffset5 = 0;
+
+        let perspectiveAngle = 0; // Angle in radians
+
+        function drawWaveAroundSphere(frequency, amplitude, offset, speed, color, shift) {
+            ctx.beginPath();
+
+            for (let angle = 0; angle <= 360; angle += 1) {
+                let radian = angle * (Math.PI / 180);
+                let x = centerX + radius * Math.cos(radian) * Math.cos(perspectiveAngle);
+                let y = centerY + radius * Math.sin(radian) + amplitude * Math.sin((radian * frequency) + offset + shift);
+                
+                if (angle === 0) {
+                    ctx.moveTo(x, y);
+                } else {
+                    ctx.lineTo(x, y);
+                }
+            }
+
+            ctx.strokeStyle = color;
+            ctx.stroke();
+        }
+
+        function animate() {
+            ctx.clearRect(0, 0, canvas.width, canvas.height);
+
+            // Draw 5 different waves moving around the sphere with perspective
+            drawWaveAroundSphere(3, 20, waveOffset1, 0.5, 'rgba(255, 255, 255, 0.5)', 0);
+            drawWaveAroundSphere(4, 15, waveOffset2, 1, 'rgba(0, 255, 0, 0.5)', 100);
+            drawWaveAroundSphere(5, 10, waveOffset3, 1.5, 'rgba(0, 0, 255, 0.5)', 200);
+            drawWaveAroundSphere(6, 5, waveOffset4, 2, 'rgba(255, 0, 255, 0.5)', 300);
+            drawWaveAroundSphere(7, 3, waveOffset5, 2.5, 'rgba(255, 255, 0, 0.5)', 400);
+
+            // Increment the offsets at different speeds
+            waveOffset1 += 0.05; 
+            waveOffset2 += 0.08; 
+            waveOffset3 += 0.12; 
+            waveOffset4 += 0.15; 
+            waveOffset5 += 0.2;
+
+            requestAnimationFrame(animate);
+        }
+
+        function onMouseMove(event) {
+            const rect = canvas.getBoundingClientRect();
+            const mouseX = event.clientX - rect.left;
+            perspectiveAngle = (mouseX - centerX) / canvas.width * Math.PI * 2;
+        }
+
+        // Event listener to change perspective based on mouse movement
+        canvas.addEventListener('mousemove', onMouseMove);
+
+        animate();
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/spherical_sinusoid2.html b/rubbish/spherical_sinusoid2.html
new file mode 100644
index 0000000..4a1f7d8
--- /dev/null
+++ b/rubbish/spherical_sinusoid2.html
@@ -0,0 +1,39 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Sinusoidal Waves Around a Sphere (Side View)</title>
+    <style>
+        body, html {
+            margin: 0;
+            padding: 0;
+            overflow: hidden;
+            background-color: #000;
+        }
+        canvas {
+            display: block;
+            background-color: #111;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="waveCanvas"></canvas>
+
+    <script>
+        const canvas = document.getElementById('waveCanvas');
+        const ctx = canvas.getContext('2d');
+
+        canvas.width = window.innerWidth;
+        canvas.height = window.innerHeight;
+
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const radius = Math.min(canvas.width, canvas.height) / 3;
+
+        let waveOffset1 = 0;
+        let waveOffset2 = 0;
+        let waveOffset3 = 0;
+        let waveOffset4 = 0;
+        let waveOffset5 =
+
diff --git a/rubbish/spherical_sinusoid3.html b/rubbish/spherical_sinusoid3.html
new file mode 100644
index 0000000..201344f
--- /dev/null
+++ b/rubbish/spherical_sinusoid3.html
@@ -0,0 +1,94 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Sinusoidal Waves Around a Sphere (Side View)</title>
+    <style>
+        body, html {
+            margin: 0;
+            padding: 0;
+            overflow: hidden;
+            background-color: #000;
+        }
+        canvas {
+            display: block;
+            background-color: #111;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="waveCanvas"></canvas>
+
+    <script>
+        const canvas = document.getElementById('waveCanvas');
+        const ctx = canvas.getContext('2d');
+
+        canvas.width = window.innerWidth;
+        canvas.height = window.innerHeight;
+
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const radius = Math.min(canvas.width, canvas.height) / 3;
+
+        let waveOffset1 = 0;
+        let waveOffset2 = 0;
+        let waveOffset3 = 0;
+        let waveOffset4 = 0;
+        let waveOffset5 = 0;
+
+        let perspectiveAngle = 0; // Angle in radians
+
+        function drawWaveAroundSphere(frequency, amplitude, offset, speed, color, shift) {
+            ctx.beginPath();
+
+            for (let angle = 0; angle <= 360; angle += 1) {
+                let radian = angle * (Math.PI / 180);
+                let x = centerX + radius * Math.cos(radian + perspectiveAngle);
+                let y = centerY + amplitude * Math.sin((radian * frequency) + offset + shift) * Math.cos(radian);
+                
+                if (angle === 0) {
+                    ctx.moveTo(x, y);
+                } else {
+                    ctx.lineTo(x, y);
+                }
+            }
+
+            ctx.strokeStyle = color;
+            ctx.stroke();
+        }
+
+        function animate() {
+            ctx.clearRect(0, 0, canvas.width, canvas.height);
+
+            // Draw 5 different waves moving around the sphere with perspective
+            drawWaveAroundSphere(3, 20, waveOffset1, 0.5, 'rgba(255, 255, 255, 0.5)', 0);
+            drawWaveAroundSphere(4, 15, waveOffset2, 1, 'rgba(0, 255, 0, 0.5)', 100);
+            drawWaveAroundSphere(5, 10, waveOffset3, 1.5, 'rgba(0, 0, 255, 0.5)', 200);
+            drawWaveAroundSphere(6, 5, waveOffset4, 2, 'rgba(255, 0, 255, 0.5)', 300);
+            drawWaveAroundSphere(7, 3, waveOffset5, 2.5, 'rgba(255, 255, 0, 0.5)', 400);
+
+            // Increment the offsets at different speeds
+            waveOffset1 += 0.05; 
+            waveOffset2 += 0.08; 
+            waveOffset3 += 0.12; 
+            waveOffset4 += 0.15; 
+            waveOffset5 += 0.2;
+
+            requestAnimationFrame(animate);
+        }
+
+        function onMouseMove(event) {
+            const rect = canvas.getBoundingClientRect();
+            const mouseX = event.clientX - rect.left;
+            perspectiveAngle = (mouseX - centerX) / canvas.width * Math.PI * 2;
+        }
+
+        // Event listener to change perspective based on mouse movement
+        canvas.addEventListener('mousemove', onMouseMove);
+
+        animate();
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/spiral.html b/rubbish/spiral.html
new file mode 100644
index 0000000..75e17e5
--- /dev/null
+++ b/rubbish/spiral.html
@@ -0,0 +1,92 @@
+<!DOCTYPE html>
+<html>
+<body>
+
+<canvas id="illusionCanvas" width="1200" height="1200"></canvas>
+
+<script>
+const canvas = document.getElementById('illusionCanvas');
+const ctx = canvas.getContext('2d');
+
+const centerX = canvas.width / 2;
+const centerY = canvas.height / 2;
+const sector = 30;
+const maxRadius = Math.min(canvas.width, canvas.height) / 2;
+
+
+for (let shift_angle = 0; shift_angle < 4*Math.PI; shift_angle += 2*Math.PI/sector) {
+	draw_spiral(centerX, centerY, maxRadius/20, maxRadius/6, sector, shift_angle);
+}
+
+function myloop() {
+
+for (let i = 0; i < sector; i++) {
+    let angle = (i / sector) * 2 * Math.PI;
+    let x = centerX + maxRadius * Math.cos(angle);
+    let y = centerY + maxRadius * Math.sin(angle);
+
+    ctx.strokeStyle = (i % 2 === 0) ? 'black' : 'blue';
+    ctx.lineWidth = 2;
+
+    ctx.beginPath();
+    ctx.moveTo(centerX, centerY);
+    ctx.lineTo(x, y);
+    ctx.stroke();
+
+}
+}
+
+function draw_center_spiral(centerx, centery, small_rad, large_rad, mysector) {
+    for (let i = 0; i < mysector; i++) {
+        let angle = (i / mysector) * 2 * Math.PI;
+
+        let x = centerx + (small_rad+large_rad*angle) * Math.cos(angle);
+        let y = centery + (small_rad+large_rad*angle) * Math.sin(angle);
+
+        ctx.strokeStyle = (i % 2 === 0) ? 'black' : 'red';
+
+        ctx.beginPath();
+        ctx.moveTo(centerx, centery);
+        ctx.lineTo(x, y);
+        ctx.stroke();
+    }
+}
+
+function draw_spiral(centerx, centery, small_rad, large_rad, mysector, shift_angle) {
+
+        ctx.strokeStyle = 'black';
+        ctx.beginPath();
+        ctx.moveTo(centerx, centery);
+    for (let i = 0; i < mysector; i++) {
+        let angle = (i / mysector) * 2 * Math.PI;
+
+        let x = centerx + (small_rad+large_rad*angle) * Math.cos(angle+shift_angle);
+        let y = centery + (small_rad+large_rad*angle) * Math.sin(angle+shift_angle);
+
+
+        ctx.lineTo(x, y);
+    }
+        ctx.stroke();
+}
+
+function draw_spoke(myx, myy, radius, mysector) {
+    for (let i = 0; i < mysector; i++) {
+        let angle = (i / mysector) * 2 * Math.PI;
+
+        let x = myx + radius * Math.cos(angle);
+        let y = myy + radius * Math.sin(angle);
+
+        ctx.strokeStyle = (i % 2 === 0) ? 'black' : 'red';
+
+        ctx.beginPath();
+        ctx.moveTo(myx, myy);
+        ctx.lineTo(x, y);
+        ctx.stroke();
+    }
+}
+
+</script>
+
+</body>
+</html>
+
diff --git a/rubbish/spoke_subspokes.html b/rubbish/spoke_subspokes.html
new file mode 100644
index 0000000..2975321
--- /dev/null
+++ b/rubbish/spoke_subspokes.html
@@ -0,0 +1,52 @@
+<!DOCTYPE html>
+<html>
+<body>
+
+<canvas id="illusionCanvas" width="1200" height="1200"></canvas>
+
+<script>
+const canvas = document.getElementById('illusionCanvas');
+const ctx = canvas.getContext('2d');
+
+const centerX = canvas.width / 2;
+const centerY = canvas.height / 2;
+const sector = 30;
+const maxRadius = Math.min(canvas.width, canvas.height) / 2;
+
+for (let i = 0; i < sector; i++) {
+    let angle = (i / sector) * 2 * Math.PI;
+    let x = centerX + maxRadius * Math.cos(angle);
+    let y = centerY + maxRadius * Math.sin(angle);
+
+    ctx.strokeStyle = (i % 2 === 0) ? 'black' : 'blue';
+    ctx.lineWidth = 2;
+
+    ctx.beginPath();
+    ctx.moveTo(centerX, centerY);
+    ctx.lineTo(x, y);
+    ctx.stroke();
+
+    draw_spoke(x, y, maxRadius/4, sector*3);
+}
+
+function draw_spoke(myx, myy, radius, mysector) {
+    for (let i = 0; i < mysector; i++) {
+        let angle = (i / mysector) * 2 * Math.PI;
+
+        let x = myx + radius * Math.cos(angle);
+        let y = myy + radius * Math.sin(angle);
+
+        ctx.strokeStyle = (i % 2 === 0) ? 'black' : 'red';
+
+        ctx.beginPath();
+        ctx.moveTo(myx, myy);
+        ctx.lineTo(x, y);
+        ctx.stroke();
+    }
+}
+
+</script>
+
+</body>
+</html>
+
diff --git a/rubbish/static_concentric.html b/rubbish/static_concentric.html
new file mode 100644
index 0000000..db59846
--- /dev/null
+++ b/rubbish/static_concentric.html
@@ -0,0 +1,68 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Canvas Pattern</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #fff;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="patternCanvas" width="500" height="500"></canvas>
+    <script>
+        const canvas = document.getElementById('patternCanvas');
+        const ctx = canvas.getContext('2d');
+        const width = canvas.width;
+        const height = canvas.height;
+        const radius = 100;
+        const lineWidth = 2;
+
+        ctx.lineWidth = lineWidth;
+
+        const colors = ['#FF5733', '#33FF57', '#3357FF', '#FF33A1', '#A133FF']; // Array of colors
+        const numColors = colors.length;
+
+        function drawPattern() {
+            const offsetX = width / 2;
+            const offsetY = height / 2;
+            const spacing = 10;
+
+            drawArcs(offsetX, offsetY, radius, spacing);
+
+            /*for (let i = 0; i <= width / radius; i++) {
+                for (let j = 0; j <= height / radius; j++) {
+                }
+            }
+	    */
+        }
+
+        function drawArcs(x, y, radius, spacing) {
+            let colorIndex = Math.floor(Math.random() * 16);
+
+
+            for (let r = radius; r > 0; r -= spacing) {
+                ctx.strokeStyle = colors[colorIndex % numColors];
+                ctx.beginPath();
+                ctx.arc(x, y, r, 0, Math.PI * 2, false);
+                ctx.stroke();
+                
+                colorIndex++; // Move to the next color in the array
+            }
+        }
+
+        drawPattern();
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/three_petal.html b/rubbish/three_petal.html
new file mode 100644
index 0000000..7ac0f88
--- /dev/null
+++ b/rubbish/three_petal.html
@@ -0,0 +1,28 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Three Petal Shape Animation</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            background-color: white;
+            border: 1px solid #ccc;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="animationCanvas" width="600" height="600"></canvas>
+    <script src="three_petal.js"></script>
+</body>
+</html>
+
diff --git a/rubbish/torus.html b/rubbish/torus.html
new file mode 100644
index 0000000..efc0ec9
--- /dev/null
+++ b/rubbish/torus.html
@@ -0,0 +1,118 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>3D Shapes Wireframe</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="canvas" width="800" height="800"></canvas>
+    <script>
+        const canvas = document.getElementById('canvas');
+        const ctx = canvas.getContext('2d');
+        const width = canvas.width;
+        const height = canvas.height;
+        const centerX = width / 2;
+        const centerY = height / 2;
+        const scale = 50;
+
+        function drawShapes() {
+            //drawMobiusStrip(centerX - 250, centerY - 250);
+            //drawKleinBottle(centerX + 250, centerY - 250);
+            drawTorus(centerX, centerY); 
+        }
+
+        function drawMobiusStrip(offsetX, offsetY) {
+            const uStep = Math.PI / 18;
+            const vStep = 2 * Math.PI / 36;
+
+            for (let u = 0; u < 4 * Math.PI; u += uStep) {
+                for (let v = 1.0; v < 12.5; v += vStep) {
+                    const x = (1 + v * Math.cos(u / 2)) * Math.cos(u);
+                    const y = (1 + v * Math.cos(u / 2)) * Math.sin(u);
+                    const z = v * Math.sin(u / 2);
+
+                    const nextX = (1 + v * Math.cos((u + uStep) / 2)) * Math.cos(u + uStep);
+                    const nextY = (1 + v * Math.cos((u + uStep) / 2)) * Math.sin(u + uStep);
+                    const nextZ = v * Math.sin((u + uStep) / 2);
+
+                    drawLine(offsetX, offsetY, project(x, y, z), project(nextX, nextY, nextZ));
+                }
+            }
+        }
+
+        function drawKleinBottle(offsetX, offsetY) {
+            const uStep = Math.PI / 18;
+            const vStep = 2 * Math.PI / 36;
+
+            for (let u = 0; u < 4 * Math.PI; u += uStep) {
+                for (let v = 0; v < 4 * Math.PI; v += vStep) {
+                    const x = (10 + 20 * Math.cos(u)) * Math.cos(v);
+                    const y = (30 + 10* Math.cos(u)) * Math.sin(v);
+                    const z = 20 * Math.sin(u) * Math.cos(v / 2);
+
+                    const nextX = (40 + 2 * Math.cos(u + uStep)) * Math.cos(v);
+                    const nextY = (40 + 2 * Math.cos(u + uStep)) * Math.sin(v);
+                    const nextZ = 2 * Math.sin(u + uStep) * Math.cos(v / 2);
+
+                    drawLine(offsetX, offsetY, project(x, y, z), project(nextX, nextY, nextZ));
+                }
+            }
+        }
+
+        function drawTorus(offsetX, offsetY) {
+            const uStep = Math.PI / 18;
+            const vStep = 2 * Math.PI / 36;
+
+            for (let u = 0; u < 4 * Math.PI; u += uStep) {
+                for (let v = 0; v < 4 * Math.PI; v += vStep) {
+                    const R = 40;
+                    const r = 10;
+                    const x = (R + r * Math.cos(v)) * Math.cos(u);
+                    const y = (R + r * Math.cos(v)) * Math.sin(u);
+                    const z = r * Math.sin(v);
+
+                    const nextX = (R + r * Math.cos(v + vStep)) * Math.cos(u);
+                    const nextY = (R + r * Math.cos(v + vStep)) * Math.sin(u);
+                    const nextZ = r * Math.sin(v + vStep);
+
+                    drawLine(offsetX, offsetY, project(x, y, z), project(nextX, nextY, nextZ));
+                }
+            }
+        }
+
+        function project(x, y, z) {
+            const perspective = 500 / (500 + z);
+            return [
+                centerX + x * scale * perspective,
+                centerY - y * scale * perspective
+            ];
+        }
+
+        function drawLine(offsetX, offsetY, start, end) {
+            ctx.beginPath();
+            ctx.moveTo(start[0] + offsetX, start[1] + offsetY);
+            ctx.lineTo(end[0] + offsetX, end[1] + offsetY);
+            ctx.stroke();
+        }
+
+        ctx.clearRect(0, 0, width, height);
+        ctx.strokeStyle = 'black';
+        drawShapes();
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/torus2.html b/rubbish/torus2.html
new file mode 100644
index 0000000..c7712b0
--- /dev/null
+++ b/rubbish/torus2.html
@@ -0,0 +1,273 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Dynamic 3D Spiral Surface - WebGL</title>
+    <style>
+        body, html { margin: 0; padding: 0; overflow: hidden; background-color: black; }
+        canvas { display: block; cursor: pointer; }
+    </style>
+</head>
+<body>
+    <canvas id="glCanvas"></canvas>
+
+    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
+    <script>
+        let canvas = document.getElementById('glCanvas');
+        let gl = canvas.getContext('webgl');
+
+        if (!gl) {
+            alert('WebGL not supported, falling back on experimental-webgl');
+            gl = canvas.getContext('experimental-webgl');
+        }
+
+        if (!gl) {
+            alert('Your browser does not support WebGL');
+        }
+
+        function resizeCanvas() {
+            canvas.width = window.innerWidth;
+            canvas.height = window.innerHeight;
+            gl.viewport(0, 0, canvas.width, canvas.height);
+        }
+
+        window.addEventListener('resize', resizeCanvas);
+        resizeCanvas();
+
+        // Variables for rotation control
+        let rotationX = 0;
+        let rotationY = 0;
+        let isDragging = false;
+        let lastMouseX = 0;
+        let lastMouseY = 0;
+
+        // Event listeners for mouse interactions
+        canvas.addEventListener('mousedown', (event) => {
+            isDragging = true;
+            lastMouseX = event.clientX;
+            lastMouseY = event.clientY;
+        });
+
+        canvas.addEventListener('mousemove', (event) => {
+            if (isDragging) {
+                let deltaX = event.clientX - lastMouseX;
+                let deltaY = event.clientY - lastMouseY;
+
+                rotationX += deltaY * 0.01;
+                rotationY += deltaX * 0.01;
+
+                lastMouseX = event.clientX;
+                lastMouseY = event.clientY;
+            }
+        });
+
+        canvas.addEventListener('mouseup', () => {
+            isDragging = false;
+        });
+
+        canvas.addEventListener('mouseleave', () => {
+            isDragging = false;
+        });
+
+        // Vertex shader program
+        const vsSource = `
+            attribute vec4 aVertexPosition;
+            uniform mat4 uModelViewMatrix;
+            uniform mat4 uProjectionMatrix;
+            void main(void) {
+                gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
+            }
+        `;
+
+        // Fragment shader program
+        const fsSource = `
+            void main(void) {
+                gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
+            }
+        `;
+
+        // Initialize a shader program; this is where all the lighting
+        // for the vertices and so forth is established.
+        const shaderProgram = initShaderProgram(gl, vsSource, fsSource);
+
+        // Collect all the info needed to use the shader program.
+        const programInfo = {
+            program: shaderProgram,
+            attribLocations: {
+                vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
+            },
+            uniformLocations: {
+                projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
+                modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
+            },
+        };
+
+        // Here's where we call the routine that builds all the objects
+        // we'll be drawing.
+        const buffers = initBuffers(gl);
+
+        let then = 0;
+
+        // Draw the scene repeatedly
+        function render(now) {
+            now *= 0.001;  // convert to seconds
+            const deltaTime = now - then;
+            then = now;
+
+            drawScene(gl, programInfo, buffers, deltaTime);
+
+            requestAnimationFrame(render);
+        }
+        requestAnimationFrame(render);
+
+        function initShaderProgram(gl, vsSource, fsSource) {
+            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
+            const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
+
+            // Create the shader program
+            const shaderProgram = gl.createProgram();
+            gl.attachShader(shaderProgram, vertexShader);
+            gl.attachShader(shaderProgram, fragmentShader);
+            gl.linkProgram(shaderProgram);
+
+            // If creating the shader program failed, alert
+            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
+                alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
+                return null;
+            }
+
+            return shaderProgram;
+        }
+
+        function loadShader(gl, type, source) {
+            const shader = gl.createShader(type);
+
+            // Send the source to the shader object
+            gl.shaderSource(shader, source);
+
+            // Compile the shader program
+            gl.compileShader(shader);
+
+            // See if it compiled successfully
+            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
+                alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
+                gl.deleteShader(shader);
+                return null;
+            }
+
+            return shader;
+        }
+
+        function initBuffers(gl) {
+            // Create a buffer for the spiral's vertex positions.
+            const positionBuffer = gl.createBuffer();
+
+            // Select the positionBuffer as the one to apply buffer
+            // operations to from here out.
+            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
+
+            // Now create an array of positions for the spiral surface.
+            const positions = createSpiralSurface();
+
+            // Now pass the list of positions into WebGL to build the
+            // shape. We do this by creating a Float32Array from the
+            // JavaScript array, then use it to fill the current buffer.
+            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
+
+            return {
+                position: positionBuffer,
+                vertexCount: positions.length / 3
+            };
+        }
+
+        function createSpiralSurface(radius1 = 2.0, radius2 = 2.0, turns1 = 30, turns2 = 30) {
+            const positions = [];
+            const itheta = 2 * Math.PI / turns1;
+            const jtheta = 2 * Math.PI / turns2;
+
+            for (let i = 0; i < turns1; i++) {
+                for (let j = 0; j < turns2; j++) {
+                    const x = radius1 * Math.cos(j * jtheta);
+                    const y = radius2 * Math.sin(i * itheta);
+                    const z = radius1 * Math.cos(i * itheta) + radius2 * Math.sin(j * jtheta);
+                    positions.push(x, y, z);
+                }
+            }
+
+            return positions;
+        }
+
+        function drawScene(gl, programInfo, buffers, deltaTime) {
+            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
+
+            const fieldOfView = 45 * Math.PI / 180;   // in radians
+            const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
+            const zNear = 0.1;
+            const zFar = 100.0;
+            const projectionMatrix = mat4.create();
+
+            mat4.perspective(projectionMatrix,
+                             fieldOfView,
+                             aspect,
+                             zNear,
+                             zFar);
+
+            const modelViewMatrix = mat4.create();
+
+            mat4.translate(modelViewMatrix,    // destination matrix
+                           modelViewMatrix,    // matrix to translate
+                           [0.0, 0.0, -10.0]); // amount to translate
+
+            // Apply rotations based on user input
+            mat4.rotate(modelViewMatrix,  // destination matrix
+                        modelViewMatrix,  // matrix to rotate
+                        rotationX,        // rotation around the X axis
+                        [1, 0, 0]);       // X axis
+            mat4.rotate(modelViewMatrix,  // destination matrix
+                        modelViewMatrix,  // matrix to rotate
+                        rotationY,        // rotation around the Y axis
+                        [0, 1, 0]);       // Y axis
+
+            // Tell WebGL how to pull out the positions from the position buffer into the vertexPosition attribute
+            {
+                const numComponents = 3;
+                const type = gl.FLOAT;
+                const normalize = false;
+                const stride = 0;
+                const offset = 0;
+                gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
+                gl.vertexAttribPointer(
+                    programInfo.attribLocations.vertexPosition,
+                    numComponents,
+                    type,
+                    normalize,
+                    stride,
+                    offset);
+                gl.enableVertexAttribArray(
+                    programInfo.attribLocations.vertexPosition);
+            }
+
+            // Tell WebGL to use our program when drawing
+            gl.useProgram(programInfo.program);
+
+            // Set the shader uniforms
+            gl.uniformMatrix4fv(
+                programInfo.uniformLocations.projectionMatrix,
+                false,
+                projectionMatrix);
+            gl.uniformMatrix4fv(
+                programInfo.uniformLocations.modelViewMatrix,
+                false,
+                modelViewMatrix);
+
+            {
+                const offset = 0;
+                gl.drawArrays(gl.LINE_STRIP, offset, buffers.vertexCount);
+            }
+        }
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/triple_motion.html b/rubbish/triple_motion.html
new file mode 100644
index 0000000..94ba80f
--- /dev/null
+++ b/rubbish/triple_motion.html
@@ -0,0 +1,71 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Dynamic Complex Line Drawing</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #333;
+        }
+        canvas {
+            border: 1px solid black;
+            background-color: #333;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="complexLineCanvas" width="600" height="600"></canvas>
+    <script>
+        const canvas = document.getElementById('complexLineCanvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const numLines = 360;
+
+        let angleMultiplier1 = 2;
+        let angleMultiplier2 = 4;
+        let radius1 = 100;
+        let radius2 = 400;
+        let angleOffset = 0;
+
+        // Function to draw the complex pattern
+        function drawComplexPattern() {
+            ctx.clearRect(0, 0, canvas.width, canvas.height);
+            ctx.strokeStyle = '#ffffff';
+            ctx.lineWidth = 0.5;
+
+            for (let i = 0; i < numLines; i++) {
+                const angle1 = (i / numLines) * 2 * Math.PI;
+                const angle2 = ((i + 180) / numLines) * 2 * Math.PI;
+                const x1 = centerX + radius1 * Math.cos(angleMultiplier1 * (angle1 + angleOffset)) * Math.sin(angle2 + angleOffset);
+                const y1 = centerY + radius1 * Math.sin(angleMultiplier2 * (angle1 + angleOffset)) * Math.sin(angle2 + angleOffset);
+                const x2 = centerX + radius2 * Math.cos(angle2 + angleOffset) * Math.sin(angle1 + angleOffset);
+                const y2 = centerY + radius2 * Math.sin(angle2 + angleOffset) * Math.sin(angle1 + angleOffset);
+
+                ctx.beginPath();
+                ctx.moveTo(x1, y1);
+                ctx.lineTo(x2, y2);
+                ctx.stroke();
+            }
+
+            // Update parameters to create animation
+            angleOffset += 0.01;
+            angleMultiplier1 = 2 + Math.sin(angleOffset) * 2;
+            angleMultiplier2 = 4 + Math.cos(angleOffset) * 2;
+            radius1 = 100 + Math.sin(3*angleOffset) * 50;
+            radius2 = 400 + Math.cos(angleOffset) * 50;
+
+            requestAnimationFrame(drawComplexPattern);
+        }
+
+        drawComplexPattern();
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/try.html b/rubbish/try.html
new file mode 100644
index 0000000..483a050
--- /dev/null
+++ b/rubbish/try.html
@@ -0,0 +1,83 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Enneper Surface Visualization</title>
+    <style>
+        body { margin: 0; }
+        canvas { display: block; }
+    </style>
+</head>
+<body>
+    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
+
+    <script>
+        function enneperSurface(u, v, n) {
+            const x = u - Math.pow(u, 2*n+1) / (2*n+1) + u * v * v;
+            const y = -v + Math.pow(v, 2*n+1) / (2*n+1) + v * u * u;
+            const z = u * u - v * v;
+            return { x, y, z };
+        }
+
+        function createSurfaceGeometry(n, resolution = 50) {
+            const geometry = new THREE.BufferGeometry();
+            const vertices = [];
+
+            for (let i = 0; i < resolution; i++) {
+                for (let j = 0; j < resolution; j++) {
+                    const u = (i / resolution) * 4 - 2;  // Map i to range [-2, 2]
+                    const v = (j / resolution) * 4 - 2;  // Map j to range [-2, 2]
+                    const point = enneperSurface(u, v, n);
+                    vertices.push(point.x, point.y, point.z);
+                }
+            }
+
+            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
+            return geometry;
+        }
+
+        function createScene() {
+            const scene = new THREE.Scene();
+            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
+            const renderer = new THREE.WebGLRenderer({ antialias: true });
+            renderer.setSize(window.innerWidth, window.innerHeight);
+            document.body.appendChild(renderer.domElement);
+
+            const light = new THREE.DirectionalLight(0xffffff, 1);
+            light.position.set(5, 5, 5).normalize();
+            scene.add(light);
+
+            const material = new THREE.MeshPhongMaterial({ color: 0x00cccc, side: THREE.DoubleSide, wireframe: false, transparent: true, opacity: 0.6 });
+
+            const surfaces = [];
+            const nValues = [1, 2, 3, 4];
+
+            nValues.forEach((n) => {
+                const geometry = createSurfaceGeometry(n);
+                const surface = new THREE.Mesh(geometry, material);
+                surfaces.push(surface);
+                scene.add(surface);
+            });
+
+            camera.position.z = 5;
+
+            function animate() {
+                requestAnimationFrame(animate);
+
+                surfaces.forEach((surface, index) => {
+                    surface.rotation.x += 0.01;
+                    surface.rotation.y += 0.01;
+                });
+
+                renderer.render(scene, camera);
+            }
+
+            animate();
+        }
+
+        createScene();
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/try5.html b/rubbish/try5.html
new file mode 100644
index 0000000..7c231d9
--- /dev/null
+++ b/rubbish/try5.html
@@ -0,0 +1,219 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Interactive 3D Ellipsoid - WebGL</title>
+    <style>
+        body, html { margin: 0; padding: 0; overflow: hidden; background-color: black; }
+        canvas { display: block; cursor: pointer; }
+    </style>
+</head>
+<body>
+    <canvas id="glCanvas"></canvas>
+
+    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
+    <script>
+        let canvas = document.getElementById('glCanvas');
+        let gl = canvas.getContext('webgl');
+
+        if (!gl) {
+            alert('WebGL not supported, falling back on experimental-webgl');
+            gl = canvas.getContext('experimental-webgl');
+        }
+
+        if (!gl) {
+            alert('Your browser does not support WebGL');
+        }
+
+        function resizeCanvas() {
+            canvas.width = window.innerWidth;
+            canvas.height = window.innerHeight;
+            gl.viewport(0, 0, canvas.width, canvas.height);
+        }
+
+        window.addEventListener('resize', resizeCanvas);
+        resizeCanvas();
+
+        let xrot = 0.2;
+        let yrot = 0.0;
+        let zrot = 0.0;
+
+        let xdiff = 0.0;
+        let ydiff = 0.0;
+        let mouseDown = false;
+
+        // Event listeners for mouse interactions
+        canvas.addEventListener('mousedown', (event) => {
+            mouseDown = true;
+            xdiff = event.clientX - yrot;
+            ydiff = event.clientY + xrot;
+        });
+
+        canvas.addEventListener('mousemove', (event) => {
+            if (mouseDown) {
+                yrot = event.clientX - xdiff;
+                xrot = event.clientY + ydiff;
+            }
+        });
+
+        canvas.addEventListener('mouseup', () => {
+            mouseDown = false;
+        });
+
+        canvas.addEventListener('mouseleave', () => {
+            mouseDown = false;
+        });
+
+        // Vertex shader program
+        const vsSource = `
+            attribute vec4 aVertexPosition;
+            uniform mat4 uModelViewMatrix;
+            uniform mat4 uProjectionMatrix;
+            void main(void) {
+                gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
+            }
+        `;
+
+        // Fragment shader program
+        const fsSource = `
+            void main(void) {
+                gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
+            }
+        `;
+
+        const shaderProgram = initShaderProgram(gl, vsSource, fsSource);
+
+        const programInfo = {
+            program: shaderProgram,
+            attribLocations: {
+                vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
+            },
+            uniformLocations: {
+                projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
+                modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
+            },
+        };
+
+        const buffers = initBuffers(gl);
+
+        function render() {
+            drawScene(gl, programInfo, buffers);
+            requestAnimationFrame(render);
+        }
+        requestAnimationFrame(render);
+
+        function initShaderProgram(gl, vsSource, fsSource) {
+            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
+            const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
+
+            const shaderProgram = gl.createProgram();
+            gl.attachShader(shaderProgram, vertexShader);
+            gl.attachShader(shaderProgram, fragmentShader);
+            gl.linkProgram(shaderProgram);
+
+            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
+                alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
+                return null;
+            }
+
+            return shaderProgram;
+        }
+
+        function loadShader(gl, type, source) {
+            const shader = gl.createShader(type);
+            gl.shaderSource(shader, source);
+            gl.compileShader(shader);
+
+            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
+                alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
+                gl.deleteShader(shader);
+                return null;
+            }
+
+            return shader;
+        }
+
+        function initBuffers(gl) {
+            const positionBuffer = gl.createBuffer();
+            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
+
+            const positions = createEllipsoid(12, 40, 1.1, 2.1, 5.1);
+
+            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
+
+            return {
+                position: positionBuffer,
+                vertexCount: positions.length / 3
+            };
+        }
+
+        function createEllipsoid(uistacks, uislices, fA, fB, fC) {
+            const positions = [];
+            const tstep = Math.PI / uislices;
+            const sstep = Math.PI / uistacks;
+
+            for (let i = 0; i < 2 * uislices; i++) {
+                const t = tstep * i;
+                for (let j = 0; j <= 2 * uistacks; j++) {
+                    const s = sstep * j;
+
+                    const x1 = fA * Math.sin(t * 3) * Math.cos(t) * Math.cos(s);
+                    const y1 = fB * Math.sin(t / 2) * Math.cos(t) * Math.sin(s);
+                    const z1 = fC * Math.sin(t / 2) * Math.sin(t);
+
+                    const x2 = fA * Math.sin((t + tstep) * 3) * Math.cos(t + tstep) * Math.cos(s);
+                    const y2 = fB * Math.sin((t + tstep) / 2) * Math.cos(t + tstep) * Math.sin(s);
+                    const z2 = fC * Math.sin((t + tstep) / 2) * Math.sin(t + tstep);
+
+                    positions.push(x1, y1, z1, x2, y2, z2);
+                }
+            }
+
+            return positions;
+        }
+
+        function drawScene(gl, programInfo, buffers) {
+            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
+
+            const fieldOfView = 45 * Math.PI / 180;
+            const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
+            const zNear = 0.1;
+            const zFar = 100.0;
+            const projectionMatrix = mat4.create();
+
+            mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);
+
+            const modelViewMatrix = mat4.create();
+
+            mat4.translate(modelViewMatrix, modelViewMatrix, [0.0, 0.0, -10.0]);
+
+            mat4.rotate(modelViewMatrix, modelViewMatrix, xrot, [1, 0, 0]);
+            mat4.rotate(modelViewMatrix, modelViewMatrix, yrot, [0, 1, 0]);
+            mat4.rotate(modelViewMatrix, modelViewMatrix, zrot, [0, 0, 1]);
+
+            {
+                const numComponents = 3;
+                const type = gl.FLOAT;
+                const normalize = false;
+                const stride = 0;
+                const offset = 0;
+                gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
+                gl.vertexAttribPointer(programInfo.attribLocations.vertexPosition, numComponents, type, normalize, stride, offset);
+                gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);
+            }
+
+            gl.useProgram(programInfo.program);
+
+            gl.uniformMatrix4fv(programInfo.uniformLocations.projectionMatrix, false, projectionMatrix);
+            gl.uniformMatrix4fv(programInfo.uniformLocations.modelViewMatrix, false, modelViewMatrix);
+
+            {
+                const offset = 0;
+                gl.drawArrays(gl.LINE_STRIP, offset, buffers.vertexCount);
+            }
+        }
+    </script>
+</body>
+</html>
+
diff --git a/rubbish/two_ellipse.html b/rubbish/two_ellipse.html
new file mode 100644
index 0000000..bc65fed
--- /dev/null
+++ b/rubbish/two_ellipse.html
@@ -0,0 +1,28 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Two Ellipse Lines Animation</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            background-color: white;
+            border: 1px solid #ccc;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="animationCanvas" width="600" height="600"></canvas>
+    <script src="two_ellipse.js"></script>
+</body>
+</html>
+
diff --git a/rubbish/two_petal.html b/rubbish/two_petal.html
new file mode 100644
index 0000000..f3a75f8
--- /dev/null
+++ b/rubbish/two_petal.html
@@ -0,0 +1,28 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Two-Petal Shape Animation</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            background-color: white;
+            border: 1px solid #ccc;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="animationCanvas" width="600" height="600"></canvas>
+    <script src="two_petal.js"></script>
+</body>
+</html>
+
diff --git a/rubbish/webgl.html b/rubbish/webgl.html
new file mode 100644
index 0000000..33572f4
--- /dev/null
+++ b/rubbish/webgl.html
@@ -0,0 +1,18 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>WebGL Example</title>
+    <style>
+        body { margin: 0; }
+        canvas { display: block; width: 100vw; height: 100vh; }
+    </style>
+</head>
+<body>
+    <canvas id="glCanvas"></canvas>
+    <script src="main.js"></script>
+</body>
+</html>
+
diff --git a/rubbish/webgl_3dcube.html b/rubbish/webgl_3dcube.html
new file mode 100644
index 0000000..9f6f63e
--- /dev/null
+++ b/rubbish/webgl_3dcube.html
@@ -0,0 +1,344 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+  <meta charset="UTF-8">
+  <meta name="viewport" content="width=device-width, initial-scale=1.0">
+  <title>3D Rotating Cube with WebGL</title>
+  <style>
+    body {
+      margin: 0;
+      display: flex;
+      justify-content: center;
+      align-items: center;
+      height: 100vh;
+      background-color: #f0f0f0;
+    }
+    canvas {
+      border: 1px solid #000;
+    }
+  </style>
+</head>
+<body>
+  <canvas id="glCanvas" width="640" height="480"></canvas>
+  <script>
+    // Add the JavaScript code here
+
+const canvas = document.getElementById('glCanvas');
+const gl = canvas.getContext('webgl');
+
+if (!gl) {
+  console.log('WebGL not supported, falling back on experimental-webgl');
+  gl = canvas.getContext('experimental-webgl');
+}
+
+if (!gl) {
+  alert('Your browser does not support WebGL');
+}
+
+// Vertex shader program
+const vsSource = `
+  attribute vec4 aVertexPosition;
+  attribute vec4 aVertexColor;
+  uniform mat4 uModelViewMatrix;
+  uniform mat4 uProjectionMatrix;
+  varying lowp vec4 vColor;
+  void main(void) {
+    gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
+    vColor = aVertexColor;
+  }
+`;
+
+// Fragment shader program
+const fsSource = `
+  varying lowp vec4 vColor;
+  void main(void) {
+    gl_FragColor = vColor;
+  }
+`;
+
+// Initialize a shader program; this is where all the lighting for the vertices and so forth is established.
+const shaderProgram = initShaderProgram(gl, vsSource, fsSource);
+
+// Collect all the info needed to use the shader program.
+const programInfo = {
+  program: shaderProgram,
+  attribLocations: {
+    vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
+    vertexColor: gl.getAttribLocation(shaderProgram, 'aVertexColor'),
+  },
+  uniformLocations: {
+    projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
+    modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
+  },
+};
+
+// Here's where we call the routine that builds all the objects we'll be drawing.
+const buffers = initBuffers(gl);
+
+let then = 0;
+
+// Draw the scene repeatedly
+function render(now) {
+  now *= 0.001;  // convert to seconds
+  const deltaTime = now - then;
+  then = now;
+
+  drawScene(gl, programInfo, buffers, deltaTime);
+
+  requestAnimationFrame(render);
+}
+requestAnimationFrame(render);
+
+// Initialize the buffers we'll need. For this demo, we just have one object -- a simple three-dimensional cube.
+function initBuffers(gl) {
+
+  // Create a buffer for the cube's vertex positions.
+  const positionBuffer = gl.createBuffer();
+
+  // Select the positionBuffer as the one to apply buffer operations to from here out.
+  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
+
+  // Now create an array of positions for the cube.
+  const positions = [
+     // Front face
+     -1.0, -1.0,  1.0,
+      1.0, -1.0,  1.0,
+      1.0,  1.0,  1.0,
+     -1.0,  1.0,  1.0,
+
+     // Back face
+     -1.0, -1.0, -1.0,
+     -1.0,  1.0, -1.0,
+      1.0,  1.0, -1.0,
+      1.0, -1.0, -1.0,
+
+     // Top face
+     -1.0,  1.0, -1.0,
+     -1.0,  1.0,  1.0,
+      1.0,  1.0,  1.0,
+      1.0,  1.0, -1.0,
+
+     // Bottom face
+     -1.0, -1.0, -1.0,
+      1.0, -1.0, -1.0,
+      1.0, -1.0,  1.0,
+     -1.0, -1.0,  1.0,
+
+     // Right face
+      1.0, -1.0, -1.0,
+      1.0,  1.0, -1.0,
+      1.0,  1.0,  1.0,
+      1.0, -1.0,  1.0,
+
+     // Left face
+     -1.0, -1.0, -1.0,
+     -1.0, -1.0,  1.0,
+     -1.0,  1.0,  1.0,
+     -1.0,  1.0, -1.0,
+  ];
+
+  // Now pass the list of positions into WebGL to build the shape. We do this by creating a Float32Array from the JavaScript array, then use it to fill the current buffer.
+  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
+
+  // Now set up the colors for the faces. We'll use solid colors for each face.
+  const faceColors = [
+    [1.0,  1.0,  1.0,  1.0],    // Front face: white
+    [1.0,  0.0,  0.0,  1.0],    // Back face: red
+    [0.0,  1.0,  0.0,  1.0],    // Top face: green
+    [0.0,  0.0,  1.0,  1.0],    // Bottom face: blue
+    [1.0,  1.0,  0.0,  1.0],    // Right face: yellow
+    [1.0,  0.0,  1.0,  1.0],    // Left face: purple
+  ];
+
+  // Convert the array of colors into a table for all the vertices.
+  var colors = [];
+
+  for (var j = 0; j < faceColors.length; ++j) {
+    const c = faceColors[j];
+
+    // Repeat each color four times for the four vertices of the face
+    colors = colors.concat(c, c, c, c);
+  }
+
+  const colorBuffer = gl.createBuffer();
+  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
+  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
+
+  // Build the element array buffer; this specifies the indices into the vertex arrays for each face's vertices.
+  const indexBuffer = gl.createBuffer();
+  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
+
+  // This array defines each face as two triangles, using the indices into the vertex array to specify each triangle's position.
+  const indices = [
+    0,  1,  2,      0,  2,  3,    // front
+    4,  5,  6,      4,  6,  7,    // back
+    8,  9,  10,     8,  10, 11,   // top
+    12, 13, 14,     12, 14, 15,   // bottom
+    16, 17, 18,     16, 18, 19,   // right
+    20, 21, 22,     20, 22, 23,   // left
+  ];
+
+  // Now send the element array to GL
+  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
+
+  return {
+    position: positionBuffer,
+    color: colorBuffer,
+    indices: indexBuffer,
+  };
+}
+
+// Draw the scene.
+function drawScene(gl, programInfo, buffers, deltaTime) {
+  gl.clearColor(0.0, 0.0, 0.0, 1.0);  // Clear to black, fully opaque
+  gl.clearDepth(1.0);                 // Clear everything
+  gl.enable(gl.DEPTH_TEST);           // Enable depth testing
+  gl.depthFunc(gl.LEQUAL);            // Near things obscure far things
+
+  // Clear the canvas before we start drawing on it.
+  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
+
+  // Create a perspective matrix, a special matrix that is used to simulate the distortion of perspective in a camera. Our field of view is 45 degrees, with a width/height ratio that matches the display size of the canvas and we only want to see objects between 0.1 units and 100 units away from the camera.
+  const fieldOfView = 45 * Math.PI / 180;   // in radians
+  const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
+  const zNear = 0.1;
+  const zFar = 100.0;
+  const projectionMatrix = mat4.create();
+
+  mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);
+
+  // Set the drawing position to the "identity" point, which is the center of the scene.
+  const modelViewMatrix = mat4.create();
+
+  // Now move the drawing position a bit to where we want to start drawing the square.
+  mat4.translate(modelViewMatrix,     // destination matrix
+                 modelViewMatrix,     // matrix to translate
+                 [-0.0, 0.0, -6.0]);  // amount to translate
+
+  mat4.rotate(modelViewMatrix,  // destination matrix
+              modelViewMatrix,  // matrix to rotate
+              cubeRotation,     // amount to rotate in radians
+              [0, 0, 1]);       // axis to rotate around (Z)
+
+  mat4.rotate(modelViewMatrix,  // destination matrix
+              modelViewMatrix,  // matrix to rotate
+              cubeRotation * .7,// amount to rotate in radians
+              [0, 1, 0]);       // axis to rotate around (Y)
+
+  mat4.rotate(modelViewMatrix,  // destination matrix
+              modelViewMatrix,  // matrix to rotate
+              cubeRotation * .3,// amount to rotate in radians
+              [1, 0, 0]);       // axis to rotate around (X)
+
+  // Tell WebGL how to pull out the positions from the position buffer into the vertexPosition attribute.
+  {
+    const numComponents = 3;
+    const type = gl.FLOAT;
+    const normalize = false;
+    const stride = 0;
+    const offset = 0;
+    gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
+    gl.vertexAttribPointer(
+        programInfo.attribLocations.vertexPosition,
+        numComponents,
+        type,
+        normalize,
+        stride,
+        offset);
+    gl.enableVertexAttribArray(
+        programInfo.attribLocations.vertexPosition);
+  }
+
+  // Tell WebGL how to pull out the colors from the color buffer into the vertexColor attribute.
+  {
+    const numComponents = 4;
+    const type = gl.FLOAT;
+    const normalize = false;
+    const stride = 0;
+    const offset = 0;
+    gl.bindBuffer(gl.ARRAY_BUFFER, buffers.color);
+    gl.vertexAttribPointer(
+        programInfo.attribLocations.vertexColor,
+        numComponents,
+        type,
+        normalize,
+        stride,
+        offset);
+    gl.enableVertexAttribArray(
+        programInfo.attribLocations.vertexColor);
+  }
+
+  // Tell WebGL which indices to use to index the vertices
+  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);
+
+  // Tell WebGL to use our program when drawing
+  gl.useProgram(programInfo.program);
+
+  // Set the shader uniforms
+  gl.uniformMatrix4fv(
+      programInfo.uniformLocations.projectionMatrix,
+      false,
+      projectionMatrix);
+  gl.uniformMatrix4fv(
+      programInfo.uniformLocations.modelViewMatrix,
+      false,
+      modelViewMatrix);
+
+  {
+    const vertexCount = 36;
+    const type = gl.UNSIGNED_SHORT;
+    const offset = 0;
+    gl.drawElements(gl.TRIANGLES, vertexCount, type, offset);
+  }
+
+  // Update the rotation for the next draw
+  cubeRotation += deltaTime;
+}
+
+// Initialize a shader program, so WebGL knows how to draw our data
+function initShaderProgram(gl, vsSource, fsSource) {
+  const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
+  const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
+
+  // Create the shader program
+  const shaderProgram = gl.createProgram();
+  gl.attachShader(shaderProgram, vertexShader);
+  gl.attachShader(shaderProgram, fragmentShader);
+  gl.linkProgram(shaderProgram);
+
+  // If creating the shader program failed, alert
+  if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
+    alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
+    return null;
+  }
+
+  return shaderProgram;
+}
+
+// creates a shader of the given type, uploads the source and compiles it.
+function loadShader(gl, type, source) {
+  const shader = gl.createShader(type);
+
+  // Send the source to the shader object
+  gl.shaderSource(shader, source);
+
+  // Compile the shader program
+  gl.compileShader(shader);
+
+  // See if it compiled successfully
+  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
+    alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
+    gl.deleteShader(shader);
+    return null;
+  }
+
+  return shader;
+}
+
+var cubeRotation = 0.0;
+
+
+  </script>
+</body>
+</html>
+
diff --git a/script.js b/script.js
deleted file mode 100644
index d0051e0..0000000
--- a/script.js
+++ /dev/null
@@ -1,86 +0,0 @@
-const canvas = document.getElementById('myCanvas');
-const ctx = canvas.getContext('2d');
-
-// Dodecahedron vertices
-const vertices = [
-    [1, 1, 1],
-    [-1, -1, 1],
-    [-1, 1, -1],
-    [1, -1, -1],
-    [1, 1, -1],
-    [-1, -1, -1],
-    [-1, 1, 1],
-    [1, -1, 1],
-    [0, 1.618, 0],
-    [0, -1.618, 0],
-    [1.618, 0, 0],
-    [-1.618, 0, 0]
-];
-
-// Dodecahedron edges
-const edges = [
-    [0, 1], [0, 2], [0, 3], [0, 4], [1, 5], [1, 6], [2, 7],
-    [2, 8], [3, 9], [3, 10], [4, 11], [4, 8], [5, 9], [5, 10],
-    [6, 11], [6, 8], [7, 9], [7, 10], [8, 11]
-];
-
-// Projection matrix (orthographic)
-const projectionMatrix = [
-    1, 0, 0, 0,
-    0, 1, 0, 0,
-    0, 0, 1, 0,
-    0, 0, 0, 1
-];
-
-// Rotation matrix (initially identity)
-let rotationMatrix = [
-    1, 0, 0, 0,
-    0, 1, 0, 0,
-    0, 0, 1, 0,
-    0, 0, 0, 1
-];
-
-function rotate(angle, axis) {
-    // Implementation of rotation matrix based on axis and angle
-    // ...
-}
-
-function project(vertex) {
-    // Implementation of projection matrix multiplication
-    // ...
-}
-
-function drawDodecahedron() {
-    ctx.clearRect(0, 0, canvas.width, canvas.height);
-
-    // Apply rotation
-    rotationMatrix = rotate(0.01, [1, 0, 0]); // Example: Rotate around x-axis
-
-    for (let i = 0; i < edges.length; i++) {
-        const vertex1 = vertices[edges[i][0]];
-        const vertex2 = vertices[edges[i][1]];
-
-        // Project vertices
-        const projectedVertex1 = project(vertex1);
-        const projectedVertex2 = project(vertex2);
-
-        // Scale and translate to fit canvas
-        projectedVertex1[0] = (projectedVertex1[0] + 1) * canvas.width / 2;
-        projectedVertex1[1] = (projectedVertex1[1] + 1) * canvas.height / 2;
-        projectedVertex2[0] = (projectedVertex2[0] + 1) * canvas.width / 2;
-        projectedVertex2[1] = (projectedVertex2[1] + 1) * canvas.height / 2;
-
-        // Draw line
-        ctx.beginPath();
-        ctx.moveTo(projectedVertex1[0], projectedVertex1[1]);
-        ctx.lineTo(projectedVertex2[0], projectedVertex2[1]);
-        ctx.stroke();
-    }
-}
-
-function animate() {
-    drawDodecahedron();
-    requestAnimationFrame(animate);
-}
-
-animate();
diff --git a/triangle.html b/triangle.html
new file mode 100644
index 0000000..e4bb1de
--- /dev/null
+++ b/triangle.html
@@ -0,0 +1,110 @@
+
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Rotating Triangles</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+        #controls {
+            position: absolute;
+            top: 20px;
+            left: 20px;
+        }
+    </style>
+</head>
+<body onload="drawShape()">
+    <div id="controls">
+        <label for="radiusX">Radius X: </label>
+        <input type="number" id="radiusX" value="100">
+        <label for="radiusY">Radius Y: </label>
+        <input type="number" id="radiusY" value="50">
+        <button onclick="drawShape()">Draw Triangle</button>
+    </div>
+    <canvas id="canvas" width="800" height="600"></canvas>
+    
+    <script>
+        const canvas = document.getElementById('canvas');
+        const context = canvas.getContext('2d');
+        let shapes = [];
+
+        canvas.addEventListener('click', (event) => {
+            const rect = canvas.getBoundingClientRect();
+            const x = event.clientX - rect.left;
+            const y = event.clientY - rect.top;
+            const radiusX = parseInt(document.getElementById('radiusX').value, 10);
+            const radiusY = parseInt(document.getElementById('radiusY').value, 10);
+            shapes.push({x: x, y: y, radiusX: radiusX, radiusY: radiusY, angle: 0});
+            drawTriangleAtPosition(x, y, radiusX, radiusY);
+        });
+
+        function drawTriangleAtPosition(x, y, radiusX, radiusY) {
+            context.beginPath();
+            context.moveTo(x, y - radiusY); // Top vertex
+            context.lineTo(x - radiusX, y + radiusY); // Bottom left vertex
+            context.lineTo(x + radiusX, y + radiusY); // Bottom right vertex
+            context.closePath(); // Complete the triangle
+            context.fillStyle = getRandomColor();
+            context.fill();
+            context.stroke();
+        }
+
+        function drawShape() {
+            const radiusX = parseInt(document.getElementById('radiusX').value, 10);
+            const radiusY = parseInt(document.getElementById('radiusY').value, 10);
+            const x = canvas.width / 2;
+            const y = canvas.height / 2;
+            shapes.push({x: x, y: y, radiusX: radiusX, radiusY: radiusY, angle: 0});
+            drawTriangleAtPosition(x, y, radiusX, radiusY);
+        }
+
+        function animateShapes() {
+            shapes.forEach(shape => {
+                context.save();
+                context.translate(shape.x, shape.y);
+                context.rotate(shape.angle);
+                context.beginPath();
+                context.moveTo(0, -shape.radiusY); // Top vertex
+                context.lineTo(-shape.radiusX, shape.radiusY); // Bottom left vertex
+                context.lineTo(shape.radiusX, shape.radiusY); // Bottom right vertex
+                context.closePath();
+                context.fillStyle = getRandomColor();
+                context.fill();
+                context.stroke();
+                context.restore();
+                shape.angle += 0.2;
+            });
+            requestAnimationFrame(animateShapes);
+        }
+
+        function getRandomColor() {
+          const colors = [
+            "blue", "green", "red", "yellow", "purple", "orange", "pink", "brown",
+            "black", "white", "gray", "cyan", "magenta", "lime", "indigo", "violet",
+            "gold", "silver", "beige", "maroon", "olive", "navy", "teal"
+          ];
+        
+          // Generate a random index to pick a color
+          const randomIndex = Math.floor(Math.random() * colors.length);
+        
+          // Return the randomly selected color
+          return colors[randomIndex];
+        }
+        
+        animateShapes();
+    </script>
+</body>
+</html>
+
diff --git a/wavy.js b/wavy.js
new file mode 100644
index 0000000..9f7aaa5
--- /dev/null
+++ b/wavy.js
@@ -0,0 +1,63 @@
+
+const canvas = document.getElementById('waveCanvas');
+const ctx = canvas.getContext('2d');
+canvas.width = window.innerWidth;
+canvas.height = window.innerHeight;
+
+const waveCount = 3;  // Number of wave layers
+const pointsPerWave = 150;
+const waves = [];
+
+for (let j = 0; j < waveCount; j++) {
+    const points = [];
+    const waveHeight = 100 + Math.random() * 50;
+    const waveSpeed = 0.01 + Math.random() * 0.02;
+
+    for (let i = 0; i < pointsPerWave; i++) {
+        points.push({
+            x: (i / (pointsPerWave - 1)) * canvas.width,
+            y: canvas.height / 2,
+            baseY: canvas.height / 2,
+            offset: Math.random() * 1000
+        });
+    }
+
+    waves.push({ points, waveHeight, waveSpeed });
+}
+
+function draw() {
+    ctx.clearRect(0, 0, canvas.width, canvas.height);
+
+    waves.forEach((wave, index) => {
+        ctx.beginPath();
+        ctx.moveTo(wave.points[0].x, wave.points[0].y);
+
+        for (let i = 1; i < wave.points.length; i++) {
+            const point = wave.points[i];
+            point.y = point.baseY + Math.sin((i + wave.waveSpeed * point.offset) * 0.05) * wave.waveHeight;
+            ctx.lineTo(point.x, point.y);
+        }
+
+        // Change color and transparency for each wave
+        ctx.strokeStyle = `rgba(255, 165, 0, ${0.3 / (index + 1)})`;  // Orangish color with decreasing opacity
+        ctx.lineWidth = 3;
+        ctx.stroke();
+    });
+
+    requestAnimationFrame(draw);
+}
+
+draw();
+
+window.addEventListener('resize', () => {
+    canvas.width = window.innerWidth;
+    canvas.height = window.innerHeight;
+
+    waves.forEach(wave => {
+        for (let i = 0; i < wave.points.length; i++) {
+            wave.points[i].x = (i / (pointsPerWave - 1)) * canvas.width;
+            wave.points[i].baseY = canvas.height / 2;
+        }
+    });
+});
+

commit 6d35cecc21ae7a6a314e52df924d7dd576b08dfb
Author: Peter Teoh <htmldeveloper@gmail.com>
Date:   Sun Sep 8 19:14:09 2024 +0800

    new file:   double_square.html
    new file:   double_square.js
    new file:   square_sphere.html
    new file:   square_sphere.js
    new file:   square_triangle.html
    new file:   square_triangle.js

diff --git a/double_square.html b/double_square.html
new file mode 100644
index 0000000..e09acd2
--- /dev/null
+++ b/double_square.html
@@ -0,0 +1,28 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Triangle Animation</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            background-color: white;
+            border: 1px solid #ccc;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="animationCanvas" width="600" height="600"></canvas>
+    <script src="double_square.js"></script>
+</body>
+</html>
+
diff --git a/double_square.js b/double_square.js
new file mode 100644
index 0000000..9b536c3
--- /dev/null
+++ b/double_square.js
@@ -0,0 +1,92 @@
+const canvas = document.getElementById('animationCanvas');
+const ctx = canvas.getContext('2d');
+const numDots = 100; // Number of points along each square
+const largeSideLength = 400; // Side length of the larger square
+const smallSideLength = 100; // Side length of the smaller square
+const centerX = canvas.width / 2; // Fixed center X
+const centerY = canvas.height / 2; // Fixed center Y
+let rotationAngleLarge = 0;
+let rotationAngleSmall = 0;
+
+// Function to generate points along the edge of a square
+function getSquarePoints(centerX, centerY, sideLength, rotationAngle, numDots) {
+    const points = [];
+    const halfSide = sideLength / 2;
+    const rotationRadians = rotationAngle * Math.PI / 180; // Convert degrees to radians
+
+    // Square vertices (top-left, top-right, bottom-right, bottom-left)
+    const vertices = [
+        { x: centerX - halfSide, y: centerY - halfSide }, // Top-left
+        { x: centerX + halfSide, y: centerY - halfSide }, // Top-right
+        { x: centerX + halfSide, y: centerY + halfSide }, // Bottom-right
+        { x: centerX - halfSide, y: centerY + halfSide }  // Bottom-left
+    ];
+
+    // Divide square perimeter into numDots
+    for (let i = 0; i < numDots; i++) {
+        const t = i / numDots;
+        let x, y;
+        if (t < 1 / 4) {
+            // First edge (top-left to top-right)
+            const tEdge = t * 4;
+            x = (1 - tEdge) * vertices[0].x + tEdge * vertices[1].x;
+            y = (1 - tEdge) * vertices[0].y + tEdge * vertices[1].y;
+        } else if (t < 2 / 4) {
+            // Second edge (top-right to bottom-right)
+            const tEdge = (t - 1 / 4) * 4;
+            x = (1 - tEdge) * vertices[1].x + tEdge * vertices[2].x;
+            y = (1 - tEdge) * vertices[1].y + tEdge * vertices[2].y;
+        } else if (t < 3 / 4) {
+            // Third edge (bottom-right to bottom-left)
+            const tEdge = (t - 2 / 4) * 4;
+            x = (1 - tEdge) * vertices[2].x + tEdge * vertices[3].x;
+            y = (1 - tEdge) * vertices[2].y + tEdge * vertices[3].y;
+        } else {
+            // Fourth edge (bottom-left to top-left)
+            const tEdge = (t - 3 / 4) * 4;
+            x = (1 - tEdge) * vertices[3].x + tEdge * vertices[0].x;
+            y = (1 - tEdge) * vertices[3].y + tEdge * vertices[0].y;
+        }
+
+        // Apply rotation
+        const rotatedX = centerX + (x - centerX) * Math.cos(rotationRadians) - (y - centerY) * Math.sin(rotationRadians);
+        const rotatedY = centerY + (x - centerX) * Math.sin(rotationRadians) + (y - centerY) * Math.cos(rotationRadians);
+
+        points.push({ x: rotatedX, y: rotatedY });
+    }
+
+    return points;
+}
+
+// Function to draw lines between points of two squares
+function drawLines(points1, points2) {
+    ctx.strokeStyle = 'blue';
+    for (let i = 0; i < points1.length; i++) {
+        ctx.beginPath();
+        ctx.moveTo(points1[i].x, points1[i].y);
+        ctx.lineTo(points2[i].x, points2[i].y);
+        ctx.stroke();
+    }
+}
+
+// Function to animate the squares
+function animate() {
+    ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
+
+    // Get points for both squares
+    const largeSquarePoints = getSquarePoints(centerX, centerY, largeSideLength, rotationAngleLarge, numDots);
+    const smallSquarePoints = getSquarePoints(centerX, centerY, smallSideLength, rotationAngleSmall, numDots);
+
+    // Draw lines between corresponding points
+    drawLines(largeSquarePoints, smallSquarePoints);
+
+    // Update rotation angles
+    rotationAngleLarge = (rotationAngleLarge + 2) % 360; // Rotate counterclockwise
+    rotationAngleSmall = (rotationAngleSmall - 2) % 360; // Rotate clockwise
+
+    requestAnimationFrame(animate); // Continue the animation
+}
+
+// Start the animation
+animate();
+
diff --git a/square_sphere.html b/square_sphere.html
new file mode 100644
index 0000000..1f8374e
--- /dev/null
+++ b/square_sphere.html
@@ -0,0 +1,28 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Triangle Animation</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            background-color: white;
+            border: 1px solid #ccc;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="animationCanvas" width="600" height="600"></canvas>
+    <script src="square_sphere.js"></script>
+</body>
+</html>
+
diff --git a/square_sphere.js b/square_sphere.js
new file mode 100644
index 0000000..c2093dd
--- /dev/null
+++ b/square_sphere.js
@@ -0,0 +1,113 @@
+const canvas = document.getElementById('animationCanvas');
+const ctx = canvas.getContext('2d');
+const numDots = 100; // Number of points along each shape
+const sphereRadius = 150; // Radius of the projected sphere (circle)
+const squareSideLength = 200; // Side length of the square
+const centerX = canvas.width / 2; // Fixed center X
+const centerY = canvas.height / 2; // Fixed center Y
+let rotationAngleSquare = 0;
+let rotationAngleSphere = 0;
+
+// Function to generate points along the edge of a sphere (2D projection of a 3D sphere)
+function getSpherePoints(centerX, centerY, radius, rotationAngle, numDots) {
+    const points = [];
+    const rotationRadians = rotationAngle * Math.PI / 180; // Convert degrees to radians
+
+    // Distribute points evenly around the circle (2D sphere projection)
+    for (let i = 0; i < numDots; i++) {
+        const theta = (2 * Math.PI * i) / numDots; // Angle for each point
+        const x = centerX + radius * Math.cos(theta);
+        const y = centerY + radius * Math.sin(theta);
+
+        // Apply rotation to the points (for visualization)
+        const rotatedX = centerX + (x - centerX) * Math.cos(rotationRadians) - (y - centerY) * Math.sin(rotationRadians);
+        const rotatedY = centerY + (x - centerX) * Math.sin(rotationRadians) + (y - centerY) * Math.cos(rotationRadians);
+
+        points.push({ x: rotatedX, y: rotatedY });
+    }
+
+    return points;
+}
+
+// Function to generate points along the edge of a square
+function getSquarePoints(centerX, centerY, sideLength, rotationAngle, numDots) {
+    const points = [];
+    const halfSide = sideLength / 2;
+    const rotationRadians = rotationAngle * Math.PI / 180; // Convert degrees to radians
+
+    // Square vertices (top-left, top-right, bottom-right, bottom-left)
+    const vertices = [
+        { x: centerX - halfSide, y: centerY - halfSide }, // Top-left
+        { x: centerX + halfSide, y: centerY - halfSide }, // Top-right
+        { x: centerX + halfSide, y: centerY + halfSide }, // Bottom-right
+        { x: centerX - halfSide, y: centerY + halfSide }  // Bottom-left
+    ];
+
+    // Divide square perimeter into numDots
+    for (let i = 0; i < numDots; i++) {
+        const t = i / numDots;
+        let x, y;
+        if (t < 1 / 4) {
+            // First edge (top-left to top-right)
+            const tEdge = t * 4;
+            x = (1 - tEdge) * vertices[0].x + tEdge * vertices[1].x;
+            y = (1 - tEdge) * vertices[0].y + tEdge * vertices[1].y;
+        } else if (t < 2 / 4) {
+            // Second edge (top-right to bottom-right)
+            const tEdge = (t - 1 / 4) * 4;
+            x = (1 - tEdge) * vertices[1].x + tEdge * vertices[2].x;
+            y = (1 - tEdge) * vertices[1].y + tEdge * vertices[2].y;
+        } else if (t < 3 / 4) {
+            // Third edge (bottom-right to bottom-left)
+            const tEdge = (t - 2 / 4) * 4;
+            x = (1 - tEdge) * vertices[2].x + tEdge * vertices[3].x;
+            y = (1 - tEdge) * vertices[2].y + tEdge * vertices[3].y;
+        } else {
+            // Fourth edge (bottom-left to top-left)
+            const tEdge = (t - 3 / 4) * 4;
+            x = (1 - tEdge) * vertices[3].x + tEdge * vertices[0].x;
+            y = (1 - tEdge) * vertices[3].y + tEdge * vertices[0].y;
+        }
+
+        // Apply rotation
+        const rotatedX = centerX + (x - centerX) * Math.cos(rotationRadians) - (y - centerY) * Math.sin(rotationRadians);
+        const rotatedY = centerY + (x - centerX) * Math.sin(rotationRadians) + (y - centerY) * Math.cos(rotationRadians);
+
+        points.push({ x: rotatedX, y: rotatedY });
+    }
+
+    return points;
+}
+
+// Function to draw lines between points of a sphere and a square
+function drawLines(points1, points2) {
+    ctx.strokeStyle = 'blue';
+    for (let i = 0; i < points1.length; i++) {
+        ctx.beginPath();
+        ctx.moveTo(points1[i].x, points1[i].y);
+        ctx.lineTo(points2[i].x, points2[i].y);
+        ctx.stroke();
+    }
+}
+
+// Function to animate the sphere and the square
+function animate() {
+    ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
+
+    // Get points for the sphere and the square
+    const spherePoints = getSpherePoints(centerX, centerY, sphereRadius, rotationAngleSphere, numDots);
+    const squarePoints = getSquarePoints(centerX, centerY, squareSideLength, rotationAngleSquare, numDots);
+
+    // Draw lines between corresponding points of the sphere and square
+    drawLines(spherePoints, squarePoints);
+
+    // Update rotation angles
+    rotationAngleSphere = (rotationAngleSphere + 2) % 360; // Rotate the sphere counterclockwise
+    rotationAngleSquare = (rotationAngleSquare - 2) % 360; // Rotate the square clockwise
+
+    requestAnimationFrame(animate); // Continue the animation
+}
+
+// Start the animation
+animate();
+
diff --git a/square_triangle.html b/square_triangle.html
new file mode 100644
index 0000000..8e05eca
--- /dev/null
+++ b/square_triangle.html
@@ -0,0 +1,28 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Triangle Animation</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            background-color: white;
+            border: 1px solid #ccc;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="animationCanvas" width="600" height="600"></canvas>
+    <script src="square_triangle.js"></script>
+</body>
+</html>
+
diff --git a/square_triangle.js b/square_triangle.js
new file mode 100644
index 0000000..9bf9391
--- /dev/null
+++ b/square_triangle.js
@@ -0,0 +1,135 @@
+const canvas = document.getElementById('animationCanvas');
+const ctx = canvas.getContext('2d');
+const numDots = 100; // Number of points along each shape
+const triangleSideLength = 450; // Side length of the triangle
+const squareSideLength = 200; // Side length of the square
+const centerX = canvas.width / 2; // Fixed center X
+const centerY = canvas.height / 2; // Fixed center Y
+let rotationAngleTriangle = 0;
+let rotationAngleSquare = 0;
+
+// Function to generate points along the edge of a triangle
+function getTrianglePoints(centerX, centerY, sideLength, rotationAngle, numDots) {
+    const points = [];
+    const rotationRadians = rotationAngle * Math.PI / 180; // Convert degrees to radians
+
+    // Triangle vertices (equilateral triangle)
+    const vertices = [
+        { x: centerX, y: centerY - sideLength / Math.sqrt(3) }, // Top vertex
+        { x: centerX - sideLength / 2, y: centerY + sideLength / (2 * Math.sqrt(3)) }, // Bottom left
+        { x: centerX + sideLength / 2, y: centerY + sideLength / (2 * Math.sqrt(3)) }  // Bottom right
+    ];
+
+    // Divide triangle perimeter into numDots
+    for (let i = 0; i < numDots; i++) {
+        const t = i / numDots;
+        let x, y;
+        if (t < 1 / 3) {
+            // First edge (vertex 0 to vertex 1)
+            const tEdge = t * 3;
+            x = (1 - tEdge) * vertices[0].x + tEdge * vertices[1].x;
+            y = (1 - tEdge) * vertices[0].y + tEdge * vertices[1].y;
+        } else if (t < 2 / 3) {
+            // Second edge (vertex 1 to vertex 2)
+            const tEdge = (t - 1 / 3) * 3;
+            x = (1 - tEdge) * vertices[1].x + tEdge * vertices[2].x;
+            y = (1 - tEdge) * vertices[1].y + tEdge * vertices[2].y;
+        } else {
+            // Third edge (vertex 2 to vertex 0)
+            const tEdge = (t - 2 / 3) * 3;
+            x = (1 - tEdge) * vertices[2].x + tEdge * vertices[0].x;
+            y = (1 - tEdge) * vertices[2].y + tEdge * vertices[0].y;
+        }
+
+        // Apply rotation
+        const rotatedX = centerX + (x - centerX) * Math.cos(rotationRadians) - (y - centerY) * Math.sin(rotationRadians);
+        const rotatedY = centerY + (x - centerX) * Math.sin(rotationRadians) + (y - centerY) * Math.cos(rotationRadians);
+
+        points.push({ x: rotatedX, y: rotatedY });
+    }
+
+    return points;
+}
+
+// Function to generate points along the edge of a square
+function getSquarePoints(centerX, centerY, sideLength, rotationAngle, numDots) {
+    const points = [];
+    const halfSide = sideLength / 2;
+    const rotationRadians = rotationAngle * Math.PI / 180; // Convert degrees to radians
+
+    // Square vertices (top-left, top-right, bottom-right, bottom-left)
+    const vertices = [
+        { x: centerX - halfSide, y: centerY - halfSide }, // Top-left
+        { x: centerX + halfSide, y: centerY - halfSide }, // Top-right
+        { x: centerX + halfSide, y: centerY + halfSide }, // Bottom-right
+        { x: centerX - halfSide, y: centerY + halfSide }  // Bottom-left
+    ];
+
+    // Divide square perimeter into numDots
+    for (let i = 0; i < numDots; i++) {
+        const t = i / numDots;
+        let x, y;
+        if (t < 1 / 4) {
+            // First edge (top-left to top-right)
+            const tEdge = t * 4;
+            x = (1 - tEdge) * vertices[0].x + tEdge * vertices[1].x;
+            y = (1 - tEdge) * vertices[0].y + tEdge * vertices[1].y;
+        } else if (t < 2 / 4) {
+            // Second edge (top-right to bottom-right)
+            const tEdge = (t - 1 / 4) * 4;
+            x = (1 - tEdge) * vertices[1].x + tEdge * vertices[2].x;
+            y = (1 - tEdge) * vertices[1].y + tEdge * vertices[2].y;
+        } else if (t < 3 / 4) {
+            // Third edge (bottom-right to bottom-left)
+            const tEdge = (t - 2 / 4) * 4;
+            x = (1 - tEdge) * vertices[2].x + tEdge * vertices[3].x;
+            y = (1 - tEdge) * vertices[2].y + tEdge * vertices[3].y;
+        } else {
+            // Fourth edge (bottom-left to top-left)
+            const tEdge = (t - 3 / 4) * 4;
+            x = (1 - tEdge) * vertices[3].x + tEdge * vertices[0].x;
+            y = (1 - tEdge) * vertices[3].y + tEdge * vertices[0].y;
+        }
+
+        // Apply rotation
+        const rotatedX = centerX + (x - centerX) * Math.cos(rotationRadians) - (y - centerY) * Math.sin(rotationRadians);
+        const rotatedY = centerY + (x - centerX) * Math.sin(rotationRadians) + (y - centerY) * Math.cos(rotationRadians);
+
+        points.push({ x: rotatedX, y: rotatedY });
+    }
+
+    return points;
+}
+
+// Function to draw lines between points of a triangle and a square
+function drawLines(points1, points2) {
+    ctx.strokeStyle = 'blue';
+    for (let i = 0; i < points1.length; i++) {
+        ctx.beginPath();
+        ctx.moveTo(points1[i].x, points1[i].y);
+        ctx.lineTo(points2[i].x, points2[i].y);
+        ctx.stroke();
+    }
+}
+
+// Function to animate the triangle and square
+function animate() {
+    ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
+
+    // Get points for the triangle and the square
+    const trianglePoints = getTrianglePoints(centerX, centerY, triangleSideLength, rotationAngleTriangle, numDots);
+    const squarePoints = getSquarePoints(centerX, centerY, squareSideLength, rotationAngleSquare, numDots);
+
+    // Draw lines between corresponding points of the triangle and square
+    drawLines(trianglePoints, squarePoints);
+
+    // Update rotation angles
+    rotationAngleTriangle = (rotationAngleTriangle + 2) % 360; // Rotate the triangle counterclockwise
+    rotationAngleSquare = (rotationAngleSquare - 2) % 360; // Rotate the square clockwise
+
+    requestAnimationFrame(animate); // Continue the animation
+}
+
+// Start the animation
+animate();
+

commit 4500db511735da645a237fcffd2ef2c5cbe4684c
Author: Peter Teoh <htmldeveloper@gmail.com>
Date:   Sun Sep 8 19:04:11 2024 +0800

    new file:   hexagon_line_rotate.html
    new file:   hexagon_line_rotate.js

diff --git a/hexagon_line_rotate.html b/hexagon_line_rotate.html
new file mode 100644
index 0000000..239f0e2
--- /dev/null
+++ b/hexagon_line_rotate.html
@@ -0,0 +1,28 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Hexagon Animation</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            background-color: white;
+            border: 1px solid #ccc;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="animationCanvas" width="600" height="600"></canvas>
+    <script src="hexagon_line_rotate.js"></script>
+</body>
+</html>
+
diff --git a/hexagon_line_rotate.js b/hexagon_line_rotate.js
new file mode 100644
index 0000000..d9321b1
--- /dev/null
+++ b/hexagon_line_rotate.js
@@ -0,0 +1,103 @@
+const canvas = document.getElementById('animationCanvas');
+const ctx = canvas.getContext('2d');
+const nPoints = 60; // Number of points to place along the hexagon
+const sideLength = 150; // Length of each hexagon side
+let step = 1;
+let rotationAngle = 0; // Initialize rotation angle
+
+function getPoints() {
+    const points = [];
+    const centerX = canvas.width / 2;
+    const centerY = canvas.height / 2;
+    const rotationRadians = rotationAngle * Math.PI / 180; // Convert degrees to radians
+
+    // Hexagon vertices (calculated in polar coordinates)
+    const vertices = [];
+    for (let i = 0; i < 6; i++) {
+        const angle = (Math.PI / 3) * i;
+        const x = centerX + sideLength * Math.cos(angle);
+        const y = centerY + sideLength * Math.sin(angle);
+        vertices.push({ x, y });
+    }
+
+    // Divide hexagon perimeter into nPoints
+    for (let i = 0; i < nPoints; i++) {
+        const t = i / nPoints;
+        let x, y;
+        if (t < 1 / 6) {
+            // First edge (vertex 0 to vertex 1)
+            const tEdge = t * 6;
+            x = (1 - tEdge) * vertices[0].x + tEdge * vertices[1].x;
+            y = (1 - tEdge) * vertices[0].y + tEdge * vertices[1].y;
+        } else if (t < 2 / 6) {
+            // Second edge (vertex 1 to vertex 2)
+            const tEdge = (t - 1 / 6) * 6;
+            x = (1 - tEdge) * vertices[1].x + tEdge * vertices[2].x;
+            y = (1 - tEdge) * vertices[1].y + tEdge * vertices[2].y;
+        } else if (t < 3 / 6) {
+            // Third edge (vertex 2 to vertex 3)
+            const tEdge = (t - 2 / 6) * 6;
+            x = (1 - tEdge) * vertices[2].x + tEdge * vertices[3].x;
+            y = (1 - tEdge) * vertices[2].y + tEdge * vertices[3].y;
+        } else if (t < 4 / 6) {
+            // Fourth edge (vertex 3 to vertex 4)
+            const tEdge = (t - 3 / 6) * 6;
+            x = (1 - tEdge) * vertices[3].x + tEdge * vertices[4].x;
+            y = (1 - tEdge) * vertices[3].y + tEdge * vertices[4].y;
+        } else if (t < 5 / 6) {
+            // Fifth edge (vertex 4 to vertex 5)
+            const tEdge = (t - 4 / 6) * 6;
+            x = (1 - tEdge) * vertices[4].x + tEdge * vertices[5].x;
+            y = (1 - tEdge) * vertices[4].y + tEdge * vertices[5].y;
+        } else {
+            // Sixth edge (vertex 5 to vertex 0)
+            const tEdge = (t - 5 / 6) * 6;
+            x = (1 - tEdge) * vertices[5].x + tEdge * vertices[0].x;
+            y = (1 - tEdge) * vertices[5].y + tEdge * vertices[0].y;
+        }
+
+        // Apply rotation
+        const rotatedX = centerX + (x - centerX) * Math.cos(rotationRadians) - (y - centerY) * Math.sin(rotationRadians);
+        const rotatedY = centerY + (x - centerX) * Math.sin(rotationRadians) + (y - centerY) * Math.cos(rotationRadians);
+
+        points.push({ x: rotatedX, y: rotatedY });
+    }
+
+    return points;
+}
+
+function drawPoints(points) {
+    ctx.clearRect(0, 0, canvas.width, canvas.height);
+    ctx.fillStyle = 'blue';
+
+    for (const point of points) {
+        ctx.beginPath();
+        ctx.arc(point.x, point.y, 3, 0, 2 * Math.PI);
+        ctx.fill();
+    }
+}
+
+function drawLines(points, step) {
+    ctx.strokeStyle = 'blue';
+
+    for (let i = 0; i < points.length; i++) {
+        const j = (i + step) % points.length;
+        ctx.beginPath();
+        ctx.moveTo(points[i].x, points[i].y);
+        ctx.lineTo(points[j].x, points[j].y);
+        ctx.stroke();
+    }
+}
+
+function animate() {
+    const points = getPoints();
+    drawPoints(points);
+    drawLines(points, step);
+    step = (step % (nPoints - 1)) + 1; // Increment step from 1 to 59
+    rotationAngle += 5; // Rotate by 5 degrees for the next frame
+
+    setTimeout(animate, 200); // Control animation speed
+}
+
+animate();
+

commit 1e5e59846b052c03ea083635d26769e6eaafa0b6
Author: Peter Teoh <htmldeveloper@gmail.com>
Date:   Sun Sep 8 19:03:08 2024 +0800

    new file:   double_triangle.html
    new file:   double_triangle.js
    new file:   double_triangle1.html
    new file:   double_triangle1.js
    new file:   twotriangle.html
    new file:   twotriangle.js

diff --git a/double_triangle.html b/double_triangle.html
new file mode 100644
index 0000000..1fb3c46
--- /dev/null
+++ b/double_triangle.html
@@ -0,0 +1,28 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Triangle Animation</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            background-color: white;
+            border: 1px solid #ccc;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="animationCanvas" width="600" height="600"></canvas>
+    <script src="double_triangle.js"></script>
+</body>
+</html>
+
diff --git a/double_triangle.js b/double_triangle.js
new file mode 100644
index 0000000..7c3d63e
--- /dev/null
+++ b/double_triangle.js
@@ -0,0 +1,85 @@
+const canvas = document.getElementById('animationCanvas');
+const ctx = canvas.getContext('2d');
+const numDots = 100; // Number of points along each triangle
+const largeSideLength = 500; // Side length of the larger triangle
+const smallSideLength = 100; // Side length of the smaller triangle
+const centerX = canvas.width / 2; // Fixed center X
+const centerY = canvas.height / 2; // Fixed center Y
+let rotationAngleLarge = 0;
+let rotationAngleSmall = 0;
+
+// Function to generate points along the edge of a triangle
+function getTrianglePoints(centerX, centerY, sideLength, rotationAngle, numDots) {
+    const points = [];
+    const rotationRadians = rotationAngle * Math.PI / 180; // Convert degrees to radians
+
+    // Triangle vertices (equilateral triangle)
+    const vertices = [
+        { x: centerX, y: centerY - sideLength / Math.sqrt(3) }, // Top vertex
+        { x: centerX - sideLength / 2, y: centerY + sideLength / (2 * Math.sqrt(3)) }, // Bottom left
+        { x: centerX + sideLength / 2, y: centerY + sideLength / (2 * Math.sqrt(3)) }  // Bottom right
+    ];
+
+    // Divide triangle perimeter into numDots
+    for (let i = 0; i < numDots; i++) {
+        const t = i / numDots;
+        let x, y;
+        if (t < 1 / 3) {
+            // First edge (vertex 0 to vertex 1)
+            const tEdge = t * 3;
+            x = (1 - tEdge) * vertices[0].x + tEdge * vertices[1].x;
+            y = (1 - tEdge) * vertices[0].y + tEdge * vertices[1].y;
+        } else if (t < 2 / 3) {
+            // Second edge (vertex 1 to vertex 2)
+            const tEdge = (t - 1 / 3) * 3;
+            x = (1 - tEdge) * vertices[1].x + tEdge * vertices[2].x;
+            y = (1 - tEdge) * vertices[1].y + tEdge * vertices[2].y;
+        } else {
+            // Third edge (vertex 2 to vertex 0)
+            const tEdge = (t - 2 / 3) * 3;
+            x = (1 - tEdge) * vertices[2].x + tEdge * vertices[0].x;
+            y = (1 - tEdge) * vertices[2].y + tEdge * vertices[0].y;
+        }
+
+        // Apply rotation
+        const rotatedX = centerX + (x - centerX) * Math.cos(rotationRadians) - (y - centerY) * Math.sin(rotationRadians);
+        const rotatedY = centerY + (x - centerX) * Math.sin(rotationRadians) + (y - centerY) * Math.cos(rotationRadians);
+
+        points.push({ x: rotatedX, y: rotatedY });
+    }
+
+    return points;
+}
+
+// Function to draw lines between points of two triangles
+function drawLines(points1, points2) {
+    ctx.strokeStyle = 'blue';
+    for (let i = 0; i < points1.length; i++) {
+        ctx.beginPath();
+        ctx.moveTo(points1[i].x, points1[i].y);
+        ctx.lineTo(points2[i].x, points2[i].y);
+        ctx.stroke();
+    }
+}
+
+// Function to animate the triangles
+function animate() {
+    ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
+
+    // Get points for both triangles
+    const largeTrianglePoints = getTrianglePoints(centerX, centerY, largeSideLength, rotationAngleLarge, numDots);
+    const smallTrianglePoints = getTrianglePoints(centerX, centerY, smallSideLength, rotationAngleSmall, numDots);
+
+    // Draw lines between corresponding points
+    drawLines(largeTrianglePoints, smallTrianglePoints);
+
+    // Update rotation angles
+    rotationAngleLarge = (rotationAngleLarge + 2) % 360; // Rotate counterclockwise
+    rotationAngleSmall = (rotationAngleSmall - 2) % 360; // Rotate clockwise
+
+    requestAnimationFrame(animate); // Continue the animation
+}
+
+// Start the animation
+animate();
+
diff --git a/double_triangle1.html b/double_triangle1.html
new file mode 100644
index 0000000..aa6ecaf
--- /dev/null
+++ b/double_triangle1.html
@@ -0,0 +1,28 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Triangle Animation</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            background-color: white;
+            border: 1px solid #ccc;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="animationCanvas" width="600" height="600"></canvas>
+    <script src="double_triangle1.js"></script>
+</body>
+</html>
+
diff --git a/double_triangle1.js b/double_triangle1.js
new file mode 100644
index 0000000..58e38bb
--- /dev/null
+++ b/double_triangle1.js
@@ -0,0 +1,85 @@
+const canvas = document.getElementById('animationCanvas');
+const ctx = canvas.getContext('2d');
+const numDots = 100; // Number of points along each triangle
+const largeSideLength = 500; // Side length of the larger triangle
+const smallSideLength = 500; // Side length of the smaller triangle
+const centerX = canvas.width / 2; // Fixed center X
+const centerY = canvas.height / 2; // Fixed center Y
+let rotationAngleLarge = 0;
+let rotationAngleSmall = 0;
+
+// Function to generate points along the edge of a triangle
+function getTrianglePoints(centerX, centerY, sideLength, rotationAngle, numDots) {
+    const points = [];
+    const rotationRadians = rotationAngle * Math.PI / 180; // Convert degrees to radians
+
+    // Triangle vertices (equilateral triangle)
+    const vertices = [
+        { x: centerX, y: centerY - sideLength / Math.sqrt(3) }, // Top vertex
+        { x: centerX - sideLength / 2, y: centerY + sideLength / (2 * Math.sqrt(3)) }, // Bottom left
+        { x: centerX + sideLength / 2, y: centerY + sideLength / (2 * Math.sqrt(3)) }  // Bottom right
+    ];
+
+    // Divide triangle perimeter into numDots
+    for (let i = 0; i < numDots; i++) {
+        const t = i / numDots;
+        let x, y;
+        if (t < 1 / 3) {
+            // First edge (vertex 0 to vertex 1)
+            const tEdge = t * 3;
+            x = (1 - tEdge) * vertices[0].x + tEdge * vertices[1].x;
+            y = (1 - tEdge) * vertices[0].y + tEdge * vertices[1].y;
+        } else if (t < 2 / 3) {
+            // Second edge (vertex 1 to vertex 2)
+            const tEdge = (t - 1 / 3) * 3;
+            x = (1 - tEdge) * vertices[1].x + tEdge * vertices[2].x;
+            y = (1 - tEdge) * vertices[1].y + tEdge * vertices[2].y;
+        } else {
+            // Third edge (vertex 2 to vertex 0)
+            const tEdge = (t - 2 / 3) * 3;
+            x = (1 - tEdge) * vertices[2].x + tEdge * vertices[0].x;
+            y = (1 - tEdge) * vertices[2].y + tEdge * vertices[0].y;
+        }
+
+        // Apply rotation
+        const rotatedX = centerX + (x - centerX) * Math.cos(rotationRadians) - (y - centerY) * Math.sin(rotationRadians);
+        const rotatedY = centerY + (x - centerX) * Math.sin(rotationRadians) + (y - centerY) * Math.cos(rotationRadians);
+
+        points.push({ x: rotatedX, y: rotatedY });
+    }
+
+    return points;
+}
+
+// Function to draw lines between points of two triangles
+function drawLines(points1, points2) {
+    ctx.strokeStyle = 'blue';
+    for (let i = 0; i < points1.length; i++) {
+        ctx.beginPath();
+        ctx.moveTo(points1[i].x, points1[i].y);
+        ctx.lineTo(points2[i].x, points2[i].y);
+        ctx.stroke();
+    }
+}
+
+// Function to animate the triangles
+function animate() {
+    ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
+
+    // Get points for both triangles
+    const largeTrianglePoints = getTrianglePoints(centerX, centerY, largeSideLength, rotationAngleLarge, numDots);
+    const smallTrianglePoints = getTrianglePoints(centerX, centerY, smallSideLength, rotationAngleSmall, numDots);
+
+    // Draw lines between corresponding points
+    drawLines(largeTrianglePoints, smallTrianglePoints);
+
+    // Update rotation angles
+    rotationAngleLarge = (rotationAngleLarge + 2) % 360; // Rotate counterclockwise
+    rotationAngleSmall = (rotationAngleSmall - 2) % 360; // Rotate clockwise
+
+    requestAnimationFrame(animate); // Continue the animation
+}
+
+// Start the animation
+animate();
+
diff --git a/twotriangle.html b/twotriangle.html
new file mode 100644
index 0000000..66112bf
--- /dev/null
+++ b/twotriangle.html
@@ -0,0 +1,28 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Triangle Animation</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            background-color: white;
+            border: 1px solid #ccc;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="animationCanvas" width="600" height="600"></canvas>
+    <script src="twotriangle.js"></script>
+</body>
+</html>
+
diff --git a/twotriangle.js b/twotriangle.js
new file mode 100644
index 0000000..8707c26
--- /dev/null
+++ b/twotriangle.js
@@ -0,0 +1,88 @@
+const canvas = document.getElementById('animationCanvas');
+const ctx = canvas.getContext('2d');
+const sideLength = 100; // Length of each triangle side
+let step = 1;
+
+class Triangle {
+    constructor(x, y) {
+        this.centerX = x;
+        this.centerY = y;
+        this.rotationAngle = Math.random() * 360; // Start with a random rotation angle
+        this.velocityX = (Math.random() - 0.5) * 4; // Random horizontal velocity
+        this.velocityY = (Math.random() - 0.5) * 4; // Random vertical velocity
+        this.rotationSpeed = (Math.random() - 0.5) * 5; // Random rotation speed
+    }
+
+    updatePosition() {
+        // Update position with velocity
+        this.centerX += this.velocityX;
+        this.centerY += this.velocityY;
+
+        // Bounce off the canvas edges
+        if (this.centerX - sideLength / 2 < 0 || this.centerX + sideLength / 2 > canvas.width) {
+            this.velocityX *= -1;
+        }
+        if (this.centerY - sideLength / 2 < 0 || this.centerY + sideLength / 2 > canvas.height) {
+            this.velocityY *= -1;
+        }
+
+        // Update rotation angle
+        this.rotationAngle = (this.rotationAngle + this.rotationSpeed) % 360;
+    }
+
+    getPoints() {
+        const points = [];
+        const rotationRadians = this.rotationAngle * Math.PI / 180; // Convert degrees to radians
+
+        // Triangle vertices (equilateral triangle)
+        const vertices = [
+            { x: this.centerX, y: this.centerY - sideLength / Math.sqrt(3) }, // Top vertex
+            { x: this.centerX - sideLength / 2, y: this.centerY + sideLength / (2 * Math.sqrt(3)) }, // Bottom left
+            { x: this.centerX + sideLength / 2, y: this.centerY + sideLength / (2 * Math.sqrt(3)) }  // Bottom right
+        ];
+
+        // Rotate the triangle around its center
+        for (const vertex of vertices) {
+            const rotatedX = this.centerX + (vertex.x - this.centerX) * Math.cos(rotationRadians) - (vertex.y - this.centerY) * Math.sin(rotationRadians);
+            const rotatedY = this.centerY + (vertex.x - this.centerX) * Math.sin(rotationRadians) + (vertex.y - this.centerY) * Math.cos(rotationRadians);
+            points.push({ x: rotatedX, y: rotatedY });
+        }
+
+        return points;
+    }
+
+    draw() {
+        const points = this.getPoints();
+        ctx.beginPath();
+        ctx.moveTo(points[0].x, points[0].y);
+        for (let i = 1; i < points.length; i++) {
+            ctx.lineTo(points[i].x, points[i].y);
+        }
+        ctx.closePath();
+        ctx.strokeStyle = 'blue';
+        ctx.stroke();
+        ctx.fillStyle = 'rgba(0, 0, 255, 0.3)'; // Semi-transparent fill for the triangle
+        ctx.fill();
+    }
+}
+
+// Create two triangles at random starting positions
+const triangle1 = new Triangle(Math.random() * canvas.width, Math.random() * canvas.height);
+const triangle2 = new Triangle(Math.random() * canvas.width, Math.random() * canvas.height);
+
+function animate() {
+    ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
+
+    // Update positions and rotations of both triangles
+    triangle1.updatePosition();
+    triangle2.updatePosition();
+
+    // Draw both triangles
+    triangle1.draw();
+    triangle2.draw();
+
+    requestAnimationFrame(animate); // Continue the animation
+}
+
+animate();
+

commit 6db45bf0597c6d2d6d6094ea7666a83a2631e8f5
Author: Peter Teoh <htmldeveloper@gmail.com>
Date:   Sun Sep 8 18:34:23 2024 +0800

    new file:   pentagon_line_rotate.html
    new file:   pentagon_line_rotate.js

diff --git a/pentagon_line_rotate.html b/pentagon_line_rotate.html
new file mode 100644
index 0000000..b1ec49f
--- /dev/null
+++ b/pentagon_line_rotate.html
@@ -0,0 +1,28 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Triangle Animation</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            background-color: white;
+            border: 1px solid #ccc;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="animationCanvas" width="600" height="600"></canvas>
+    <script src="pentagon_line_rotate.js"></script>
+</body>
+</html>
+
diff --git a/pentagon_line_rotate.js b/pentagon_line_rotate.js
new file mode 100644
index 0000000..9296f7b
--- /dev/null
+++ b/pentagon_line_rotate.js
@@ -0,0 +1,87 @@
+
+const canvas = document.getElementById('animationCanvas');
+const ctx = canvas.getContext('2d');
+const nPoints = 60; // Number of points to place along the triangle
+const sideLength = 300; // Length of each triangle side
+let step = 1;
+let rotationAngle = 0; // Initialize rotation angle
+
+function getPoints() {
+    const points = [];
+    const centerX = canvas.width / 2;
+    const centerY = canvas.height / 2;
+    const rotationRadians = rotationAngle * Math.PI / 180; // Convert degrees to radians
+
+    // Triangle vertices
+    const vertices = [
+        { x: centerX, y: centerY - sideLength / Math.sqrt(3) }, // Top vertex
+        { x: centerX - sideLength / 2, y: centerY + sideLength / (2 * Math.sqrt(3)) }, // Bottom left
+        { x: centerX + sideLength / 2, y: centerY + sideLength / (2 * Math.sqrt(3)) }  // Bottom right
+    ];
+
+    // Divide triangle perimeter into nPoints
+    for (let i = 0; i < nPoints; i++) {
+        const t = i / nPoints;
+        let x, y;
+        if (t < 1 / 3) {
+            // First edge (top to bottom-left)
+            const tEdge = t * 3;
+            x = (1 - tEdge) * vertices[0].x + tEdge * vertices[1].x;
+            y = (1 - tEdge) * vertices[0].y + tEdge * vertices[1].y;
+        } else if (t < 2 / 3) {
+            // Second edge (bottom-left to bottom-right)
+            const tEdge = (t - 1 / 3) * 3;
+            x = (1 - tEdge) * vertices[1].x + tEdge * vertices[2].x;
+            y = (1 - tEdge) * vertices[1].y + tEdge * vertices[2].y;
+        } else {
+            // Third edge (bottom-right to top)
+            const tEdge = (t - 2 / 3) * 3;
+            x = (1 - tEdge) * vertices[2].x + tEdge * vertices[0].x;
+            y = (1 - tEdge) * vertices[2].y + tEdge * vertices[0].y;
+        }
+
+        // Apply rotation
+        const rotatedX = centerX + (x - centerX) * Math.cos(rotationRadians) - (y - centerY) * Math.sin(rotationRadians);
+        const rotatedY = centerY + (x - centerX) * Math.sin(rotationRadians) + (y - centerY) * Math.cos(rotationRadians);
+
+        points.push({ x: rotatedX, y: rotatedY });
+    }
+
+    return points;
+}
+
+function drawPoints(points) {
+    ctx.clearRect(0, 0, canvas.width, canvas.height);
+    ctx.fillStyle = 'blue';
+
+    for (const point of points) {
+        ctx.beginPath();
+        ctx.arc(point.x, point.y, 3, 0, 2 * Math.PI);
+        ctx.fill();
+    }
+}
+
+function drawLines(points, step) {
+    ctx.strokeStyle = 'blue';
+
+    for (let i = 0; i < points.length; i++) {
+        const j = (i + step) % points.length;
+        ctx.beginPath();
+        ctx.moveTo(points[i].x, points[i].y);
+        ctx.lineTo(points[j].x, points[j].y);
+        ctx.stroke();
+    }
+}
+
+function animate() {
+    const points = getPoints();
+    drawPoints(points);
+    drawLines(points, step);
+    step = (step % (nPoints - 1)) + 1; // Increment step from 1 to 59
+    rotationAngle += 5; // Rotate by 5 degrees for the next frame
+
+    setTimeout(animate, 200); // Control animation speed
+}
+
+animate();
+

commit 72c52ed8fcb1f1bf40f041ff3469e996ffcb6c64
Author: Peter Teoh <htmldeveloper@gmail.com>
Date:   Sun Sep 8 18:30:18 2024 +0800

    Changes to be committed:
    deleted:    css_3dcube.html
    deleted:    css_circle.html
    deleted:    css_circle1.html
    deleted:    d3_graph.html
    :    dot_forest.html
    deleted:    dot_forest1.html
    modified:   ellipse2.html
    modified:   ellipse3.html
    :    ellipse4.html
    new file:   head
    deleted:    index.html
    new file:   square_line_rotate.html
    new file:   square_line_rotate.js
    new file:   triangle_line_rotate.html
    new file:   triangle_line_rotate.js
    deleted:    wave.html
    deleted:    wave1.html

diff --git a/css_3dcube.html b/css_3dcube.html
deleted file mode 100644
index d726af2..0000000
--- a/css_3dcube.html
+++ /dev/null
@@ -1,78 +0,0 @@
-
-<!DOCTYPE html>
-<html lang="en">
-<head>
-  <meta charset="UTF-8">
-  <meta name="viewport" content="width=device-width, initial-scale=1.0">
-  <title>3D Rotating Cube</title>
-  <style>
-    /* Add the CSS code here */
-body {
-  display: flex;
-  justify-content: center;
-  align-items: center;
-  height: 100vh;
-  background-color: #f0f0f0;
-  margin: 0;
-  perspective: 1000px;
-}
-
-.cube {
-  position: relative;
-  width: 200px;
-  transform-style: preserve-3d;
-  animation: rotateCube 2s infinite linear;
-}
-
-.face {
-  position: absolute;
-  width: 200px;
-  height: 200px;
-  background: rgba(0, 128, 255, 0.7);
-  border: 1px solid #000;
-  display: flex;
-  justify-content: center;
-  align-items: center;
-  font-size: 24px;
-  color: white;
-}
-
-.front  { transform: translateZ(100px); }
-.back   { transform: rotateY(180deg) translateZ(100px); }
-.right  { transform: rotateY(90deg) translateZ(100px); }
-.left   { transform: rotateY(-90deg) translateZ(100px); }
-.top    { transform: rotateX(90deg) translateZ(100px); }
-.bottom { transform: rotateX(-90deg) translateZ(100px); }
-
-@keyframes rotateCube {
-  0% {
-    transform: rotateX(0deg) rotateY(0deg) rotateZ(0deg);
-  }
-  33% {
-    transform: rotateX(360deg) rotateY(0deg) rotateZ(0deg);
-  }
-  66% {
-    transform: rotateX(360deg) rotateY(360deg) rotateZ(0deg);
-  }
-  100% {
-    transform: rotateX(360deg) rotateY(360deg) rotateZ(360deg);
-  }
-}
-
-
-  </style>
-</head>
-<body>
-  <div class="cube">
-    <div class="face front">Front</div>
-    <div class="face back">Back</div>
-    <div class="face right">Right</div>
-    <div class="face left">Left</div>
-    <div class="face top">Top</div>
-    <div class="face bottom">Bottom</div>
-  </div>
-</body>
-</html>
-
-
-
diff --git a/css_circle.html b/css_circle.html
deleted file mode 100644
index 442e404..0000000
--- a/css_circle.html
+++ /dev/null
@@ -1,19 +0,0 @@
-
-<!DOCTYPE html>
-<html lang="en">
-<head>
-    <meta charset="UTF-8">
-    <meta name="viewport" content="width=device-width, initial-scale=1.0">
-    <title>Circle Slider</title>
-    <link rel="stylesheet" href="css_style.css">
-</head>
-<body>
-    <div class="container">
-        <input type="range" id="radiusSlider" min="10" max="200" value="50">
-        <button id="startButton">Start</button>
-        <canvas id="circleCanvas"></canvas>
-    </div>
-    <script src="css_script.js"></script>
-</body>
-</html>
-
diff --git a/css_circle1.html b/css_circle1.html
deleted file mode 100644
index 5eb5f9a..0000000
--- a/css_circle1.html
+++ /dev/null
@@ -1,20 +0,0 @@
-
-<!DOCTYPE html>
-<html lang="en">
-<head>
-    <meta charset="UTF-8">
-    <meta name="viewport" content="width=device-width, initial-scale=1.0">
-    <title>Circle Slider</title>
-    <link rel="stylesheet" href="css_style1.css">
-</head>
-<body>
-    <div class="container">
-        <input type="range" id="radiusSlider" min="10" max="200" value="100">
-        <input type="number" id="innerCircleCount" min="1" max="100" value="20">
-        <button id="startButton">Start</button>
-        <canvas id="circleCanvas"></canvas>
-    </div>
-    <script src="css_script1.js"></script>
-</body>
-</html>
-
diff --git a/d3_graph.html b/d3_graph.html
deleted file mode 100644
index 6cb3629..0000000
--- a/d3_graph.html
+++ /dev/null
@@ -1,18 +0,0 @@
-<!DOCTYPE html>
-<html lang="en">
-<head>
-    <meta charset="UTF-8">
-    <title>Scatter Plot with D3.js</title>
-    <script src="https://d3js.org/d3.v7.min.js"></script>
-    <style>
-        .dot {
-            fill: steelblue;
-        }
-    </style>
-</head>
-<body>
-    <svg width="800" height="600"></svg>
-    <script src="d3_graph.js"></script>
-</body>
-</html>
-
diff --git a/dot_forest.html b/dot_forest.html
deleted file mode 100644
index abc8d28..0000000
--- a/dot_forest.html
+++ /dev/null
@@ -1,75 +0,0 @@
-<!DOCTYPE html>
-<html lang="en">
-<head>
-    <meta charset="UTF-8">
-    <meta name="viewport" content="width=device-width, initial-scale=1.0">
-    <title>Connected Dots using D3.js</title>
-    <script src="https://d3js.org/d3.v7.min.js"></script>
-</head>
-<body>
-    <svg width="800" height="800"></svg>
-
-    <script>
-        const width = 800;
-        const height = 800;
-        const numDots = 20;
-        const svg = d3.select("svg");
-
-        // Generate random dots
-        const nodes = d3.range(numDots).map(() => {
-            return {
-                x: Math.random() * width,
-                y: Math.random() * height
-            };
-        });
-
-        // Generate a Minimum Spanning Tree (MST) using Prim's algorithm
-        const links = [];
-        const visited = new Set();
-        visited.add(0);
-
-        while (visited.size < nodes.length) {
-            let minDist = Infinity;
-            let newLink = null;
-
-            visited.forEach(u => {
-                nodes.forEach((v, vi) => {
-                    if (!visited.has(vi)) {
-                        const dist = Math.hypot(nodes[u].x - v.x, nodes[u].y - v.y);
-                        if (dist < minDist) {
-                            minDist = dist;
-                            newLink = { source: u, target: vi };
-                        }
-                    }
-                });
-            });
-
-            links.push(newLink);
-            visited.add(newLink.target);
-        }
-
-        // Draw the links
-        svg.selectAll("line")
-            .data(links)
-            .enter()
-            .append("line")
-            .attr("x1", d => nodes[d.source].x)
-            .attr("y1", d => nodes[d.source].y)
-            .attr("x2", d => nodes[d.target].x)
-            .attr("y2", d => nodes[d.target].y)
-            .attr("stroke", "black")
-            .attr("stroke-width", 2);
-
-        // Draw the dots
-        svg.selectAll("circle")
-            .data(nodes)
-            .enter()
-            .append("circle")
-            .attr("cx", d => d.x)
-            .attr("cy", d => d.y)
-            .attr("r", 5)
-            .attr("fill", "red");
-    </script>
-</body>
-</html>
-
diff --git a/dot_forest1.html b/dot_forest1.html
deleted file mode 100644
index ba32e2c..0000000
--- a/dot_forest1.html
+++ /dev/null
@@ -1,134 +0,0 @@
-<!DOCTYPE html>
-<html lang="en">
-<head>
-    <meta charset="UTF-8">
-    <meta name="viewport" content="width=device-width, initial-scale=1.0">
-    <title>Interactive Connected Dots using D3.js</title>
-    <script src="https://d3js.org/d3.v7.min.js"></script>
-</head>
-<body>
-    <svg width="800" height="800"></svg>
-
-    <script>
-        const width = 800;
-        const height = 800;
-        const numDots = 20;
-        const svg = d3.select("svg");
-        const strength = 0.1; // Pulling strength of the connected dots
-
-        // Generate random dots
-        const nodes = d3.range(numDots).map(() => {
-            return {
-                x: Math.random() * width,
-                y: Math.random() * height,
-                vx: 0,
-                vy: 0
-            };
-        });
-
-        // Generate a Minimum Spanning Tree (MST) using Prim's algorithm
-        const links = [];
-        const visited = new Set();
-        visited.add(0);
-
-        while (visited.size < nodes.length) {
-            let minDist = Infinity;
-            let newLink = null;
-
-            visited.forEach(u => {
-                nodes.forEach((v, vi) => {
-                    if (!visited.has(vi)) {
-                        const dist = Math.hypot(nodes[u].x - v.x, nodes[u].y - v.y);
-                        if (dist < minDist) {
-                            minDist = dist;
-                            newLink = { source: u, target: vi };
-                        }
-                    }
-                });
-            });
-
-            links.push(newLink);
-            visited.add(newLink.target);
-        }
-
-        // Draw the links
-        const line = svg.selectAll("line")
-            .data(links)
-            .enter()
-            .append("line")
-            .attr("stroke", "black")
-            .attr("stroke-width", 2);
-
-        // Draw the dots
-        const circle = svg.selectAll("circle")
-            .data(nodes)
-            .enter()
-            .append("circle")
-            .attr("r", 5)
-            .attr("fill", "red")
-            .call(d3.drag()
-                .on("start", dragstarted)
-                .on("drag", dragged)
-                .on("end", dragended));
-
-        // Function to update the positions of dots and lines
-        function update() {
-            line
-                .attr("x1", d => nodes[d.source].x)
-                .attr("y1", d => nodes[d.source].y)
-                .attr("x2", d => nodes[d.target].x)
-                .attr("y2", d => nodes[d.target].y);
-
-            circle
-                .attr("cx", d => d.x)
-                .attr("cy", d => d.y);
-        }
-
-        // Drag functions
-        function dragstarted(event, d) {
-            d3.select(this).raise().attr("fill", "orange");
-        }
-
-        function dragged(event, d) {
-            // Update the dragged node's position
-            d.x = event.x;
-            d.y = event.y;
-
-            // Apply pulling effect to connected nodes
-            links.forEach(link => {
-                if (link.source === nodes.indexOf(d)) {
-                    pullNode(nodes[link.target], d);
-                } else if (link.target === nodes.indexOf(d)) {
-                    pullNode(nodes[link.source], d);
-                }
-            });
-
-            // Update the visualization
-            update();
-        }
-
-        function dragended(event, d) {
-            d3.select(this).attr("fill", "red");
-        }
-
-        function pullNode(target, dragged) {
-            const dx = dragged.x - target.x;
-            const dy = dragged.y - target.y;
-            target.vx += dx * strength;
-            target.vy += dy * strength;
-
-            // Update the position of the connected node
-            target.x += target.vx;
-            target.y += target.vy;
-
-            // Dampen the velocity to simulate friction
-            target.vx *= 0.9;
-            target.vy *= 0.9;
-        }
-
-        // Initial update of positions
-        update();
-    </script>
-</body>
-</html>
-
diff --git a/ellipse2.html b/ellipse2.html
index 43d1021..e2eadba 100644
--- a/ellipse2.html
+++ b/ellipse2.html
@@ -24,7 +24,7 @@
         }
     </style>
 </head>
-<body>
+<body onload="drawEllipse()" >
     <div id="controls">
         <label for="radiusX">Radius X: </label>
         <input type="number" id="radiusX" value="100">
diff --git a/ellipse3.html b/ellipse3.html
index 183ed7f..609284e 100644
--- a/ellipse3.html
+++ b/ellipse3.html
@@ -23,7 +23,7 @@
         }
     </style>
 </head>
-<body>
+<body onload="drawEllipse()">
     <div id="controls">
         <label for="radiusX">Radius X: </label>
         <input type="number" id="radiusX" value="100">
@@ -51,7 +51,7 @@
         function drawEllipseAtPosition(x, y, radiusX, radiusY) {
             context.beginPath();
             context.ellipse(x, y, radiusX, radiusY, 0, 0, 2 * Math.PI);
-            context.fillStyle = 'blue';
+            context.fillStyle = getRandomColor();
             context.fill();
             context.stroke();
         }
@@ -72,7 +72,7 @@
                 context.rotate(ellipse.angle);
                 context.beginPath();
                 context.ellipse(0, 0, ellipse.radiusX, ellipse.radiusY, 0, 0, 2 * Math.PI);
-                context.fillStyle = 'blue';
+                context.fillStyle = getRandomColor();
                 context.fill();
                 context.stroke();
                 context.restore();
@@ -81,6 +81,20 @@
             requestAnimationFrame(animateEllipses);
         }
 
+        function getRandomColor() {
+          const colors = [
+            "blue", "green", "red", "yellow", "purple", "orange", "pink", "brown",
+            "black", "white", "gray", "cyan", "magenta", "lime", "indigo", "violet",
+            "gold", "silver", "beige", "maroon", "olive", "navy", "teal"
+          ];
+        
+          // Generate a random index to pick a color
+          const randomIndex = Math.floor(Math.random() * colors.length);
+        
+          // Return the randomly selected color
+          return colors[randomIndex];
+        }
+        
         animateEllipses();
     </script>
 </body>
diff --git a/ellipse4.html b/ellipse4.html
deleted file mode 100644
index 6500d9b..0000000
--- a/ellipse4.html
+++ /dev/null
@@ -1,96 +0,0 @@
-<!DOCTYPE html>
-<html lang="en">
-<head>
-    <meta charset="UTF-8">
-    <meta name="viewport" content="width=device-width, initial-scale=1.0">
-    <title>Rotating Ellipses</title>
-    <style>
-        body {
-            display: flex;
-            justify-content: center;
-            align-items: center;
-            height: 100vh;
-            margin: 0;
-            background-color: #f0f0f0;
-        }
-        canvas {
-            border: 1px solid black;
-        }
-        #controls {
-            position: absolute;
-            top: 20px;
-            left: 20px;
-        }
-    </style>
-</head>
-<body>
-    <div id="controls">
-        <label for="radiusX">Radius X: </label>
-        <input type="number" id="radiusX" value="100">
-        <label for="radiusY">Radius Y: </label>
-        <input type="number" id="radiusY" value="50">
-        <button onclick="drawEllipse()">Draw Ellipse</button>
-    </div>
-    <canvas id="canvas" width="800" height="600"></canvas>
-    
-    <script>
-        const canvas = document.getElementById('canvas');
-        const context = canvas.getContext('2d');
-        let ellipses = [];
-        let centerX = canvas.width / 2;
-        let centerY = canvas.height / 2;
-        let traverseAngle = 0;
-        const traverseRadius = 50;
-
-        canvas.addEventListener('click', (event) => {
-            const radiusX = parseInt(document.getElementById('radiusX').value, 10);
-            const radiusY = parseInt(document.getElementById('radiusY').value, 10);
-            drawEllipseAtPosition(centerX, centerY, radiusX, radiusY);
-            ellipses.push({x: centerX, y: centerY, radiusX: radiusX, radiusY: radiusY, angle: 0});
-            updateCenter();
-        });
-
-        function drawEllipseAtPosition(x, y, radiusX, radiusY) {
-            context.beginPath();
-            context.ellipse(x, y, radiusX, radiusY, 0, 0, 2 * Math.PI);
-            context.fillStyle = 'blue';
-            context.fill();
-            context.stroke();
-        }
-
-        function drawEllipse() {
-            const radiusX = parseInt(document.getElementById('radiusX').value, 10);
-            const radiusY = parseInt(document.getElementById('radiusY').value, 10);
-            drawEllipseAtPosition(centerX, centerY, radiusX, radiusY);
-            ellipses.push({x: centerX, y: centerY, radiusX: radiusX, radiusY: radiusY, angle: 0});
-            updateCenter();
-        }
-
-        function updateCenter() {
-            traverseAngle += Math.PI / 12;  // Update the angle by 30 degrees
-            centerX = canvas.width / 2 + traverseRadius * Math.cos(4*traverseAngle);
-            centerY = canvas.height / 2 + traverseRadius * Math.sin(4*traverseAngle);
-        }
-
-        function animateEllipses() {
-            ellipses.forEach(ellipse => {
-                context.save();
-                context.translate(ellipse.x, ellipse.y);
-                context.rotate(ellipse.angle);
-                context.beginPath();
-                context.ellipse(0, 0, ellipse.radiusX, ellipse.radiusY, 0, 0, 2 * Math.PI);
-                context.fillStyle = 'blue';
-                context.fill();
-                context.stroke();
-                context.restore();
-                ellipse.angle += 0.2;
-            	updateCenter();
-            	//ellipses.push({x: centerX, y: centerY, radiusX: radiusX, radiusY: radiusY, angle: 0});
-            });
-            requestAnimationFrame(animateEllipses);
-        }
-
-        animateEllipses();
-    </script>
-</body>
-</html>
diff --git a/head b/head
new file mode 100644
index 0000000..b385030
--- /dev/null
+++ b/head
@@ -0,0 +1,18 @@
+<head>
+     <meta charset="UTF-8">
+     <meta name="viewport" content="width=device-width, initial-scale=1.0">
+     <title></title>
+     <style>
+         body {
+             display: flex;
+             justify-content: center;
+             align-items: center;
+             height: 100vh;
+             margin: 0;
+             background-color: #fff;
+         }
+         canvas {
+             border: 1px solid black;
+         }
+     </style>
+</head>
diff --git a/index.html b/index.html
deleted file mode 100644
index 47ee9fb..0000000
--- a/index.html
+++ /dev/null
@@ -1,220 +0,0 @@
-
-    <!DOCTYPE html>
-    <html lang="en">
-    <head>
-        <meta charset="UTF-8">
-        <meta name="viewport" content="width=device-width, initial-scale=1.0">
-        <title>Sansagraphics Jems</title>
-        <style>
-            body { font-family: Arial, sans-serif; margin: 20px; }
-            a { display: block; margin-bottom: 10px; text-decoration: none; color: blue; }
-            iframe { width: 100%; height: 500px; border: none; margin-top: 20px; }
-        </style>
-    </head>
-    <body>
-        <h1>Sansagraphics Jems</h1>
-    
-            <a href="icosahedron_surface.html">icosahedron_surface.html</a>
-            <iframe src="icosahedron_surface.html"></iframe>
-            
-            <a href="icosahedron_centroid.html">icosahedron_centroid.html</a>
-            <iframe src="icosahedron_centroid.html"></iframe>
-            
-            <a href="icosahedron.html">icosahedron.html</a>
-            <iframe src="icosahedron.html"></iframe>
-            
-            <a href="sphere.html">sphere.html</a>
-            <iframe src="sphere.html"></iframe>
-            
-            <a href="ovalellipse.html">ovalellipse.html</a>
-            <iframe src="ovalellipse.html"></iframe>
-            
-            <a href="klein2_animation3.html">klein2_animation3.html</a>
-            <iframe src="klein2_animation3.html"></iframe>
-            
-            <a href="klein2_animation.html">klein2_animation.html</a>
-            <iframe src="klein2_animation.html"></iframe>
-            
-            <a href="klein3.html">klein3.html</a>
-            <iframe src="klein3.html"></iframe>
-            
-            <a href="torus.html">torus.html</a>
-            <iframe src="torus.html"></iframe>
-            
-            <a href="line_drawing.html">line_drawing.html</a>
-            <iframe src="line_drawing.html"></iframe>
-            
-            <a href="mobius.html">mobius.html</a>
-            <iframe src="mobius.html"></iframe>
-            
-            <a href="moving_square2.html">moving_square2.html</a>
-            <iframe src="moving_square2.html"></iframe>
-            
-            <a href="moving_square3.html">moving_square3.html</a>
-            <iframe src="moving_square3.html"></iframe>
-            
-            <a href="moving_square4.html">moving_square4.html</a>
-            <iframe src="moving_square4.html"></iframe>
-            
-            <a href="moving_square5.html">moving_square5.html</a>
-            <iframe src="moving_square5.html"></iframe>
-            
-            <a href="moving_square.html">moving_square.html</a>
-            <iframe src="moving_square.html"></iframe>
-            
-            <a href="quart_motion.html">quart_motion.html</a>
-            <iframe src="quart_motion.html"></iframe>
-            
-            <a href="rotating_sector.html">rotating_sector.html</a>
-            <iframe src="rotating_sector.html"></iframe>
-            
-            <a href="rotating_spiral.html">rotating_spiral.html</a>
-            <iframe src="rotating_spiral.html"></iframe>
-            
-            <a href="rotating_spoke.html">rotating_spoke.html</a>
-            <iframe src="rotating_spoke.html"></iframe>
-            
-            <a href="sinsoidal5.html">sinsoidal5.html</a>
-            <iframe src="sinsoidal5.html"></iframe>
-            
-            <a href="sinusoidal.html">sinusoidal.html</a>
-            <iframe src="sinusoidal.html"></iframe>
-            
-            <a href="solid_torus1.html">solid_torus1.html</a>
-            <iframe src="solid_torus1.html"></iframe>
-            
-            <a href="special.html">special.html</a>
-            <iframe src="special.html"></iframe>
-            
-            <a href="spherical_sinusoid1.html">spherical_sinusoid1.html</a>
-            <iframe src="spherical_sinusoid1.html"></iframe>
-            
-            <a href="spherical_sinusoid3.html">spherical_sinusoid3.html</a>
-            <iframe src="spherical_sinusoid3.html"></iframe>
-            
-            <a href="spherical_sinusoid.html">spherical_sinusoid.html</a>
-            <iframe src="spherical_sinusoid.html"></iframe>
-            
-            <a href="spiral.html">spiral.html</a>
-            <iframe src="spiral.html"></iframe>
-            
-            <a href="spoke_subspokes.html">spoke_subspokes.html</a>
-            <iframe src="spoke_subspokes.html"></iframe>
-            
-            <a href="static_concentric.html">static_concentric.html</a>
-            <iframe src="static_concentric.html"></iframe>
-            
-            <a href="concentric.html">concentric.html</a>
-            <iframe src="concentric.html"></iframe>
-            
-            <a href="three_petal.html">three_petal.html</a>
-            <iframe src="three_petal.html"></iframe>
-            
-            <a href="torus2.html">torus2.html</a>
-            <iframe src="torus2.html"></iframe>
-            
-            <a href="triple_motion.html">triple_motion.html</a>
-            <iframe src="triple_motion.html"></iframe>
-            
-            <a href="try5.html">try5.html</a>
-            <iframe src="try5.html"></iframe>
-            
-            <a href="two_ellipse.html">two_ellipse.html</a>
-            <iframe src="two_ellipse.html"></iframe>
-            
-            <a href="two_petal.html">two_petal.html</a>
-            <iframe src="two_petal.html"></iframe>
-            
-            <a href="double_motion.html">double_motion.html</a>
-            <iframe src="double_motion.html"></iframe>
-            
-            <a href="drawsector.html">drawsector.html</a>
-            <iframe src="drawsector.html"></iframe>
-            
-            <a href="ellipse2.html">ellipse2.html</a>
-            <iframe src="ellipse2.html"></iframe>
-            
-            <a href="ellipse3.html">ellipse3.html</a>
-            <iframe src="ellipse3.html"></iframe>
-            
-            <a href="ellipse4.html">ellipse4.html</a>
-            <iframe src="ellipse4.html"></iframe>
-            
-            <a href="ellipsical_line.html">ellipsical_line.html</a>
-            <iframe src="ellipsical_line.html"></iframe>
-            
-            <a href="ellipsical_line_rotate.html">ellipsical_line_rotate.html</a>
-            <iframe src="ellipsical_line_rotate.html"></iframe>
-            
-            <a href="figure_eight2.html">figure_eight2.html</a>
-            <iframe src="figure_eight2.html"></iframe>
-            
-            <a href="figure_eight.html">figure_eight.html</a>
-            <iframe src="figure_eight.html"></iframe>
-            
-            <a href="five_rotate_spoke.html">five_rotate_spoke.html</a>
-            <iframe src="five_rotate_spoke.html"></iframe>
-            
-            <a href="five_rotate_spoke_sector.html">five_rotate_spoke_sector.html</a>
-            <iframe src="five_rotate_spoke_sector.html"></iframe>
-            
-            <a href="four_petal_double.html">four_petal_double.html</a>
-            <iframe src="four_petal_double.html"></iframe>
-            
-            <a href="four_petal.html">four_petal.html</a>
-            <iframe src="four_petal.html"></iframe>
-            
-            <a href="four_petal_rotate.html">four_petal_rotate.html</a>
-            <iframe src="four_petal_rotate.html"></iframe>
-            
-            <a href="klein2_animation2.html">klein2_animation2.html</a>
-            <iframe src="klein2_animation2.html"></iframe>
-            
-            <a href="chasing_square1.html">chasing_square1.html</a>
-            <iframe src="chasing_square1.html"></iframe>
-            
-            <a href="chasing_square2.html">chasing_square2.html</a>
-            <iframe src="chasing_square2.html"></iframe>
-            
-            <a href="chasing_square.html">chasing_square.html</a>
-            <iframe src="chasing_square.html"></iframe>
-            
-            <a href="circle2.html">circle2.html</a>
-            <iframe src="circle2.html"></iframe>
-            
-            <a href="circle_color.html">circle_color.html</a>
-            <iframe src="circle_color.html"></iframe>
-            
-            <a href="circle.html">circle.html</a>
-            <iframe src="circle.html"></iframe>
-            
-            <a href="counter_rotating_sector.html">counter_rotating_sector.html</a>
-            <iframe src="counter_rotating_sector.html"></iframe>
-            
-            <a href="css_3dcube.html">css_3dcube.html</a>
-            <iframe src="css_3dcube.html"></iframe>
-            
-            <a href="css_circle1.html">css_circle1.html</a>
-            <iframe src="css_circle1.html"></iframe>
-            
-            <a href="css_circle.html">css_circle.html</a>
-            <iframe src="css_circle.html"></iframe>
-            
-            <a href="d3_graph.html">d3_graph.html</a>
-            <iframe src="d3_graph.html"></iframe>
-            
-            <a href="double3.html">double3.html</a>
-            <iframe src="double3.html"></iframe>
-            
-            <a href="double4.html">double4.html</a>
-            <iframe src="double4.html"></iframe>
-            
-            <a href="double5.html">double5.html</a>
-            <iframe src="double5.html"></iframe>
-            
-            <a href="double.html">double.html</a>
-            <iframe src="double.html"></iframe>
-            
-    </body>
-    </html>
-    
diff --git a/square_line_rotate.html b/square_line_rotate.html
new file mode 100644
index 0000000..1c4cb96
--- /dev/null
+++ b/square_line_rotate.html
@@ -0,0 +1,28 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Square Animation</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            background-color: white;
+            border: 1px solid #ccc;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="animationCanvas" width="600" height="600"></canvas>
+    <script src="square_line_rotate.js"></script>
+</body>
+</html>
+
diff --git a/square_line_rotate.js b/square_line_rotate.js
new file mode 100644
index 0000000..5d3c108
--- /dev/null
+++ b/square_line_rotate.js
@@ -0,0 +1,93 @@
+const canvas = document.getElementById('animationCanvas');
+const ctx = canvas.getContext('2d');
+const nPoints = 60; // Number of points to place along the square
+const sideLength = 300; // Length of each square side
+let step = 1;
+let rotationAngle = 0; // Initialize rotation angle
+
+function getPoints() {
+    const points = [];
+    const centerX = canvas.width / 2;
+    const centerY = canvas.height / 2;
+    const halfSide = sideLength / 2;
+    const rotationRadians = rotationAngle * Math.PI / 180; // Convert degrees to radians
+
+    // Square vertices
+    const vertices = [
+        { x: centerX - halfSide, y: centerY - halfSide }, // Top-left
+        { x: centerX + halfSide, y: centerY - halfSide }, // Top-right
+        { x: centerX + halfSide, y: centerY + halfSide }, // Bottom-right
+        { x: centerX - halfSide, y: centerY + halfSide }  // Bottom-left
+    ];
+
+    // Divide square perimeter into nPoints
+    for (let i = 0; i < nPoints; i++) {
+        const t = i / nPoints;
+        let x, y;
+        if (t < 1 / 4) {
+            // First edge (top-left to top-right)
+            const tEdge = t * 4;
+            x = (1 - tEdge) * vertices[0].x + tEdge * vertices[1].x;
+            y = (1 - tEdge) * vertices[0].y + tEdge * vertices[1].y;
+        } else if (t < 1 / 2) {
+            // Second edge (top-right to bottom-right)
+            const tEdge = (t - 1 / 4) * 4;
+            x = (1 - tEdge) * vertices[1].x + tEdge * vertices[2].x;
+            y = (1 - tEdge) * vertices[1].y + tEdge * vertices[2].y;
+        } else if (t < 3 / 4) {
+            // Third edge (bottom-right to bottom-left)
+            const tEdge = (t - 1 / 2) * 4;
+            x = (1 - tEdge) * vertices[2].x + tEdge * vertices[3].x;
+            y = (1 - tEdge) * vertices[2].y + tEdge * vertices[3].y;
+        } else {
+            // Fourth edge (bottom-left to top-left)
+            const tEdge = (t - 3 / 4) * 4;
+            x = (1 - tEdge) * vertices[3].x + tEdge * vertices[0].x;
+            y = (1 - tEdge) * vertices[3].y + tEdge * vertices[0].y;
+        }
+
+        // Apply rotation
+        const rotatedX = centerX + (x - centerX) * Math.cos(rotationRadians) - (y - centerY) * Math.sin(rotationRadians);
+        const rotatedY = centerY + (x - centerX) * Math.sin(rotationRadians) + (y - centerY) * Math.cos(rotationRadians);
+
+        points.push({ x: rotatedX, y: rotatedY });
+    }
+
+    return points;
+}
+
+function drawPoints(points) {
+    ctx.clearRect(0, 0, canvas.width, canvas.height);
+    ctx.fillStyle = 'blue';
+
+    for (const point of points) {
+        ctx.beginPath();
+        ctx.arc(point.x, point.y, 3, 0, 2 * Math.PI);
+        ctx.fill();
+    }
+}
+
+function drawLines(points, step) {
+    ctx.strokeStyle = 'blue';
+
+    for (let i = 0; i < points.length; i++) {
+        const j = (i + step) % points.length;
+        ctx.beginPath();
+        ctx.moveTo(points[i].x, points[i].y);
+        ctx.lineTo(points[j].x, points[j].y);
+        ctx.stroke();
+    }
+}
+
+function animate() {
+    const points = getPoints();
+    drawPoints(points);
+    drawLines(points, step);
+    step = (step % (nPoints - 1)) + 1; // Increment step from 1 to 59
+    rotationAngle += 5; // Rotate by 5 degrees for the next frame
+
+    setTimeout(animate, 200); // Control animation speed
+}
+
+animate();
+
diff --git a/triangle_line_rotate.html b/triangle_line_rotate.html
new file mode 100644
index 0000000..6ab0cc6
--- /dev/null
+++ b/triangle_line_rotate.html
@@ -0,0 +1,28 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Triangle Animation</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            background-color: white;
+            border: 1px solid #ccc;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="animationCanvas" width="600" height="600"></canvas>
+    <script src="triangle_line_rotate.js"></script>
+</body>
+</html>
+
diff --git a/triangle_line_rotate.js b/triangle_line_rotate.js
new file mode 100644
index 0000000..9296f7b
--- /dev/null
+++ b/triangle_line_rotate.js
@@ -0,0 +1,87 @@
+
+const canvas = document.getElementById('animationCanvas');
+const ctx = canvas.getContext('2d');
+const nPoints = 60; // Number of points to place along the triangle
+const sideLength = 300; // Length of each triangle side
+let step = 1;
+let rotationAngle = 0; // Initialize rotation angle
+
+function getPoints() {
+    const points = [];
+    const centerX = canvas.width / 2;
+    const centerY = canvas.height / 2;
+    const rotationRadians = rotationAngle * Math.PI / 180; // Convert degrees to radians
+
+    // Triangle vertices
+    const vertices = [
+        { x: centerX, y: centerY - sideLength / Math.sqrt(3) }, // Top vertex
+        { x: centerX - sideLength / 2, y: centerY + sideLength / (2 * Math.sqrt(3)) }, // Bottom left
+        { x: centerX + sideLength / 2, y: centerY + sideLength / (2 * Math.sqrt(3)) }  // Bottom right
+    ];
+
+    // Divide triangle perimeter into nPoints
+    for (let i = 0; i < nPoints; i++) {
+        const t = i / nPoints;
+        let x, y;
+        if (t < 1 / 3) {
+            // First edge (top to bottom-left)
+            const tEdge = t * 3;
+            x = (1 - tEdge) * vertices[0].x + tEdge * vertices[1].x;
+            y = (1 - tEdge) * vertices[0].y + tEdge * vertices[1].y;
+        } else if (t < 2 / 3) {
+            // Second edge (bottom-left to bottom-right)
+            const tEdge = (t - 1 / 3) * 3;
+            x = (1 - tEdge) * vertices[1].x + tEdge * vertices[2].x;
+            y = (1 - tEdge) * vertices[1].y + tEdge * vertices[2].y;
+        } else {
+            // Third edge (bottom-right to top)
+            const tEdge = (t - 2 / 3) * 3;
+            x = (1 - tEdge) * vertices[2].x + tEdge * vertices[0].x;
+            y = (1 - tEdge) * vertices[2].y + tEdge * vertices[0].y;
+        }
+
+        // Apply rotation
+        const rotatedX = centerX + (x - centerX) * Math.cos(rotationRadians) - (y - centerY) * Math.sin(rotationRadians);
+        const rotatedY = centerY + (x - centerX) * Math.sin(rotationRadians) + (y - centerY) * Math.cos(rotationRadians);
+
+        points.push({ x: rotatedX, y: rotatedY });
+    }
+
+    return points;
+}
+
+function drawPoints(points) {
+    ctx.clearRect(0, 0, canvas.width, canvas.height);
+    ctx.fillStyle = 'blue';
+
+    for (const point of points) {
+        ctx.beginPath();
+        ctx.arc(point.x, point.y, 3, 0, 2 * Math.PI);
+        ctx.fill();
+    }
+}
+
+function drawLines(points, step) {
+    ctx.strokeStyle = 'blue';
+
+    for (let i = 0; i < points.length; i++) {
+        const j = (i + step) % points.length;
+        ctx.beginPath();
+        ctx.moveTo(points[i].x, points[i].y);
+        ctx.lineTo(points[j].x, points[j].y);
+        ctx.stroke();
+    }
+}
+
+function animate() {
+    const points = getPoints();
+    drawPoints(points);
+    drawLines(points, step);
+    step = (step % (nPoints - 1)) + 1; // Increment step from 1 to 59
+    rotationAngle += 5; // Rotate by 5 degrees for the next frame
+
+    setTimeout(animate, 200); // Control animation speed
+}
+
+animate();
+
diff --git a/wave.html b/wave.html
deleted file mode 100644
index 2048624..0000000
--- a/wave.html
+++ /dev/null
@@ -1,27 +0,0 @@
-
-<!DOCTYPE html>
-<html lang="en">
-<head>
-    <meta charset="UTF-8">
-    <meta name="viewport" content="width=device-width, initial-scale=1.0">
-    <title>Wave Animation</title>
-    <style>
-        body, html {
-            margin: 0;
-            padding: 0;
-            overflow: hidden;
-            height: 100%;
-            background-color: black;
-        }
-        canvas {
-            display: block;
-        }
-    </style>
-</head>
-<body>
-    <canvas id="waveCanvas"></canvas>
-
-    <script src="wave.js"></script>
-</body>
-</html>
-
diff --git a/wave1.html b/wave1.html
deleted file mode 100644
index 7284ab6..0000000
--- a/wave1.html
+++ /dev/null
@@ -1,28 +0,0 @@
-
-<!DOCTYPE html>
-<html lang="en">
-<head>
-    <meta charset="UTF-8">
-    <meta name="viewport" content="width=device-width, initial-scale=1.0">
-    <title>Wave Animation</title>
-    <style>
-        body, html {
-            margin: 0;
-            padding: 0;
-            overflow: hidden;
-            height: 100%;
-            background-color: black;
-        }
-        canvas {
-            display: block;
-            filter: blue(5px);
-        }
-    </style>
-</head>
-<body>
-    <canvas id="waveCanvas"></canvas>
-
-    <script src="wave1.js"></script>
-</body>
-</html>
-

commit ff07c0551cfac420a89f47c56b5b4cd19dc6ec68
Author: Peter Teoh <htmldeveloper@gmail.com>
Date:   Sun Sep 8 16:25:41 2024 +0800

    modified:   circle2.html
    deleted:    circle22.html

diff --git a/circle2.html b/circle2.html
index 7e7f978..1e083c6 100644
--- a/circle2.html
+++ b/circle2.html
@@ -1,4 +1,3 @@
-
 <!DOCTYPE html>
 <html lang="en">
 <head>
@@ -28,6 +27,7 @@
     <div id="controls">
         <label for="radius">Radius: </label>
         <input type="number" id="radius" value="50">
+        <label for="nodenumber">Node Number: </label>
         <input type="number" id="nodenumber" value="2">
         <button onclick="drawCircle()">Draw Circle</button>
     </div>
@@ -43,19 +43,19 @@
             const y = event.clientY - rect.top;
             const radius = parseInt(document.getElementById('radius').value, 10);
             const radius2 = 2 * parseInt(document.getElementById('radius').value, 10);
-            const nodenumber = parseInt(document.getElementById('nodenumber').value, 2);
+            const nodenumber = parseInt(document.getElementById('nodenumber').value, 10); // Change from base 2 to base 10
             const delta0 = (Math.PI / 15);
             for (let delta = 0; delta <= Math.PI * 2; delta += delta0) {
-            	drawCirclePolar(x, y, radius, radius2, nodenumber, delta);
-	    }
+                drawCirclePolar(x, y, radius, radius2, nodenumber, delta);
+            }
         });
 
         function drawCirclePolar(centerX, centerY, radius, radius2, nodenumber, delta) {
             context.beginPath();
             for (let angle = 0; angle <= 360; angle++) {
                 const theta = angle * (Math.PI / 180);
-                const x = centerX + ( radius2 + radius * Math.cos(nodenumber*theta + delta)) * Math.cos(theta + delta);
-                const y = centerY + ( radius2 + radius * Math.cos(nodenumber*theta + delta)) * Math.sin(theta + delta);
+                const x = centerX + (radius2 + radius * Math.cos(nodenumber * theta + delta)) * Math.cos(theta + delta);
+                const y = centerY + (radius2 + radius * Math.cos(nodenumber * theta + delta)) * Math.sin(theta + delta);
                 if (angle === 0) {
                     context.moveTo(x, y);
                 } else {
@@ -63,21 +63,20 @@
                 }
             }
             context.closePath();
-            //context.fillStyle = 'blue';
-            //context.fill();
             context.stroke();
         }
 
         function drawCircle() {
+            context.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas before drawing
             const radius = parseInt(document.getElementById('radius').value, 10);
             const radius2 = 2 * parseInt(document.getElementById('radius').value, 10);
-            const nodenumber = parseInt(document.getElementById('nodenumber').value, 2);
+            const nodenumber = parseInt(document.getElementById('nodenumber').value, 10); // Change from base 2 to base 10
             const x = canvas.width / 2;
             const y = canvas.height / 2;
             const delta0 = (Math.PI / 15);
             for (let delta = 0; delta <= Math.PI * 2; delta += delta0) {
-            	drawCirclePolar(x, y, radius, radius2, nodenumber, delta);
-	    }
+                drawCirclePolar(x, y, radius, radius2, nodenumber, delta);
+            }
         }
     </script>
 </body>
diff --git a/circle22.html b/circle22.html
deleted file mode 100644
index 1e083c6..0000000
--- a/circle22.html
+++ /dev/null
@@ -1,84 +0,0 @@
-<!DOCTYPE html>
-<html lang="en">
-<head>
-    <meta charset="UTF-8">
-    <meta name="viewport" content="width=device-width, initial-scale=1.0">
-    <title>Draw Circles with Polar Coordinates</title>
-    <style>
-        body {
-            display: flex;
-            justify-content: center;
-            align-items: center;
-            height: 100vh;
-            margin: 0;
-            background-color: #f0f0f0;
-        }
-        canvas {
-            border: 1px solid black;
-        }
-        #controls {
-            position: absolute;
-            top: 20px;
-            left: 20px;
-        }
-    </style>
-</head>
-<body onload="drawCircle()">
-    <div id="controls">
-        <label for="radius">Radius: </label>
-        <input type="number" id="radius" value="50">
-        <label for="nodenumber">Node Number: </label>
-        <input type="number" id="nodenumber" value="2">
-        <button onclick="drawCircle()">Draw Circle</button>
-    </div>
-    <canvas id="canvas" width="800" height="600"></canvas>
-
-    <script>
-        const canvas = document.getElementById('canvas');
-        const context = canvas.getContext('2d');
-
-        canvas.addEventListener('click', (event) => {
-            const rect = canvas.getBoundingClientRect();
-            const x = event.clientX - rect.left;
-            const y = event.clientY - rect.top;
-            const radius = parseInt(document.getElementById('radius').value, 10);
-            const radius2 = 2 * parseInt(document.getElementById('radius').value, 10);
-            const nodenumber = parseInt(document.getElementById('nodenumber').value, 10); // Change from base 2 to base 10
-            const delta0 = (Math.PI / 15);
-            for (let delta = 0; delta <= Math.PI * 2; delta += delta0) {
-                drawCirclePolar(x, y, radius, radius2, nodenumber, delta);
-            }
-        });
-
-        function drawCirclePolar(centerX, centerY, radius, radius2, nodenumber, delta) {
-            context.beginPath();
-            for (let angle = 0; angle <= 360; angle++) {
-                const theta = angle * (Math.PI / 180);
-                const x = centerX + (radius2 + radius * Math.cos(nodenumber * theta + delta)) * Math.cos(theta + delta);
-                const y = centerY + (radius2 + radius * Math.cos(nodenumber * theta + delta)) * Math.sin(theta + delta);
-                if (angle === 0) {
-                    context.moveTo(x, y);
-                } else {
-                    context.lineTo(x, y);
-                }
-            }
-            context.closePath();
-            context.stroke();
-        }
-
-        function drawCircle() {
-            context.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas before drawing
-            const radius = parseInt(document.getElementById('radius').value, 10);
-            const radius2 = 2 * parseInt(document.getElementById('radius').value, 10);
-            const nodenumber = parseInt(document.getElementById('nodenumber').value, 10); // Change from base 2 to base 10
-            const x = canvas.width / 2;
-            const y = canvas.height / 2;
-            const delta0 = (Math.PI / 15);
-            for (let delta = 0; delta <= Math.PI * 2; delta += delta0) {
-                drawCirclePolar(x, y, radius, radius2, nodenumber, delta);
-            }
-        }
-    </script>
-</body>
-</html>
-

commit e45edd18dd48fb1c650c95f3e081ca0474f338f5
Author: tthtlc <htmldeveloper@gmail.com>
Date:   Sun Sep 8 10:24:58 2024 +0800

    modified:   circle2.html
    new file:   circle22.html
    modified:   dodecahedron1.html

diff --git a/circle2.html b/circle2.html
index c3c7a44..7e7f978 100644
--- a/circle2.html
+++ b/circle2.html
@@ -24,7 +24,7 @@
         }
     </style>
 </head>
-<body>
+<body onload="drawCircle()">
     <div id="controls">
         <label for="radius">Radius: </label>
         <input type="number" id="radius" value="50">
diff --git a/circle22.html b/circle22.html
new file mode 100644
index 0000000..1e083c6
--- /dev/null
+++ b/circle22.html
@@ -0,0 +1,84 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Draw Circles with Polar Coordinates</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+        #controls {
+            position: absolute;
+            top: 20px;
+            left: 20px;
+        }
+    </style>
+</head>
+<body onload="drawCircle()">
+    <div id="controls">
+        <label for="radius">Radius: </label>
+        <input type="number" id="radius" value="50">
+        <label for="nodenumber">Node Number: </label>
+        <input type="number" id="nodenumber" value="2">
+        <button onclick="drawCircle()">Draw Circle</button>
+    </div>
+    <canvas id="canvas" width="800" height="600"></canvas>
+
+    <script>
+        const canvas = document.getElementById('canvas');
+        const context = canvas.getContext('2d');
+
+        canvas.addEventListener('click', (event) => {
+            const rect = canvas.getBoundingClientRect();
+            const x = event.clientX - rect.left;
+            const y = event.clientY - rect.top;
+            const radius = parseInt(document.getElementById('radius').value, 10);
+            const radius2 = 2 * parseInt(document.getElementById('radius').value, 10);
+            const nodenumber = parseInt(document.getElementById('nodenumber').value, 10); // Change from base 2 to base 10
+            const delta0 = (Math.PI / 15);
+            for (let delta = 0; delta <= Math.PI * 2; delta += delta0) {
+                drawCirclePolar(x, y, radius, radius2, nodenumber, delta);
+            }
+        });
+
+        function drawCirclePolar(centerX, centerY, radius, radius2, nodenumber, delta) {
+            context.beginPath();
+            for (let angle = 0; angle <= 360; angle++) {
+                const theta = angle * (Math.PI / 180);
+                const x = centerX + (radius2 + radius * Math.cos(nodenumber * theta + delta)) * Math.cos(theta + delta);
+                const y = centerY + (radius2 + radius * Math.cos(nodenumber * theta + delta)) * Math.sin(theta + delta);
+                if (angle === 0) {
+                    context.moveTo(x, y);
+                } else {
+                    context.lineTo(x, y);
+                }
+            }
+            context.closePath();
+            context.stroke();
+        }
+
+        function drawCircle() {
+            context.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas before drawing
+            const radius = parseInt(document.getElementById('radius').value, 10);
+            const radius2 = 2 * parseInt(document.getElementById('radius').value, 10);
+            const nodenumber = parseInt(document.getElementById('nodenumber').value, 10); // Change from base 2 to base 10
+            const x = canvas.width / 2;
+            const y = canvas.height / 2;
+            const delta0 = (Math.PI / 15);
+            for (let delta = 0; delta <= Math.PI * 2; delta += delta0) {
+                drawCirclePolar(x, y, radius, radius2, nodenumber, delta);
+            }
+        }
+    </script>
+</body>
+</html>
+
diff --git a/dodecahedron1.html b/dodecahedron1.html
index adefa93..df55110 100644
--- a/dodecahedron1.html
+++ b/dodecahedron1.html
@@ -1,12 +1,22 @@
 <!DOCTYPE html>
 <html>
 <head>
+     <meta charset="UTF-8">
+     <meta name="viewport" content="width=device-width, initial-scale=1.0">
     <title>Rotating Dodecahedron</title>
-    <style>
-        canvas {
-            border: 1px solid black;
-        }
-    </style>
+     <style>
+         body {
+             display: flex;
+             justify-content: center;
+             align-items: center;
+             height: 100vh;
+             margin: 0;
+             background-color: #fff;
+         }
+         canvas {
+             border: 1px solid black;
+         }
+     </style>
 </head>
 <body>
     <canvas id="myCanvas" width="500" height="500"></canvas>

commit 7e6a32ba7bd08c64e1444a0fccbfec3695739845
Author: tthtlc <htmldeveloper@gmail.com>
Date:   Sun Sep 8 09:53:54 2024 +0800

    Changes to be committed:
    modified:   counter_rotating_sector.html
    new file:   hexagon_tessellation.html
    new file:   hexagon_tessellation.html.old
    new file:   koch_drawing.html
    new file:   recursive_fractal.html
    modified:   try5.html

diff --git a/counter_rotating_sector.html b/counter_rotating_sector.html
index ced0a92..a122924 100644
--- a/counter_rotating_sector.html
+++ b/counter_rotating_sector.html
@@ -1,8 +1,26 @@
 <!DOCTYPE html>
 <html>
+<head>
+     <meta charset="UTF-8">
+     <meta name="viewport" content="width=device-width, initial-scale=1.0">
+     <title>Canvas Pattern</title>
+     <style>
+         body {
+             display: flex;
+             justify-content: center;
+             align-items: center;
+             height: 100vh;
+             margin: 0;
+             background-color: #fff;
+         }
+         canvas {
+             border: 1px solid black;
+         }
+     </style>
+</head>
 <body>
 
-<canvas id="illusionCanvas" width="1200" height="1200"></canvas>
+<canvas id="illusionCanvas" width="500" height="500"></canvas>
 
 <script>
 // Function to draw a sector of a circle and radially cut it into half
diff --git a/hexagon_tessellation.html b/hexagon_tessellation.html
new file mode 100644
index 0000000..80dcc5e
--- /dev/null
+++ b/hexagon_tessellation.html
@@ -0,0 +1,79 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Hexagon Circle Tessellation</title>
+    <style>
+        canvas {
+            display: block;
+            margin: 0 auto;
+            background-color: #f0f0f0;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="hexCanvas"></canvas>
+
+    <script>
+        const canvas = document.getElementById('hexCanvas');
+        const ctx = canvas.getContext('2d');
+
+        // Resize canvas to fit window
+        canvas.width = window.innerWidth;
+        canvas.height = window.innerHeight;
+
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const maxRadius = Math.min(centerX, centerY) * 0.9;  // Circle boundary
+
+        function drawHexagon(x, y, size) {
+            ctx.beginPath();
+            for (let i = 0; i < 6; i++) {
+                const angle = Math.PI / 3 * i;
+                const dx = size * Math.cos(angle);
+                const dy = size * Math.sin(angle);
+                if (i === 0) {
+                    ctx.moveTo(x + dx, y + dy);
+                } else {
+                    ctx.lineTo(x + dx, y + dy);
+                }
+            }
+            ctx.closePath();
+            ctx.stroke();
+        }
+
+        function drawTessellation() {
+            const baseHexSize = 50;  // Largest size at the center
+            const hexHeight = Math.sqrt(3) * baseHexSize;
+            const hexWidth = 2 * baseHexSize;
+
+            // Loop to draw multiple rings of hexagons
+            for (let r = 0; r < maxRadius; r += baseHexSize * 1.5) {
+                const scaleFactor = 1 - (r / maxRadius);  // Reduce size as we move outward
+                const currentHexSize = baseHexSize * scaleFactor;
+                const currentHexHeight = Math.sqrt(3) * currentHexSize;
+                const currentHexWidth = 2 * currentHexSize;
+
+                // Calculate number of hexagons to fit in the current ring
+                const hexCount = Math.ceil((2 * Math.PI * r) / currentHexWidth);
+                
+                for (let i = 0; i < hexCount; i++) {
+                    const angle = (2 * Math.PI / hexCount) * i;
+                    const x = centerX + r * Math.cos(angle);
+                    const y = centerY + r * Math.sin(angle);
+
+                    // Ensure hexagons are inside the circle
+                    if (Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2)) + currentHexSize <= maxRadius) {
+                        drawHexagon(x, y, currentHexSize);
+                    }
+                }
+            }
+        }
+
+        // Draw the tessellation pattern
+        drawTessellation();
+    </script>
+</body>
+</html>
+
diff --git a/hexagon_tessellation.html.old b/hexagon_tessellation.html.old
new file mode 100644
index 0000000..6123111
--- /dev/null
+++ b/hexagon_tessellation.html.old
@@ -0,0 +1,63 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Hexagon Circle Tessellation</title>
+    <style>
+        canvas {
+            display: block;
+            margin: 0 auto;
+            background-color: #f0f0f0;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="hexCanvas"></canvas>
+
+    <script>
+        const canvas = document.getElementById('hexCanvas');
+        const ctx = canvas.getContext('2d');
+
+        // Resize canvas to fit window
+        canvas.width = window.innerWidth;
+        canvas.height = window.innerHeight;
+
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const maxRadius = Math.min(centerX, centerY) * 0.9;  // Circle boundary
+
+        function drawHexagon(x, y, size) {
+            ctx.beginPath();
+            for (let i = 0; i < 6; i++) {
+                const angle = Math.PI / 3 * i;
+                const dx = size * Math.cos(angle);
+                const dy = size * Math.sin(angle);
+                if (i === 0) {
+                    ctx.moveTo(x + dx, y + dy);
+                } else {
+                    ctx.lineTo(x + dx, y + dy);
+                }
+            }
+            ctx.closePath();
+            ctx.stroke();
+        }
+
+        function drawTessellation() {
+            const hexSize = 50; // Base hexagon size
+            const hexHeight = Math.sqrt(3) * hexSize;
+            let radius = 0;
+
+            // Loop to draw multiple rings of hexagons
+            for (let r = 0; r < maxRadius; r += hexSize * 1.5) {
+                let hexCount = Math.ceil(2 * Math.PI * r / hexHeight);
+                if (hexCount < 6) hexCount = 6;  // Minimum 6 hexagons in a ring
+
+                // Scale down the size of the hexagon as radius increases
+                let sizeFactor = 1 - (r / maxRadius);  // Decrease size with distance
+                let currentHexSize = hexSize * sizeFactor;
+
+                // Calculate angle and position each hexagon
+                for (let i = 0; i < hexCount; i++) {
+                    
+
diff --git a/koch_drawing.html b/koch_drawing.html
new file mode 100644
index 0000000..c840f4a
--- /dev/null
+++ b/koch_drawing.html
@@ -0,0 +1,83 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Koch Snowflake Fractal</title>
+    <style>
+        canvas {
+            border: 1px solid black;
+        }
+    </style>
+</head>
+<body>
+    <h1>Koch Snowflake Fractal</h1>
+    <label for="iterations">Recursion Depth: </label>
+    <input type="number" id="iterations" value="4" min="1" max="6">
+    <button onclick="drawFractal()">Generate Fractal</button>
+
+    <canvas id="fractalCanvas" width="500" height="500"></canvas>
+
+    <script>
+        function drawFractal() {
+            const iterations = parseInt(document.getElementById('iterations').value);
+            const canvas = document.getElementById('fractalCanvas');
+            const ctx = canvas.getContext('2d');
+
+            // Clear the canvas
+            ctx.clearRect(0, 0, canvas.width, canvas.height);
+
+            // Set starting points for Koch snowflake
+            const startX = 100;
+            const startY = 300;
+            const sideLength = 300;
+
+            // Function to draw a line
+            function drawLine(x1, y1, x2, y2) {
+                ctx.beginPath();
+                ctx.moveTo(x1, y1);
+                ctx.lineTo(x2, y2);
+                ctx.stroke();
+            }
+
+            // Recursive function to generate Koch curve
+            function koch(x1, y1, x2, y2, depth) {
+                if (depth === 0) {
+                    drawLine(x1, y1, x2, y2);
+                } else {
+                    const dx = (x2 - x1) / 3;
+                    const dy = (y2 - y1) / 3;
+
+                    // Calculate intermediate points
+                    const xA = x1 + dx;
+                    const yA = y1 + dy;
+                    const xB = x1 + 2 * dx;
+                    const yB = y1 + 2 * dy;
+                    const xC = (xA + xB) / 2 - (yB - yA) * Math.sqrt(3) / 2;
+                    const yC = (yA + yB) / 2 + (xB - xA) * Math.sqrt(3) / 2;
+
+                    // Recursively draw four segments
+                    koch(x1, y1, xA, yA, depth - 1);
+                    koch(xA, yA, xC, yC, depth - 1);
+                    koch(xC, yC, xB, yB, depth - 1);
+                    koch(xB, yB, x2, y2, depth - 1);
+                }
+            }
+
+            // Draw Koch snowflake with three sides
+            const x2 = startX + sideLength;
+            const y2 = startY;
+            const x3 = startX + sideLength / 2;
+            const y3 = startY - Math.sin(Math.PI / 3) * sideLength;
+
+            koch(startX, startY, x2, y2, iterations);
+            koch(x2, y2, x3, y3, iterations);
+            koch(x3, y3, startX, startY, iterations);
+        }
+
+        // Initial draw
+        drawFractal();
+    </script>
+</body>
+</html>
+
diff --git a/recursive_fractal.html b/recursive_fractal.html
new file mode 100644
index 0000000..97ab1ff
--- /dev/null
+++ b/recursive_fractal.html
@@ -0,0 +1,66 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Fractal Generator</title>
+    <style>
+        canvas {
+            border: 1px solid black;
+        }
+    </style>
+</head>
+<body>
+    <h1>Fractal Generator</h1>
+    <label for="depth">Recursion Depth: </label>
+    <input type="number" id="depth" value="5" min="1" max="10">
+    <label for="angle">Branch Angle (degrees): </label>
+    <input type="number" id="angle" value="25">
+    <button onclick="drawFractal()">Generate Fractal</button>
+
+    <canvas id="fractalCanvas" width="500" height="500"></canvas>
+
+    <script>
+        function drawFractal() {
+            const depth = parseInt(document.getElementById('depth').value);
+            const angle = parseFloat(document.getElementById('angle').value) * Math.PI / 180; // Convert to radians
+            const canvas = document.getElementById('fractalCanvas');
+            const ctx = canvas.getContext('2d');
+
+            // Clear the canvas
+            ctx.clearRect(0, 0, canvas.width, canvas.height);
+
+            // Start drawing from the bottom center of the canvas
+            const startX = canvas.width / 2;
+            const startY = canvas.height / 2 - 100;
+            const length = 100;
+
+            // Recursive function to draw the fractal
+            function drawBranch(x, y, len, angle, depth) {
+                if (depth === 0) return;
+
+                // Calculate end points of the branch
+                const endX = x + len * Math.cos(angle);
+                const endY = y - len * Math.sin(angle);
+
+                // Draw the branch
+                ctx.beginPath();
+                ctx.moveTo(x, y);
+                ctx.lineTo(endX, endY);
+                ctx.stroke();
+
+                // Recursively draw two smaller branches
+                drawBranch(endX, endY, len * 0.7, angle - Math.PI / 4, depth - 1);
+                drawBranch(endX, endY, len * 0.7, angle + Math.PI / 4, depth - 1);
+            }
+
+            // Start the recursion
+            drawBranch(startX, startY, length, -Math.PI / 2, depth);
+        }
+
+        // Initial draw
+        drawFractal();
+    </script>
+</body>
+</html>
+
diff --git a/try5.html b/try5.html
index 7c231d9..4651329 100644
--- a/try5.html
+++ b/try5.html
@@ -42,27 +42,35 @@
         let xdiff = 0.0;
         let ydiff = 0.0;
         let mouseDown = false;
+        let mouseEnabled = false;  // New flag to track if mouse movement is enabled
 
         // Event listeners for mouse interactions
         canvas.addEventListener('mousedown', (event) => {
-            mouseDown = true;
-            xdiff = event.clientX - yrot;
-            ydiff = event.clientY + xrot;
+            if (event.button === 0) {  // Only activate on left click
+                mouseEnabled = true;  // Enable mouse movement
+                mouseDown = true;
+                xdiff = event.clientX - yrot;
+                ydiff = event.clientY + xrot;
+            }
         });
 
         canvas.addEventListener('mousemove', (event) => {
-            if (mouseDown) {
+            if (mouseDown && mouseEnabled) {
                 yrot = event.clientX - xdiff;
                 xrot = event.clientY + ydiff;
             }
         });
 
-        canvas.addEventListener('mouseup', () => {
-            mouseDown = false;
+        canvas.addEventListener('mouseup', (event) => {
+            if (event.button === 0) {  // Only respond to left-click release
+                mouseDown = false;
+                mouseEnabled = false;  
+            }
         });
 
         canvas.addEventListener('mouseleave', () => {
             mouseDown = false;
+            mouseEnabled = false;  
         });
 
         // Vertex shader program

commit d0e23f725b1f9e99cfbaebca65d1baaecd244cdb
Author: tthtlc <htmldeveloper@gmail.com>
Date:   Tue Sep 3 00:12:30 2024 +0800

    new file:   dodecahedron.html
    new file:   dodecahedron1.html
    new file:   script.js

diff --git a/dodecahedron.html b/dodecahedron.html
new file mode 100644
index 0000000..653c740
--- /dev/null
+++ b/dodecahedron.html
@@ -0,0 +1,123 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Rotating Dodecahedron</title>
+    <style>
+        body, html {
+            margin: 0;
+            padding: 0;
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid #000;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="dodecahedronCanvas" width="600" height="600"></canvas>
+
+    <script>
+        const canvas = document.getElementById('dodecahedronCanvas');
+        const ctx = canvas.getContext('2d');
+
+        const vertices = [
+            [1.0, 1.0, 1.0], [1.0, 1.0, -1.0], [1.0, -1.0, 1.0], [1.0, -1.0, -1.0],
+            [-1.0, 1.0, 1.0], [-1.0, 1.0, -1.0], [-1.0, -1.0, 1.0], [-1.0, -1.0, -1.0],
+            [0.0, 0.618, 1.618], [0.0, 0.618, -1.618], [0.0, -0.618, 1.618], [0.0, -0.618, -1.618],
+            [0.618, 1.618, 0.0], [0.618, -1.618, 0.0], [-0.618, 1.618, 0.0], [-0.618, -1.618, 0.0],
+            [1.618, 0.0, 0.618], [1.618, 0.0, -0.618], [-1.618, 0.0, 0.618], [-1.618, 0.0, -0.618]
+        ];
+
+        const faces = [
+            [0, 8, 10, 2, 16], [1, 17, 3, 11, 9], [4, 14, 12, 0, 8], [5, 9, 1, 13, 15],
+            [6, 10, 8, 4, 18], [7, 19, 5, 15, 11], [2, 10, 6, 18, 16], [3, 17, 19, 7, 11],
+            [12, 14, 18, 6, 16], [13, 19, 17, 1, 9], [4, 14, 12, 0, 16], [5, 9, 13, 15, 7]
+        ];
+
+        let angleX = 0;
+        let angleY = 0;
+        let angleZ = 0;
+
+        // Randomly select rotation axis
+        const rotationAxis = [Math.random(), Math.random(), Math.random()];
+
+        function rotate([x, y, z], [u, v, w], angle) {
+            const cosA = Math.cos(angle);
+            const sinA = Math.sin(angle);
+            const dot = u * x + v * y + w * z;
+            const crossX = v * z - w * y;
+            const crossY = w * x - u * z;
+            const crossZ = u * y - v * x;
+
+            return [
+                cosA * x + sinA * crossX + (1 - cosA) * dot * u,
+                cosA * y + sinA * crossY + (1 - cosA) * dot * v,
+                cosA * z + sinA * crossZ + (1 - cosA) * dot * w
+            ];
+        }
+
+        function project([x, y, z]) {
+            const scale = 100;
+            const distance = 5;
+            const factor = scale / (distance + z);
+            return [
+                factor * x + canvas.width / 2,
+                -factor * y + canvas.height / 2,
+                z
+            ];
+        }
+
+        function drawFace(vertices) {
+            ctx.beginPath();
+            const [startX, startY] = vertices[0];
+            ctx.moveTo(startX, startY);
+
+            vertices.slice(1).forEach(([x, y]) => {
+                ctx.lineTo(x, y);
+            });
+
+            ctx.closePath();
+            ctx.stroke();
+        }
+
+        function drawDodecahedron() {
+            ctx.clearRect(0, 0, canvas.width, canvas.height);
+            ctx.strokeStyle = '#000';
+
+            const projectedFaces = faces.map(face => {
+                const projectedVertices = face.map(v => project(vertices[v]));
+                const averageZ = projectedVertices.reduce((acc, val) => acc + val[2], 0) / face.length;
+                return { vertices: projectedVertices, z: averageZ };
+            });
+
+            // Sort faces by depth
+            projectedFaces.sort((a, b) => b.z - a.z);
+
+            // Draw faces
+            projectedFaces.forEach(face => drawFace(face.vertices));
+        }
+
+        function animate() {
+            angleX += 0.01;
+            angleY += 0.01;
+            angleZ += 0.01;
+
+            vertices.forEach((vertex, i) => {
+                vertices[i] = rotate(vertex, rotationAxis, 0.01);
+            });
+
+            drawDodecahedron();
+            requestAnimationFrame(animate);
+        }
+
+        animate();
+    </script>
+</body>
+</html>
+
diff --git a/dodecahedron1.html b/dodecahedron1.html
new file mode 100644
index 0000000..adefa93
--- /dev/null
+++ b/dodecahedron1.html
@@ -0,0 +1,15 @@
+<!DOCTYPE html>
+<html>
+<head>
+    <title>Rotating Dodecahedron</title>
+    <style>
+        canvas {
+            border: 1px solid black;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="myCanvas" width="500" height="500"></canvas>
+    <script src="script.js"></script>
+</body>
+</html>
diff --git a/script.js b/script.js
new file mode 100644
index 0000000..d0051e0
--- /dev/null
+++ b/script.js
@@ -0,0 +1,86 @@
+const canvas = document.getElementById('myCanvas');
+const ctx = canvas.getContext('2d');
+
+// Dodecahedron vertices
+const vertices = [
+    [1, 1, 1],
+    [-1, -1, 1],
+    [-1, 1, -1],
+    [1, -1, -1],
+    [1, 1, -1],
+    [-1, -1, -1],
+    [-1, 1, 1],
+    [1, -1, 1],
+    [0, 1.618, 0],
+    [0, -1.618, 0],
+    [1.618, 0, 0],
+    [-1.618, 0, 0]
+];
+
+// Dodecahedron edges
+const edges = [
+    [0, 1], [0, 2], [0, 3], [0, 4], [1, 5], [1, 6], [2, 7],
+    [2, 8], [3, 9], [3, 10], [4, 11], [4, 8], [5, 9], [5, 10],
+    [6, 11], [6, 8], [7, 9], [7, 10], [8, 11]
+];
+
+// Projection matrix (orthographic)
+const projectionMatrix = [
+    1, 0, 0, 0,
+    0, 1, 0, 0,
+    0, 0, 1, 0,
+    0, 0, 0, 1
+];
+
+// Rotation matrix (initially identity)
+let rotationMatrix = [
+    1, 0, 0, 0,
+    0, 1, 0, 0,
+    0, 0, 1, 0,
+    0, 0, 0, 1
+];
+
+function rotate(angle, axis) {
+    // Implementation of rotation matrix based on axis and angle
+    // ...
+}
+
+function project(vertex) {
+    // Implementation of projection matrix multiplication
+    // ...
+}
+
+function drawDodecahedron() {
+    ctx.clearRect(0, 0, canvas.width, canvas.height);
+
+    // Apply rotation
+    rotationMatrix = rotate(0.01, [1, 0, 0]); // Example: Rotate around x-axis
+
+    for (let i = 0; i < edges.length; i++) {
+        const vertex1 = vertices[edges[i][0]];
+        const vertex2 = vertices[edges[i][1]];
+
+        // Project vertices
+        const projectedVertex1 = project(vertex1);
+        const projectedVertex2 = project(vertex2);
+
+        // Scale and translate to fit canvas
+        projectedVertex1[0] = (projectedVertex1[0] + 1) * canvas.width / 2;
+        projectedVertex1[1] = (projectedVertex1[1] + 1) * canvas.height / 2;
+        projectedVertex2[0] = (projectedVertex2[0] + 1) * canvas.width / 2;
+        projectedVertex2[1] = (projectedVertex2[1] + 1) * canvas.height / 2;
+
+        // Draw line
+        ctx.beginPath();
+        ctx.moveTo(projectedVertex1[0], projectedVertex1[1]);
+        ctx.lineTo(projectedVertex2[0], projectedVertex2[1]);
+        ctx.stroke();
+    }
+}
+
+function animate() {
+    drawDodecahedron();
+    requestAnimationFrame(animate);
+}
+
+animate();

commit ea134536e6b7af8a92175f66f145b1f6c6294ea6
Author: tthtlc <htmldeveloper@gmail.com>
Date:   Mon Sep 2 02:04:12 2024 +0800

    new file:   dot_forest.html
    new file:   dot_forest1.html
    modified:   index.html
    :   spoke_subspokes.html
    new file:   spoke_subspokes1.html
    new file:   spoke_subspokes2.html
    new file:   wave.css
    new file:   wave.html
    new file:   wave.js
    new file:   wave1.html
    new file:   wave1.js

diff --git a/dot_forest.html b/dot_forest.html
new file mode 100644
index 0000000..abc8d28
--- /dev/null
+++ b/dot_forest.html
@@ -0,0 +1,75 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Connected Dots using D3.js</title>
+    <script src="https://d3js.org/d3.v7.min.js"></script>
+</head>
+<body>
+    <svg width="800" height="800"></svg>
+
+    <script>
+        const width = 800;
+        const height = 800;
+        const numDots = 20;
+        const svg = d3.select("svg");
+
+        // Generate random dots
+        const nodes = d3.range(numDots).map(() => {
+            return {
+                x: Math.random() * width,
+                y: Math.random() * height
+            };
+        });
+
+        // Generate a Minimum Spanning Tree (MST) using Prim's algorithm
+        const links = [];
+        const visited = new Set();
+        visited.add(0);
+
+        while (visited.size < nodes.length) {
+            let minDist = Infinity;
+            let newLink = null;
+
+            visited.forEach(u => {
+                nodes.forEach((v, vi) => {
+                    if (!visited.has(vi)) {
+                        const dist = Math.hypot(nodes[u].x - v.x, nodes[u].y - v.y);
+                        if (dist < minDist) {
+                            minDist = dist;
+                            newLink = { source: u, target: vi };
+                        }
+                    }
+                });
+            });
+
+            links.push(newLink);
+            visited.add(newLink.target);
+        }
+
+        // Draw the links
+        svg.selectAll("line")
+            .data(links)
+            .enter()
+            .append("line")
+            .attr("x1", d => nodes[d.source].x)
+            .attr("y1", d => nodes[d.source].y)
+            .attr("x2", d => nodes[d.target].x)
+            .attr("y2", d => nodes[d.target].y)
+            .attr("stroke", "black")
+            .attr("stroke-width", 2);
+
+        // Draw the dots
+        svg.selectAll("circle")
+            .data(nodes)
+            .enter()
+            .append("circle")
+            .attr("cx", d => d.x)
+            .attr("cy", d => d.y)
+            .attr("r", 5)
+            .attr("fill", "red");
+    </script>
+</body>
+</html>
+
diff --git a/dot_forest1.html b/dot_forest1.html
new file mode 100644
index 0000000..ba32e2c
--- /dev/null
+++ b/dot_forest1.html
@@ -0,0 +1,134 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Interactive Connected Dots using D3.js</title>
+    <script src="https://d3js.org/d3.v7.min.js"></script>
+</head>
+<body>
+    <svg width="800" height="800"></svg>
+
+    <script>
+        const width = 800;
+        const height = 800;
+        const numDots = 20;
+        const svg = d3.select("svg");
+        const strength = 0.1; // Pulling strength of the connected dots
+
+        // Generate random dots
+        const nodes = d3.range(numDots).map(() => {
+            return {
+                x: Math.random() * width,
+                y: Math.random() * height,
+                vx: 0,
+                vy: 0
+            };
+        });
+
+        // Generate a Minimum Spanning Tree (MST) using Prim's algorithm
+        const links = [];
+        const visited = new Set();
+        visited.add(0);
+
+        while (visited.size < nodes.length) {
+            let minDist = Infinity;
+            let newLink = null;
+
+            visited.forEach(u => {
+                nodes.forEach((v, vi) => {
+                    if (!visited.has(vi)) {
+                        const dist = Math.hypot(nodes[u].x - v.x, nodes[u].y - v.y);
+                        if (dist < minDist) {
+                            minDist = dist;
+                            newLink = { source: u, target: vi };
+                        }
+                    }
+                });
+            });
+
+            links.push(newLink);
+            visited.add(newLink.target);
+        }
+
+        // Draw the links
+        const line = svg.selectAll("line")
+            .data(links)
+            .enter()
+            .append("line")
+            .attr("stroke", "black")
+            .attr("stroke-width", 2);
+
+        // Draw the dots
+        const circle = svg.selectAll("circle")
+            .data(nodes)
+            .enter()
+            .append("circle")
+            .attr("r", 5)
+            .attr("fill", "red")
+            .call(d3.drag()
+                .on("start", dragstarted)
+                .on("drag", dragged)
+                .on("end", dragended));
+
+        // Function to update the positions of dots and lines
+        function update() {
+            line
+                .attr("x1", d => nodes[d.source].x)
+                .attr("y1", d => nodes[d.source].y)
+                .attr("x2", d => nodes[d.target].x)
+                .attr("y2", d => nodes[d.target].y);
+
+            circle
+                .attr("cx", d => d.x)
+                .attr("cy", d => d.y);
+        }
+
+        // Drag functions
+        function dragstarted(event, d) {
+            d3.select(this).raise().attr("fill", "orange");
+        }
+
+        function dragged(event, d) {
+            // Update the dragged node's position
+            d.x = event.x;
+            d.y = event.y;
+
+            // Apply pulling effect to connected nodes
+            links.forEach(link => {
+                if (link.source === nodes.indexOf(d)) {
+                    pullNode(nodes[link.target], d);
+                } else if (link.target === nodes.indexOf(d)) {
+                    pullNode(nodes[link.source], d);
+                }
+            });
+
+            // Update the visualization
+            update();
+        }
+
+        function dragended(event, d) {
+            d3.select(this).attr("fill", "red");
+        }
+
+        function pullNode(target, dragged) {
+            const dx = dragged.x - target.x;
+            const dy = dragged.y - target.y;
+            target.vx += dx * strength;
+            target.vy += dy * strength;
+
+            // Update the position of the connected node
+            target.x += target.vx;
+            target.y += target.vy;
+
+            // Dampen the velocity to simulate friction
+            target.vx *= 0.9;
+            target.vy *= 0.9;
+        }
+
+        // Initial update of positions
+        update();
+    </script>
+</body>
+</html>
+
diff --git a/index.html b/index.html
index 82419be..47ee9fb 100644
--- a/index.html
+++ b/index.html
@@ -4,7 +4,7 @@
     <head>
         <meta charset="UTF-8">
         <meta name="viewport" content="width=device-width, initial-scale=1.0">
-        <title>Sansagraphics Museum</title>
+        <title>Sansagraphics Jems</title>
         <style>
             body { font-family: Arial, sans-serif; margin: 20px; }
             a { display: block; margin-bottom: 10px; text-decoration: none; color: blue; }
@@ -12,7 +12,7 @@
         </style>
     </head>
     <body>
-        <h1>Files</h1>
+        <h1>Sansagraphics Jems</h1>
     
             <a href="icosahedron_surface.html">icosahedron_surface.html</a>
             <iframe src="icosahedron_surface.html"></iframe>
diff --git a/spoke_subspokes.html b/spoke_subspokes.html
index 2975321..3a9cd31 100644
--- a/spoke_subspokes.html
+++ b/spoke_subspokes.html
@@ -11,22 +11,30 @@ const ctx = canvas.getContext('2d');
 const centerX = canvas.width / 2;
 const centerY = canvas.height / 2;
 const sector = 30;
-const maxRadius = Math.min(canvas.width, canvas.height) / 2;
+const maxRadius = Math.min(canvas.width, canvas.height) / 3;
+let rotationAngle = 0;
 
-for (let i = 0; i < sector; i++) {
-    let angle = (i / sector) * 2 * Math.PI;
-    let x = centerX + maxRadius * Math.cos(angle);
-    let y = centerY + maxRadius * Math.sin(angle);
+function drawScene() {
+    ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
 
-    ctx.strokeStyle = (i % 2 === 0) ? 'black' : 'blue';
-    ctx.lineWidth = 2;
+    for (let i = 0; i < sector; i++) {
+        let angle = (i / sector) * 2 * Math.PI + rotationAngle;
+        let x = centerX + maxRadius * Math.cos(angle);
+        let y = centerY + maxRadius * Math.sin(angle);
 
-    ctx.beginPath();
-    ctx.moveTo(centerX, centerY);
-    ctx.lineTo(x, y);
-    ctx.stroke();
+        ctx.strokeStyle = (i % 2 === 0) ? 'yellow' : 'blue';
+        ctx.lineWidth = 2;
 
-    draw_spoke(x, y, maxRadius/4, sector*3);
+        ctx.beginPath();
+        ctx.moveTo(centerX, centerY);
+        ctx.lineTo(x, y);
+        ctx.stroke();
+
+        draw_spoke(x, y, maxRadius/4, sector*3);
+    }
+
+    rotationAngle += 0.01; // Increment the rotation angle for animation
+    requestAnimationFrame(drawScene); // Request the next frame
 }
 
 function draw_spoke(myx, myy, radius, mysector) {
@@ -45,6 +53,9 @@ function draw_spoke(myx, myy, radius, mysector) {
     }
 }
 
+// Start the animation
+drawScene();
+
 </script>
 
 </body>
diff --git a/spoke_subspokes1.html b/spoke_subspokes1.html
new file mode 100644
index 0000000..0792198
--- /dev/null
+++ b/spoke_subspokes1.html
@@ -0,0 +1,81 @@
+<!DOCTYPE html>
+<html>
+<body>
+
+<canvas id="illusionCanvas" width="1200" height="1200"></canvas>
+
+<script>
+const canvas = document.getElementById('illusionCanvas');
+const ctx = canvas.getContext('2d');
+
+const centerX = canvas.width / 2;
+const centerY = canvas.height / 2;
+const sector = 30;
+const maxRadius = Math.min(canvas.width, canvas.height) / 3;
+let rotationAngle = 0;
+let isAnimating = true; // To control the animation state
+let mouseAngle = 0; // To store the angle based on mouse movement
+
+// Start the animation
+drawScene();
+
+canvas.addEventListener('click', () => {
+    isAnimating = !isAnimating; // Toggle the animation state on click
+});
+
+canvas.addEventListener('mousemove', (event) => {
+    const rect = canvas.getBoundingClientRect();
+    const mouseX = event.clientX - rect.left;
+    const mouseY = event.clientY - rect.top;
+    
+    // Calculate the angle between the mouse position and the center of the canvas
+    mouseAngle = Math.atan2(mouseY - centerY, mouseX - centerX);
+});
+
+function drawScene() {
+    ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
+
+    for (let i = 0; i < sector; i++) {
+        let angle = (i / sector) * 2 * Math.PI + rotationAngle + mouseAngle;
+        let x = centerX + maxRadius * Math.cos(angle);
+        let y = centerY + maxRadius * Math.sin(angle);
+
+        ctx.strokeStyle = (i % 2 === 0) ? 'yellow' : 'blue';
+        ctx.lineWidth = 2;
+
+        ctx.beginPath();
+        ctx.moveTo(centerX, centerY);
+        ctx.lineTo(x, y);
+        ctx.stroke();
+
+        draw_spoke(x, y, maxRadius / 4, sector * 3);
+    }
+
+    if (isAnimating) {
+        rotationAngle += 0.01; // Increment the rotation angle for animation
+    }
+
+    requestAnimationFrame(drawScene); // Request the next frame
+}
+
+function draw_spoke(myx, myy, radius, mysector) {
+    for (let i = 0; i < mysector; i++) {
+        let angle = (i / mysector) * 2 * Math.PI;
+
+        let x = myx + radius * Math.cos(angle);
+        let y = myy + radius * Math.sin(angle);
+
+        ctx.strokeStyle = (i % 2 === 0) ? 'black' : 'red';
+
+        ctx.beginPath();
+        ctx.moveTo(myx, myy);
+        ctx.lineTo(x, y);
+        ctx.stroke();
+    }
+}
+
+</script>
+
+</body>
+</html>
+
diff --git a/spoke_subspokes2.html b/spoke_subspokes2.html
new file mode 100644
index 0000000..a8b5c25
--- /dev/null
+++ b/spoke_subspokes2.html
@@ -0,0 +1,93 @@
+<!DOCTYPE html>
+<html>
+<body>
+
+<canvas id="illusionCanvas" width="1200" height="1200"></canvas>
+
+<script>
+const canvas = document.getElementById('illusionCanvas');
+const ctx = canvas.getContext('2d');
+
+const centerX = canvas.width / 2;
+const centerY = canvas.height / 2;
+const sector = 30;
+const maxRadius = Math.min(canvas.width, canvas.height) / 3;
+let rotationAngle = 0;
+let isAnimating = true; // To control the animation state
+let mouseAngle = 0; // To store the angle based on mouse movement
+let isMousePressed = false; // To track if the left mouse button is pressed
+
+// Start the animation
+drawScene();
+
+canvas.addEventListener('mousedown', (event) => {
+    if (event.button === 0) { // Check if the left mouse button is clicked
+        isMousePressed = true;
+        isAnimating = !isAnimating; // Toggle the animation state on click
+    }
+});
+
+canvas.addEventListener('mouseup', (event) => {
+    if (event.button === 0) { // Check if the left mouse button is released
+        isMousePressed = false;
+    }
+});
+
+canvas.addEventListener('mousemove', (event) => {
+    if (isMousePressed) { // Only respond to mouse movement if the left button is pressed
+        const rect = canvas.getBoundingClientRect();
+        const mouseX = event.clientX - rect.left;
+        const mouseY = event.clientY - rect.top;
+        
+        // Calculate the angle between the mouse position and the center of the canvas
+        mouseAngle = Math.atan2(mouseY - centerY, mouseX - centerX);
+    }
+});
+
+function drawScene() {
+    ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
+
+    for (let i = 0; i < sector; i++) {
+        let angle = (i / sector) * 2 * Math.PI + rotationAngle + mouseAngle;
+        let x = centerX + maxRadius * Math.cos(angle);
+        let y = centerY + maxRadius * Math.sin(angle);
+
+        ctx.strokeStyle = (i % 2 === 0) ? 'yellow' : 'blue';
+        ctx.lineWidth = 2;
+
+        ctx.beginPath();
+        ctx.moveTo(centerX, centerY);
+        ctx.lineTo(x, y);
+        ctx.stroke();
+
+        draw_spoke(x, y, maxRadius / 4, sector * 3);
+    }
+
+    if (isAnimating) {
+        rotationAngle += 0.01; // Increment the rotation angle for animation
+    }
+
+    requestAnimationFrame(drawScene); // Request the next frame
+}
+
+function draw_spoke(myx, myy, radius, mysector) {
+    for (let i = 0; i < mysector; i++) {
+        let angle = (i / mysector) * 2 * Math.PI;
+
+        let x = myx + radius * Math.cos(angle);
+        let y = myy + radius * Math.sin(angle);
+
+        ctx.strokeStyle = (i % 2 === 0) ? 'black' : 'red';
+
+        ctx.beginPath();
+        ctx.moveTo(myx, myy);
+        ctx.lineTo(x, y);
+        ctx.stroke();
+    }
+}
+
+</script>
+
+</body>
+</html>
+
diff --git a/wave.css b/wave.css
new file mode 100644
index 0000000..903ab5c
--- /dev/null
+++ b/wave.css
@@ -0,0 +1,14 @@
+
+body, html {
+    margin: 0;
+    padding: 0;
+    overflow: hidden;
+    height: 100%;
+    background-color: black;
+}
+
+canvas {
+    display: block;
+    filter: blur(5px);  /* Adds a blur effect */
+}
+
diff --git a/wave.html b/wave.html
new file mode 100644
index 0000000..2048624
--- /dev/null
+++ b/wave.html
@@ -0,0 +1,27 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Wave Animation</title>
+    <style>
+        body, html {
+            margin: 0;
+            padding: 0;
+            overflow: hidden;
+            height: 100%;
+            background-color: black;
+        }
+        canvas {
+            display: block;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="waveCanvas"></canvas>
+
+    <script src="wave.js"></script>
+</body>
+</html>
+
diff --git a/wave.js b/wave.js
new file mode 100644
index 0000000..9521129
--- /dev/null
+++ b/wave.js
@@ -0,0 +1,50 @@
+
+const canvas = document.getElementById('waveCanvas');
+const ctx = canvas.getContext('2d');
+canvas.width = window.innerWidth;
+canvas.height = window.innerHeight;
+
+const points = [];
+const pointCount = 100;
+const waveHeight = 100;
+const waveSpeed = 0.02;
+
+for (let i = 0; i < pointCount; i++) {
+    points.push({
+        x: (i / (pointCount - 1)) * canvas.width,
+        y: canvas.height / 2,
+        baseY: canvas.height / 2,
+        offset: Math.random() * 1000
+    });
+}
+
+function draw() {
+    ctx.clearRect(0, 0, canvas.width, canvas.height);
+    ctx.beginPath();
+    ctx.moveTo(points[0].x, points[0].y);
+
+    for (let i = 1; i < points.length; i++) {
+        const point = points[i];
+        point.y = point.baseY + Math.sin((i + waveSpeed * point.offset) * 0.05) * waveHeight;
+        ctx.lineTo(point.x, point.y);
+    }
+
+    ctx.strokeStyle = 'rgba(255, 165, 0, 0.8)';  // Orangish color
+    ctx.lineWidth = 2;
+    ctx.stroke();
+
+    requestAnimationFrame(draw);
+}
+
+draw();
+
+window.addEventListener('resize', () => {
+    canvas.width = window.innerWidth;
+    canvas.height = window.innerHeight;
+
+    for (let i = 0; i < points.length; i++) {
+        points[i].x = (i / (pointCount - 1)) * canvas.width;
+        points[i].baseY = canvas.height / 2;
+    }
+});
+
diff --git a/wave1.html b/wave1.html
new file mode 100644
index 0000000..7284ab6
--- /dev/null
+++ b/wave1.html
@@ -0,0 +1,28 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Wave Animation</title>
+    <style>
+        body, html {
+            margin: 0;
+            padding: 0;
+            overflow: hidden;
+            height: 100%;
+            background-color: black;
+        }
+        canvas {
+            display: block;
+            filter: blue(5px);
+        }
+    </style>
+</head>
+<body>
+    <canvas id="waveCanvas"></canvas>
+
+    <script src="wave1.js"></script>
+</body>
+</html>
+
diff --git a/wave1.js b/wave1.js
new file mode 100644
index 0000000..58f9d6d
--- /dev/null
+++ b/wave1.js
@@ -0,0 +1,62 @@
+const canvas = document.getElementById('waveCanvas');
+const ctx = canvas.getContext('2d');
+canvas.width = window.innerWidth;
+canvas.height = window.innerHeight;
+
+const waveCount = 3;  // Number of wave layers
+const pointsPerWave = 150;
+const waves = [];
+
+for (let j = 0; j < waveCount; j++) {
+    const points = [];
+    const waveHeight = 100 + Math.random() * 50;
+    const waveSpeed = 0.01 + Math.random() * 0.02;
+
+    for (let i = 0; i < pointsPerWave; i++) {
+        points.push({
+            x: (i / (pointsPerWave - 1)) * canvas.width,
+            y: canvas.height / 2,
+            baseY: canvas.height / 2,
+            offset: Math.random() * 1000
+        });
+    }
+
+    waves.push({ points, waveHeight, waveSpeed });
+}
+
+function draw() {
+    ctx.clearRect(0, 0, canvas.width, canvas.height);
+
+    waves.forEach((wave, index) => {
+        ctx.beginPath();
+        ctx.moveTo(wave.points[0].x, wave.points[0].y);
+
+        for (let i = 1; i < wave.points.length; i++) {
+            const point = wave.points[i];
+            point.y = point.baseY + Math.sin((i + wave.waveSpeed * point.offset) * 0.05) * wave.waveHeight;
+            ctx.lineTo(point.x, point.y);
+        }
+
+        // Change color and transparency for each wave
+        ctx.strokeStyle = `rgba(255, 165, 0, ${0.3 / (index + 1)})`;  // Orangish color with decreasing opacity
+        ctx.lineWidth = 3;
+        ctx.stroke();
+    });
+
+    requestAnimationFrame(draw);
+}
+
+draw();
+
+window.addEventListener('resize', () => {
+    canvas.width = window.innerWidth;
+    canvas.height = window.innerHeight;
+
+    waves.forEach(wave => {
+        for (let i = 0; i < wave.points.length; i++) {
+            wave.points[i].x = (i / (pointsPerWave - 1)) * canvas.width;
+            wave.points[i].baseY = canvas.height / 2;
+        }
+    });
+});
+

commit 36d58befac9d4a47698f7329ffdb883e315aea21
Author: Peter Teoh <htmldeveloper@gmail.com>
Date:   Sun Sep 1 18:37:29 2024 +0800

    modified:   index.html

diff --git a/index.html b/index.html
index df17be5..82419be 100644
--- a/index.html
+++ b/index.html
@@ -4,7 +4,7 @@
     <head>
         <meta charset="UTF-8">
         <meta name="viewport" content="width=device-width, initial-scale=1.0">
-        <title>Files List</title>
+        <title>Sansagraphics Museum</title>
         <style>
             body { font-family: Arial, sans-serif; margin: 20px; }
             a { display: block; margin-bottom: 10px; text-decoration: none; color: blue; }
@@ -14,206 +14,206 @@
     <body>
         <h1>Files</h1>
     
-            <a href="icosahedron_surface.html" target="frame_icosahedron_surface.html">icosahedron_surface.html</a>
-            <iframe name="frame_icosahedron_surface.html" src="icosahedron_surface.html"></iframe>
+            <a href="icosahedron_surface.html">icosahedron_surface.html</a>
+            <iframe src="icosahedron_surface.html"></iframe>
             
-            <a href="icosahedron_centroid.html" target="frame_icosahedron_centroid.html">icosahedron_centroid.html</a>
-            <iframe name="frame_icosahedron_centroid.html" src="icosahedron_centroid.html"></iframe>
+            <a href="icosahedron_centroid.html">icosahedron_centroid.html</a>
+            <iframe src="icosahedron_centroid.html"></iframe>
             
-            <a href="icosahedron.html" target="frame_icosahedron.html">icosahedron.html</a>
-            <iframe name="frame_icosahedron.html" src="icosahedron.html"></iframe>
+            <a href="icosahedron.html">icosahedron.html</a>
+            <iframe src="icosahedron.html"></iframe>
             
-            <a href="sphere.html" target="frame_sphere.html">sphere.html</a>
-            <iframe name="frame_sphere.html" src="sphere.html"></iframe>
+            <a href="sphere.html">sphere.html</a>
+            <iframe src="sphere.html"></iframe>
             
-            <a href="ovalellipse.html" target="frame_ovalellipse.html">ovalellipse.html</a>
-            <iframe name="frame_ovalellipse.html" src="ovalellipse.html"></iframe>
+            <a href="ovalellipse.html">ovalellipse.html</a>
+            <iframe src="ovalellipse.html"></iframe>
             
-            <a href="klein2_animation3.html" target="frame_klein2_animation3.html">klein2_animation3.html</a>
-            <iframe name="frame_klein2_animation3.html" src="klein2_animation3.html"></iframe>
+            <a href="klein2_animation3.html">klein2_animation3.html</a>
+            <iframe src="klein2_animation3.html"></iframe>
             
-            <a href="klein2_animation.html" target="frame_klein2_animation.html">klein2_animation.html</a>
-            <iframe name="frame_klein2_animation.html" src="klein2_animation.html"></iframe>
+            <a href="klein2_animation.html">klein2_animation.html</a>
+            <iframe src="klein2_animation.html"></iframe>
             
-            <a href="klein3.html" target="frame_klein3.html">klein3.html</a>
-            <iframe name="frame_klein3.html" src="klein3.html"></iframe>
+            <a href="klein3.html">klein3.html</a>
+            <iframe src="klein3.html"></iframe>
             
-            <a href="torus.html" target="frame_torus.html">torus.html</a>
-            <iframe name="frame_torus.html" src="torus.html"></iframe>
+            <a href="torus.html">torus.html</a>
+            <iframe src="torus.html"></iframe>
             
-            <a href="line_drawing.html" target="frame_line_drawing.html">line_drawing.html</a>
-            <iframe name="frame_line_drawing.html" src="line_drawing.html"></iframe>
+            <a href="line_drawing.html">line_drawing.html</a>
+            <iframe src="line_drawing.html"></iframe>
             
-            <a href="mobius.html" target="frame_mobius.html">mobius.html</a>
-            <iframe name="frame_mobius.html" src="mobius.html"></iframe>
+            <a href="mobius.html">mobius.html</a>
+            <iframe src="mobius.html"></iframe>
             
-            <a href="moving_square2.html" target="frame_moving_square2.html">moving_square2.html</a>
-            <iframe name="frame_moving_square2.html" src="moving_square2.html"></iframe>
+            <a href="moving_square2.html">moving_square2.html</a>
+            <iframe src="moving_square2.html"></iframe>
             
-            <a href="moving_square3.html" target="frame_moving_square3.html">moving_square3.html</a>
-            <iframe name="frame_moving_square3.html" src="moving_square3.html"></iframe>
+            <a href="moving_square3.html">moving_square3.html</a>
+            <iframe src="moving_square3.html"></iframe>
             
-            <a href="moving_square4.html" target="frame_moving_square4.html">moving_square4.html</a>
-            <iframe name="frame_moving_square4.html" src="moving_square4.html"></iframe>
+            <a href="moving_square4.html">moving_square4.html</a>
+            <iframe src="moving_square4.html"></iframe>
             
-            <a href="moving_square5.html" target="frame_moving_square5.html">moving_square5.html</a>
-            <iframe name="frame_moving_square5.html" src="moving_square5.html"></iframe>
+            <a href="moving_square5.html">moving_square5.html</a>
+            <iframe src="moving_square5.html"></iframe>
             
-            <a href="moving_square.html" target="frame_moving_square.html">moving_square.html</a>
-            <iframe name="frame_moving_square.html" src="moving_square.html"></iframe>
+            <a href="moving_square.html">moving_square.html</a>
+            <iframe src="moving_square.html"></iframe>
             
-            <a href="quart_motion.html" target="frame_quart_motion.html">quart_motion.html</a>
-            <iframe name="frame_quart_motion.html" src="quart_motion.html"></iframe>
+            <a href="quart_motion.html">quart_motion.html</a>
+            <iframe src="quart_motion.html"></iframe>
             
-            <a href="rotating_sector.html" target="frame_rotating_sector.html">rotating_sector.html</a>
-            <iframe name="frame_rotating_sector.html" src="rotating_sector.html"></iframe>
+            <a href="rotating_sector.html">rotating_sector.html</a>
+            <iframe src="rotating_sector.html"></iframe>
             
-            <a href="rotating_spiral.html" target="frame_rotating_spiral.html">rotating_spiral.html</a>
-            <iframe name="frame_rotating_spiral.html" src="rotating_spiral.html"></iframe>
+            <a href="rotating_spiral.html">rotating_spiral.html</a>
+            <iframe src="rotating_spiral.html"></iframe>
             
-            <a href="rotating_spoke.html" target="frame_rotating_spoke.html">rotating_spoke.html</a>
-            <iframe name="frame_rotating_spoke.html" src="rotating_spoke.html"></iframe>
+            <a href="rotating_spoke.html">rotating_spoke.html</a>
+            <iframe src="rotating_spoke.html"></iframe>
             
-            <a href="sinsoidal5.html" target="frame_sinsoidal5.html">sinsoidal5.html</a>
-            <iframe name="frame_sinsoidal5.html" src="sinsoidal5.html"></iframe>
+            <a href="sinsoidal5.html">sinsoidal5.html</a>
+            <iframe src="sinsoidal5.html"></iframe>
             
-            <a href="sinusoidal.html" target="frame_sinusoidal.html">sinusoidal.html</a>
-            <iframe name="frame_sinusoidal.html" src="sinusoidal.html"></iframe>
+            <a href="sinusoidal.html">sinusoidal.html</a>
+            <iframe src="sinusoidal.html"></iframe>
             
-            <a href="solid_torus1.html" target="frame_solid_torus1.html">solid_torus1.html</a>
-            <iframe name="frame_solid_torus1.html" src="solid_torus1.html"></iframe>
+            <a href="solid_torus1.html">solid_torus1.html</a>
+            <iframe src="solid_torus1.html"></iframe>
             
-            <a href="special.html" target="frame_special.html">special.html</a>
-            <iframe name="frame_special.html" src="special.html"></iframe>
+            <a href="special.html">special.html</a>
+            <iframe src="special.html"></iframe>
             
-            <a href="spherical_sinusoid1.html" target="frame_spherical_sinusoid1.html">spherical_sinusoid1.html</a>
-            <iframe name="frame_spherical_sinusoid1.html" src="spherical_sinusoid1.html"></iframe>
+            <a href="spherical_sinusoid1.html">spherical_sinusoid1.html</a>
+            <iframe src="spherical_sinusoid1.html"></iframe>
             
-            <a href="spherical_sinusoid3.html" target="frame_spherical_sinusoid3.html">spherical_sinusoid3.html</a>
-            <iframe name="frame_spherical_sinusoid3.html" src="spherical_sinusoid3.html"></iframe>
+            <a href="spherical_sinusoid3.html">spherical_sinusoid3.html</a>
+            <iframe src="spherical_sinusoid3.html"></iframe>
             
-            <a href="spherical_sinusoid.html" target="frame_spherical_sinusoid.html">spherical_sinusoid.html</a>
-            <iframe name="frame_spherical_sinusoid.html" src="spherical_sinusoid.html"></iframe>
+            <a href="spherical_sinusoid.html">spherical_sinusoid.html</a>
+            <iframe src="spherical_sinusoid.html"></iframe>
             
-            <a href="spiral.html" target="frame_spiral.html">spiral.html</a>
-            <iframe name="frame_spiral.html" src="spiral.html"></iframe>
+            <a href="spiral.html">spiral.html</a>
+            <iframe src="spiral.html"></iframe>
             
-            <a href="spoke_subspokes.html" target="frame_spoke_subspokes.html">spoke_subspokes.html</a>
-            <iframe name="frame_spoke_subspokes.html" src="spoke_subspokes.html"></iframe>
+            <a href="spoke_subspokes.html">spoke_subspokes.html</a>
+            <iframe src="spoke_subspokes.html"></iframe>
             
-            <a href="static_concentric.html" target="frame_static_concentric.html">static_concentric.html</a>
-            <iframe name="frame_static_concentric.html" src="static_concentric.html"></iframe>
+            <a href="static_concentric.html">static_concentric.html</a>
+            <iframe src="static_concentric.html"></iframe>
             
-            <a href="concentric.html" target="frame_concentric.html">concentric.html</a>
-            <iframe name="frame_concentric.html" src="concentric.html"></iframe>
+            <a href="concentric.html">concentric.html</a>
+            <iframe src="concentric.html"></iframe>
             
-            <a href="three_petal.html" target="frame_three_petal.html">three_petal.html</a>
-            <iframe name="frame_three_petal.html" src="three_petal.html"></iframe>
+            <a href="three_petal.html">three_petal.html</a>
+            <iframe src="three_petal.html"></iframe>
             
-            <a href="torus2.html" target="frame_torus2.html">torus2.html</a>
-            <iframe name="frame_torus2.html" src="torus2.html"></iframe>
+            <a href="torus2.html">torus2.html</a>
+            <iframe src="torus2.html"></iframe>
             
-            <a href="triple_motion.html" target="frame_triple_motion.html">triple_motion.html</a>
-            <iframe name="frame_triple_motion.html" src="triple_motion.html"></iframe>
+            <a href="triple_motion.html">triple_motion.html</a>
+            <iframe src="triple_motion.html"></iframe>
             
-            <a href="try5.html" target="frame_try5.html">try5.html</a>
-            <iframe name="frame_try5.html" src="try5.html"></iframe>
+            <a href="try5.html">try5.html</a>
+            <iframe src="try5.html"></iframe>
             
-            <a href="two_ellipse.html" target="frame_two_ellipse.html">two_ellipse.html</a>
-            <iframe name="frame_two_ellipse.html" src="two_ellipse.html"></iframe>
+            <a href="two_ellipse.html">two_ellipse.html</a>
+            <iframe src="two_ellipse.html"></iframe>
             
-            <a href="two_petal.html" target="frame_two_petal.html">two_petal.html</a>
-            <iframe name="frame_two_petal.html" src="two_petal.html"></iframe>
+            <a href="two_petal.html">two_petal.html</a>
+            <iframe src="two_petal.html"></iframe>
             
-            <a href="double_motion.html" target="frame_double_motion.html">double_motion.html</a>
-            <iframe name="frame_double_motion.html" src="double_motion.html"></iframe>
+            <a href="double_motion.html">double_motion.html</a>
+            <iframe src="double_motion.html"></iframe>
             
-            <a href="drawsector.html" target="frame_drawsector.html">drawsector.html</a>
-            <iframe name="frame_drawsector.html" src="drawsector.html"></iframe>
+            <a href="drawsector.html">drawsector.html</a>
+            <iframe src="drawsector.html"></iframe>
             
-            <a href="ellipse2.html" target="frame_ellipse2.html">ellipse2.html</a>
-            <iframe name="frame_ellipse2.html" src="ellipse2.html"></iframe>
+            <a href="ellipse2.html">ellipse2.html</a>
+            <iframe src="ellipse2.html"></iframe>
             
-            <a href="ellipse3.html" target="frame_ellipse3.html">ellipse3.html</a>
-            <iframe name="frame_ellipse3.html" src="ellipse3.html"></iframe>
+            <a href="ellipse3.html">ellipse3.html</a>
+            <iframe src="ellipse3.html"></iframe>
             
-            <a href="ellipse4.html" target="frame_ellipse4.html">ellipse4.html</a>
-            <iframe name="frame_ellipse4.html" src="ellipse4.html"></iframe>
+            <a href="ellipse4.html">ellipse4.html</a>
+            <iframe src="ellipse4.html"></iframe>
             
-            <a href="ellipsical_line.html" target="frame_ellipsical_line.html">ellipsical_line.html</a>
-            <iframe name="frame_ellipsical_line.html" src="ellipsical_line.html"></iframe>
+            <a href="ellipsical_line.html">ellipsical_line.html</a>
+            <iframe src="ellipsical_line.html"></iframe>
             
-            <a href="ellipsical_line_rotate.html" target="frame_ellipsical_line_rotate.html">ellipsical_line_rotate.html</a>
-            <iframe name="frame_ellipsical_line_rotate.html" src="ellipsical_line_rotate.html"></iframe>
+            <a href="ellipsical_line_rotate.html">ellipsical_line_rotate.html</a>
+            <iframe src="ellipsical_line_rotate.html"></iframe>
             
-            <a href="figure_eight2.html" target="frame_figure_eight2.html">figure_eight2.html</a>
-            <iframe name="frame_figure_eight2.html" src="figure_eight2.html"></iframe>
+            <a href="figure_eight2.html">figure_eight2.html</a>
+            <iframe src="figure_eight2.html"></iframe>
             
-            <a href="figure_eight.html" target="frame_figure_eight.html">figure_eight.html</a>
-            <iframe name="frame_figure_eight.html" src="figure_eight.html"></iframe>
+            <a href="figure_eight.html">figure_eight.html</a>
+            <iframe src="figure_eight.html"></iframe>
             
-            <a href="five_rotate_spoke.html" target="frame_five_rotate_spoke.html">five_rotate_spoke.html</a>
-            <iframe name="frame_five_rotate_spoke.html" src="five_rotate_spoke.html"></iframe>
+            <a href="five_rotate_spoke.html">five_rotate_spoke.html</a>
+            <iframe src="five_rotate_spoke.html"></iframe>
             
-            <a href="five_rotate_spoke_sector.html" target="frame_five_rotate_spoke_sector.html">five_rotate_spoke_sector.html</a>
-            <iframe name="frame_five_rotate_spoke_sector.html" src="five_rotate_spoke_sector.html"></iframe>
+            <a href="five_rotate_spoke_sector.html">five_rotate_spoke_sector.html</a>
+            <iframe src="five_rotate_spoke_sector.html"></iframe>
             
-            <a href="four_petal_double.html" target="frame_four_petal_double.html">four_petal_double.html</a>
-            <iframe name="frame_four_petal_double.html" src="four_petal_double.html"></iframe>
+            <a href="four_petal_double.html">four_petal_double.html</a>
+            <iframe src="four_petal_double.html"></iframe>
             
-            <a href="four_petal.html" target="frame_four_petal.html">four_petal.html</a>
-            <iframe name="frame_four_petal.html" src="four_petal.html"></iframe>
+            <a href="four_petal.html">four_petal.html</a>
+            <iframe src="four_petal.html"></iframe>
             
-            <a href="four_petal_rotate.html" target="frame_four_petal_rotate.html">four_petal_rotate.html</a>
-            <iframe name="frame_four_petal_rotate.html" src="four_petal_rotate.html"></iframe>
+            <a href="four_petal_rotate.html">four_petal_rotate.html</a>
+            <iframe src="four_petal_rotate.html"></iframe>
             
-            <a href="klein2_animation2.html" target="frame_klein2_animation2.html">klein2_animation2.html</a>
-            <iframe name="frame_klein2_animation2.html" src="klein2_animation2.html"></iframe>
+            <a href="klein2_animation2.html">klein2_animation2.html</a>
+            <iframe src="klein2_animation2.html"></iframe>
             
-            <a href="chasing_square1.html" target="frame_chasing_square1.html">chasing_square1.html</a>
-            <iframe name="frame_chasing_square1.html" src="chasing_square1.html"></iframe>
+            <a href="chasing_square1.html">chasing_square1.html</a>
+            <iframe src="chasing_square1.html"></iframe>
             
-            <a href="chasing_square2.html" target="frame_chasing_square2.html">chasing_square2.html</a>
-            <iframe name="frame_chasing_square2.html" src="chasing_square2.html"></iframe>
+            <a href="chasing_square2.html">chasing_square2.html</a>
+            <iframe src="chasing_square2.html"></iframe>
             
-            <a href="chasing_square.html" target="frame_chasing_square.html">chasing_square.html</a>
-            <iframe name="frame_chasing_square.html" src="chasing_square.html"></iframe>
+            <a href="chasing_square.html">chasing_square.html</a>
+            <iframe src="chasing_square.html"></iframe>
             
-            <a href="circle2.html" target="frame_circle2.html">circle2.html</a>
-            <iframe name="frame_circle2.html" src="circle2.html"></iframe>
+            <a href="circle2.html">circle2.html</a>
+            <iframe src="circle2.html"></iframe>
             
-            <a href="circle_color.html" target="frame_circle_color.html">circle_color.html</a>
-            <iframe name="frame_circle_color.html" src="circle_color.html"></iframe>
+            <a href="circle_color.html">circle_color.html</a>
+            <iframe src="circle_color.html"></iframe>
             
-            <a href="circle.html" target="frame_circle.html">circle.html</a>
-            <iframe name="frame_circle.html" src="circle.html"></iframe>
+            <a href="circle.html">circle.html</a>
+            <iframe src="circle.html"></iframe>
             
-            <a href="counter_rotating_sector.html" target="frame_counter_rotating_sector.html">counter_rotating_sector.html</a>
-            <iframe name="frame_counter_rotating_sector.html" src="counter_rotating_sector.html"></iframe>
+            <a href="counter_rotating_sector.html">counter_rotating_sector.html</a>
+            <iframe src="counter_rotating_sector.html"></iframe>
             
-            <a href="css_3dcube.html" target="frame_css_3dcube.html">css_3dcube.html</a>
-            <iframe name="frame_css_3dcube.html" src="css_3dcube.html"></iframe>
+            <a href="css_3dcube.html">css_3dcube.html</a>
+            <iframe src="css_3dcube.html"></iframe>
             
-            <a href="css_circle1.html" target="frame_css_circle1.html">css_circle1.html</a>
-            <iframe name="frame_css_circle1.html" src="css_circle1.html"></iframe>
+            <a href="css_circle1.html">css_circle1.html</a>
+            <iframe src="css_circle1.html"></iframe>
             
-            <a href="css_circle.html" target="frame_css_circle.html">css_circle.html</a>
-            <iframe name="frame_css_circle.html" src="css_circle.html"></iframe>
+            <a href="css_circle.html">css_circle.html</a>
+            <iframe src="css_circle.html"></iframe>
             
-            <a href="d3_graph.html" target="frame_d3_graph.html">d3_graph.html</a>
-            <iframe name="frame_d3_graph.html" src="d3_graph.html"></iframe>
+            <a href="d3_graph.html">d3_graph.html</a>
+            <iframe src="d3_graph.html"></iframe>
             
-            <a href="double3.html" target="frame_double3.html">double3.html</a>
-            <iframe name="frame_double3.html" src="double3.html"></iframe>
+            <a href="double3.html">double3.html</a>
+            <iframe src="double3.html"></iframe>
             
-            <a href="double4.html" target="frame_double4.html">double4.html</a>
-            <iframe name="frame_double4.html" src="double4.html"></iframe>
+            <a href="double4.html">double4.html</a>
+            <iframe src="double4.html"></iframe>
             
-            <a href="double5.html" target="frame_double5.html">double5.html</a>
-            <iframe name="frame_double5.html" src="double5.html"></iframe>
+            <a href="double5.html">double5.html</a>
+            <iframe src="double5.html"></iframe>
             
-            <a href="double.html" target="frame_double.html">double.html</a>
-            <iframe name="frame_double.html" src="double.html"></iframe>
+            <a href="double.html">double.html</a>
+            <iframe src="double.html"></iframe>
             
     </body>
     </html>

commit c78d967cd4d92a210d56254370a7a5ba5ca2e3e6
Author: tthtlc <htmldeveloper@gmail.com>
Date:   Sun Sep 1 15:03:25 2024 +0800

    modified:   double_ellipse.html
    new file:   ellipse_circle.html
    new file:   ellipse_circle1.html
    new file:   ellipse_circle2.html

diff --git a/double_ellipse.html b/double_ellipse.html
index 6ac69c3..5328237 100644
--- a/double_ellipse.html
+++ b/double_ellipse.html
@@ -92,7 +92,7 @@
             drawConnectingLines(ellipse1Points, ellipse2Points);
 
             // Redraw the pattern every 2 seconds with new random transformations
-            setTimeout(drawDynamicEllipses, 2000);
+            setTimeout(drawDynamicEllipses, 200);
         }
 
         drawDynamicEllipses();
diff --git a/ellipse_circle.html b/ellipse_circle.html
new file mode 100644
index 0000000..939f525
--- /dev/null
+++ b/ellipse_circle.html
@@ -0,0 +1,82 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Moving Tangential Ellipse</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #333;
+        }
+        canvas {
+            border: 1px solid black;
+            background-color: #333;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="tangentialEllipseCanvas" width="800" height="800"></canvas>
+    <script>
+        const canvas = document.getElementById('tangentialEllipseCanvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const circleRadius = 200;
+        const ellipseRadiusX = 100;
+        const ellipseRadiusY = 50;
+        const speed = 0.01; // Speed of the ellipse moving along the circle
+        const rotationSpeed = 0.005; // Speed of ellipse rotation
+
+        let angle = 0;
+        let ellipseAngle = 0;
+
+        function drawCircle() {
+            ctx.beginPath();
+            ctx.arc(centerX, centerY, circleRadius, 0, 2 * Math.PI);
+            ctx.strokeStyle = '#ffffff';
+            ctx.lineWidth = 2;
+            ctx.stroke();
+        }
+
+        function drawEllipse(x, y, angle) {
+            ctx.save();
+            ctx.translate(x, y);
+            ctx.rotate(angle);
+            ctx.beginPath();
+            ctx.ellipse(0, 0, ellipseRadiusX, ellipseRadiusY, 0, 0, 2 * Math.PI);
+            ctx.strokeStyle = '#00ff00';
+            ctx.lineWidth = 2;
+            ctx.stroke();
+            ctx.restore();
+        }
+
+        function animate() {
+            ctx.clearRect(0, 0, canvas.width, canvas.height);
+
+            drawCircle();
+
+            // Calculate the position of the ellipse on the circle's circumference
+            const ellipseX = centerX + circleRadius * Math.cos(angle);
+            const ellipseY = centerY + circleRadius * Math.sin(angle);
+
+            // Draw the ellipse at the calculated position with the current rotation angle
+            drawEllipse(ellipseX, ellipseY, ellipseAngle);
+
+            // Update the angles for the next frame
+            angle += speed;
+            ellipseAngle += rotationSpeed;
+
+            // Request the next frame
+            requestAnimationFrame(animate);
+        }
+
+        animate();
+    </script>
+</body>
+</html>
+
diff --git a/ellipse_circle1.html b/ellipse_circle1.html
new file mode 100644
index 0000000..d5aa82f
--- /dev/null
+++ b/ellipse_circle1.html
@@ -0,0 +1,83 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Tangential Ellipse Animation</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #333;
+        }
+        canvas {
+            border: 1px solid black;
+            background-color: #333;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="tangentialEllipseCanvas" width="800" height="800"></canvas>
+    <script>
+        const canvas = document.getElementById('tangentialEllipseCanvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const circleRadius = 200;
+        const ellipseRadiusX = 100;
+        const ellipseRadiusY = 50;
+        const speed = 0.01; // Speed of the ellipse moving along the circle
+        const rotationSpeed = 0.005; // Speed of ellipse rotation
+
+        let angle = 0;
+        let ellipseAngle = 0;
+
+        function drawCircle() {
+            ctx.beginPath();
+            ctx.arc(centerX, centerY, circleRadius, 0, 2 * Math.PI);
+            ctx.strokeStyle = '#ffffff';
+            ctx.lineWidth = 2;
+            ctx.stroke();
+        }
+
+        function drawEllipse(x, y, angle) {
+            ctx.save();
+            ctx.translate(x, y);
+            ctx.rotate(angle);
+            ctx.beginPath();
+            ctx.ellipse(0, 0, ellipseRadiusX, ellipseRadiusY, 0, 0, 2 * Math.PI);
+            ctx.strokeStyle = '#00ff00';
+            ctx.lineWidth = 2;
+            ctx.stroke();
+            ctx.restore();
+        }
+
+        function animate() {
+            ctx.clearRect(0, 0, canvas.width, canvas.height);
+
+            drawCircle();
+
+            // Calculate the position of the ellipse on the circle's circumference
+            const ellipseDistance = Math.sqrt(Math.pow(ellipseRadiusX * Math.cos(ellipseAngle), 2) + Math.pow(ellipseRadiusY * Math.sin(ellipseAngle), 2));
+            const ellipseX = centerX + (circleRadius + ellipseDistance) * Math.cos(angle);
+            const ellipseY = centerY + (circleRadius + ellipseDistance) * Math.sin(angle);
+
+            // Draw the ellipse at the calculated position with the current rotation angle
+            drawEllipse(ellipseX, ellipseY, ellipseAngle);
+
+            // Update the angles for the next frame
+            angle += speed;
+            ellipseAngle += rotationSpeed;
+
+            // Request the next frame
+            requestAnimationFrame(animate);
+        }
+
+        animate();
+    </script>
+</body>
+</html>
+
diff --git a/ellipse_circle2.html b/ellipse_circle2.html
new file mode 100644
index 0000000..e8febaf
--- /dev/null
+++ b/ellipse_circle2.html
@@ -0,0 +1,124 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Tangential Ellipse with Lines</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #333;
+        }
+        canvas {
+            border: 1px solid black;
+            background-color: #333;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="tangentialEllipseCanvas" width="800" height="800"></canvas>
+    <script>
+        const canvas = document.getElementById('tangentialEllipseCanvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const circleRadius = 200;
+        const ellipseRadiusX = 100;
+        const ellipseRadiusY = 50;
+        const numPoints = 60; // Number of points on both the ellipse and the circle
+        const speed = 0.01; // Speed of the ellipse moving along the circle
+        const rotationSpeed = 0.005; // Speed of ellipse rotation
+
+        let angle = 0;
+        let ellipseAngle = 0;
+
+        function drawCircle() {
+            ctx.beginPath();
+            ctx.arc(centerX, centerY, circleRadius, 0, 2 * Math.PI);
+            ctx.strokeStyle = '#ffffff';
+            ctx.lineWidth = 2;
+            ctx.stroke();
+        }
+
+        function drawEllipse(x, y, angle) {
+            ctx.save();
+            ctx.translate(x, y);
+            ctx.rotate(angle);
+            ctx.beginPath();
+            ctx.ellipse(0, 0, ellipseRadiusX, ellipseRadiusY, 0, 0, 2 * Math.PI);
+            ctx.strokeStyle = '#00ff00';
+            ctx.lineWidth = 2;
+            ctx.stroke();
+            ctx.restore();
+        }
+
+        function generatePointsOnCircle(radius, centerX, centerY, numPoints) {
+            const points = [];
+            for (let i = 0; i < numPoints; i++) {
+                const angle = (i / numPoints) * 2 * Math.PI;
+                const x = centerX + radius * Math.cos(angle);
+                const y = centerY + radius * Math.sin(angle);
+                points.push({ x, y });
+            }
+            return points;
+        }
+
+        function generatePointsOnEllipse(centerX, centerY, radiusX, radiusY, numPoints, rotationAngle) {
+            const points = [];
+            for (let i = 0; i < numPoints; i++) {
+                const angle = (i / numPoints) * 2 * Math.PI;
+                const x = centerX + radiusX * Math.cos(angle) * Math.cos(rotationAngle) - radiusY * Math.sin(angle) * Math.sin(rotationAngle);
+                const y = centerY + radiusX * Math.cos(angle) * Math.sin(rotationAngle) + radiusY * Math.sin(angle) * Math.cos(rotationAngle);
+                points.push({ x, y });
+            }
+            return points;
+        }
+
+        function drawConnectingLines(points1, points2) {
+            for (let i = 0; i < numPoints; i++) {
+                ctx.beginPath();
+                ctx.moveTo(points1[i].x, points1[i].y);
+                ctx.lineTo(points2[i].x, points2[i].y);
+                ctx.strokeStyle = `hsl(${(i / numPoints) * 360}, 100%, 50%)`; // Vary color for each line
+                ctx.lineWidth = 1;
+                ctx.stroke();
+            }
+        }
+
+        function animate() {
+            ctx.clearRect(0, 0, canvas.width, canvas.height);
+
+            drawCircle();
+
+            // Calculate the position of the ellipse on the circle's circumference
+            const ellipseDistance = Math.sqrt(Math.pow(ellipseRadiusX * Math.cos(ellipseAngle), 2) + Math.pow(ellipseRadiusY * Math.sin(ellipseAngle), 2));
+            const ellipseX = centerX + (circleRadius + ellipseDistance) * Math.cos(angle);
+            const ellipseY = centerY + (circleRadius + ellipseDistance) * Math.sin(angle);
+
+            // Generate points on the circle and the ellipse
+            const circlePoints = generatePointsOnCircle(circleRadius, centerX, centerY, numPoints);
+            const ellipsePoints = generatePointsOnEllipse(ellipseX, ellipseY, ellipseRadiusX, ellipseRadiusY, numPoints, ellipseAngle);
+
+            // Draw the ellipse
+            drawEllipse(ellipseX, ellipseY, ellipseAngle);
+
+            // Draw lines connecting the points on the circle and the ellipse
+            drawConnectingLines(circlePoints, ellipsePoints);
+
+            // Update the angles for the next frame
+            angle += speed;
+            ellipseAngle += rotationSpeed;
+
+            // Request the next frame
+            requestAnimationFrame(animate);
+        }
+
+        animate();
+    </script>
+</body>
+</html>
+

commit 2d88b45465971041bc303aa6266c5b8cc888feca
Author: tthtlc <htmldeveloper@gmail.com>
Date:   Sun Sep 1 14:52:27 2024 +0800

    new file:   double_ellipse.html

diff --git a/double_ellipse.html b/double_ellipse.html
new file mode 100644
index 0000000..6ac69c3
--- /dev/null
+++ b/double_ellipse.html
@@ -0,0 +1,102 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Dynamic Ellipse Connection</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #333;
+        }
+        canvas {
+            border: 1px solid black;
+            background-color: #333;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="ellipseCanvas" width="800" height="800"></canvas>
+    <script>
+        const canvas = document.getElementById('ellipseCanvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const numPoints = 60;
+        const ellipse1RadiusX = 150;
+        const ellipse1RadiusY = 100;
+        const ellipse2RadiusX = 200;
+        const ellipse2RadiusY = 120;
+
+        // Function to generate ellipse points
+        function generateEllipsePoints(centerX, centerY, radiusX, radiusY, numPoints, angleOffset) {
+            const points = [];
+            for (let i = 0; i < numPoints; i++) {
+                const angle = (i / numPoints) * 2 * Math.PI + angleOffset;
+                const x = centerX + radiusX * Math.cos(angle);
+                const y = centerY + radiusY * Math.sin(angle);
+                points.push({ x, y });
+            }
+            return points;
+        }
+
+        // Function to draw lines between two sets of points
+        function drawConnectingLines(points1, points2) {
+            ctx.strokeStyle = '#ffffff';
+            ctx.lineWidth = 0.5;
+            for (let i = 0; i < numPoints; i++) {
+                ctx.beginPath();
+                ctx.moveTo(points1[i].x, points1[i].y);
+                ctx.lineTo(points2[i].x, points2[i].y);
+                ctx.stroke();
+            }
+        }
+
+        // Function to randomize translation and rotation
+        function randomTransform() {
+            const translateX = Math.random() * 100 - 50;
+            const translateY = Math.random() * 100 - 50;
+            const rotateAngle = Math.random() * 2 * Math.PI;
+            return { translateX, translateY, rotateAngle };
+        }
+
+        // Main function to draw the pattern
+        function drawDynamicEllipses() {
+            ctx.clearRect(0, 0, canvas.width, canvas.height);
+
+            const transform1 = randomTransform();
+            const transform2 = randomTransform();
+
+            const ellipse1Points = generateEllipsePoints(
+                centerX + transform1.translateX,
+                centerY + transform1.translateY,
+                ellipse1RadiusX,
+                ellipse1RadiusY,
+                numPoints,
+                transform1.rotateAngle
+            );
+
+            const ellipse2Points = generateEllipsePoints(
+                centerX + transform2.translateX,
+                centerY + transform2.translateY,
+                ellipse2RadiusX,
+                ellipse2RadiusY,
+                numPoints,
+                transform2.rotateAngle
+            );
+
+            drawConnectingLines(ellipse1Points, ellipse2Points);
+
+            // Redraw the pattern every 2 seconds with new random transformations
+            setTimeout(drawDynamicEllipses, 2000);
+        }
+
+        drawDynamicEllipses();
+    </script>
+</body>
+</html>
+

commit 6ea979904d4dfab0a5d01fea65afe73f91bf6013
Author: tthtlc <htmldeveloper@gmail.com>
Date:   Sun Sep 1 14:46:18 2024 +0800

    modified:   index.html

diff --git a/index.html b/index.html
index 09a858f..df17be5 100644
--- a/index.html
+++ b/index.html
@@ -104,6 +104,9 @@
             <a href="static_concentric.html" target="frame_static_concentric.html">static_concentric.html</a>
             <iframe name="frame_static_concentric.html" src="static_concentric.html"></iframe>
             
+            <a href="concentric.html" target="frame_concentric.html">concentric.html</a>
+            <iframe name="frame_concentric.html" src="concentric.html"></iframe>
+            
             <a href="three_petal.html" target="frame_three_petal.html">three_petal.html</a>
             <iframe name="frame_three_petal.html" src="three_petal.html"></iframe>
             
@@ -185,9 +188,6 @@
             <a href="circle.html" target="frame_circle.html">circle.html</a>
             <iframe name="frame_circle.html" src="circle.html"></iframe>
             
-            <a href="concentric.html" target="frame_concentric.html">concentric.html</a>
-            <iframe name="frame_concentric.html" src="concentric.html"></iframe>
-            
             <a href="counter_rotating_sector.html" target="frame_counter_rotating_sector.html">counter_rotating_sector.html</a>
             <iframe name="frame_counter_rotating_sector.html" src="counter_rotating_sector.html"></iframe>
             

commit ade9ce8ae4384dff0dadfa3475f5785b29cec432
Author: tthtlc <htmldeveloper@gmail.com>
Date:   Sun Sep 1 14:43:08 2024 +0800

    modified:   index.html

diff --git a/index.html b/index.html
index 5eaff27..09a858f 100644
--- a/index.html
+++ b/index.html
@@ -14,6 +14,12 @@
     <body>
         <h1>Files</h1>
     
+            <a href="icosahedron_surface.html" target="frame_icosahedron_surface.html">icosahedron_surface.html</a>
+            <iframe name="frame_icosahedron_surface.html" src="icosahedron_surface.html"></iframe>
+            
+            <a href="icosahedron_centroid.html" target="frame_icosahedron_centroid.html">icosahedron_centroid.html</a>
+            <iframe name="frame_icosahedron_centroid.html" src="icosahedron_centroid.html"></iframe>
+            
             <a href="icosahedron.html" target="frame_icosahedron.html">icosahedron.html</a>
             <iframe name="frame_icosahedron.html" src="icosahedron.html"></iframe>
             

commit c28f77760c71c0de6f4fb6e5cd17f967b245e8b4
Author: tthtlc <htmldeveloper@gmail.com>
Date:   Sun Sep 1 14:40:46 2024 +0800

    new file:   truncated_icosahedron.html

diff --git a/truncated_icosahedron.html b/truncated_icosahedron.html
new file mode 100644
index 0000000..b63306a
--- /dev/null
+++ b/truncated_icosahedron.html
@@ -0,0 +1,139 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Truncated Icosahedron Wireframe</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="canvas" width="800" height="800"></canvas>
+    <script>
+        const canvas = document.getElementById('canvas');
+        const ctx = canvas.getContext('2d');
+        const width = canvas.width;
+        const height = canvas.height;
+        const centerX = width / 2;
+        const centerY = height / 2;
+        const scale = 50;
+
+        let angleX = 0;
+        let angleY = 0;
+
+        const vertices = [];
+        const faces = [];
+
+        function initTruncatedIcosahedron() {
+            const t = (1 + Math.sqrt(5)) / 2;
+            const s = 1;
+
+            const V = [
+                [-s,  s, 3*t], [ s,  s, 3*t], [-s, -s, 3*t], [ s, -s, 3*t],
+                [ 0,  t, 3*s], [ 0, -t, 3*s], [-t,  s, 3*s], [ t,  s, 3*s],
+                [-t, -s, 3*s], [ t, -s, 3*s], [3*s,  0,  t], [3*s,  0, -t],
+                [3*t,  s,  s], [3*t,  s, -s], [3*t, -s,  s], [3*t, -s, -s],
+                [ s, 3*t,  s], [-s, 3*t,  s], [ s, 3*t, -s], [-s, 3*t, -s],
+                [ 0,  t, -3*s], [ 0, -t, -3*s], [-t,  s, -3*s], [ t,  s, -3*s],
+                [-t, -s, -3*s], [ t, -s, -3*s], [-3*s,  0,  t], [-3*s,  0, -t],
+                [-3*t,  s,  s], [-3*t,  s, -s], [-3*t, -s,  s], [-3*t, -s, -s],
+                [-s, -3*t,  s], [ s, -3*t,  s], [-s, -3*t, -s], [ s, -3*t, -s]
+            ];
+
+            for (let i = 0; i < V.length; i++) {
+                vertices.push([V[i][0], V[i][1], V[i][2]]);
+                vertices.push([-V[i][0], -V[i][1], -V[i][2]]);
+            }
+
+            const F = [
+                [0, 4, 1], [0, 1, 2], [0, 2, 3], [0, 3, 4],
+                [1, 4, 7], [1, 7, 6], [1, 6, 2], [2, 6, 5],
+                [2, 5, 3], [3, 5, 8], [3, 8, 4], [4, 8, 7],
+                [6, 7, 10], [6, 10, 9], [6, 9, 5], [5, 9, 12],
+                [5, 12, 8], [8, 12, 11], [8, 11, 7], [7, 11, 10],
+                [9, 10, 13], [9, 13, 14], [9, 14, 12], [12, 14, 15],
+                [12, 15, 11], [11, 15, 10], [10, 15, 13], [13, 14, 15]
+            ];
+
+            for (let i = 0; i < F.length; i++) {
+                faces.push(F[i]);
+            }
+        }
+
+        function rotateX(point, angle) {
+            const cos = Math.cos(angle);
+            const sin = Math.sin(angle);
+            const [x, y, z] = point;
+            return [
+                x,
+                y * cos - z * sin,
+                y * sin + z * cos
+            ];
+        }
+
+        function rotateY(point, angle) {
+            const cos = Math.cos(angle);
+            const sin = Math.sin(angle);
+            const [x, y, z] = point;
+            return [
+                x * cos + z * sin,
+                y,
+                -x * sin + z * cos
+            ];
+        }
+
+        function project(point) {
+            const [x, y, z] = point;
+            const perspective = 1 / (1 - z / 4);
+            return [
+                centerX + x * scale * perspective,
+                centerY - y * scale * perspective
+            ];
+        }
+
+        function drawTruncatedIcosahedron() {
+            ctx.clearRect(0, 0, width, height);
+
+            const rotatedVertices = vertices.map(v => rotateY(rotateX(v, angleX), angleY));
+
+            faces.forEach(face => {
+                ctx.beginPath();
+                const projectedPoint = project(rotatedVertices[face[0]]);
+                ctx.moveTo(projectedPoint[0], projectedPoint[1]);
+
+                face.forEach(index => {
+                    const [x, y] = project(rotatedVertices[index]);
+                    ctx.lineTo(x, y);
+                });
+
+                ctx.closePath();
+                ctx.strokeStyle = 'black';
+                ctx.stroke();
+            });
+        }
+
+        function animate() {
+            angleX += 0.01;
+            angleY += 0.01;
+            drawTruncatedIcosahedron();
+            requestAnimationFrame(animate);
+        }
+
+        initTruncatedIcosahedron();
+        animate();
+    </script>
+</body>
+</html>
+

commit 68841d6823fdb8c27838d0035aec934db403237d
Author: tthtlc <htmldeveloper@gmail.com>
Date:   Sun Sep 1 14:40:07 2024 +0800

    new file:   figure_eight_double.html
    new file:   icosahedron_centroid.html
    new file:   icosahedron_surface.html
    new file:   icosicosidodecahedron.html
    new file:   icosicosidodecahedron.txt

diff --git a/figure_eight_double.html b/figure_eight_double.html
new file mode 100644
index 0000000..3cc8b57
--- /dev/null
+++ b/figure_eight_double.html
@@ -0,0 +1,61 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Figure of 8 using Polar Coordinates</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            background-color: white;
+            border: 1px solid black;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="figure8Canvas" width="500" height="500"></canvas>
+
+    <script>
+        const canvas = document.getElementById('figure8Canvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const scale = 100;
+        const parts = 1200;
+        const step = 2*Math.PI/parts;
+
+        function drawFigure8() {
+            ctx.clearRect(0, 0, canvas.width, canvas.height);
+            ctx.beginPath();
+
+            for (let theta = 0; theta <= 2 * Math.PI; theta += step) {
+                // Polar coordinates for figure of 8 (lemniscate of Bernoulli)
+                const r = scale * Math.sqrt(Math.cos(4 * theta));
+                const x = r * Math.cos(theta);
+                const y = r * Math.sin(theta);
+
+                // Convert to Cartesian coordinates and draw
+                //if (theta === 0) {
+                //    ctx.moveTo(centerX + x, centerY + y);
+                //} else {
+                    ctx.lineTo(centerX + x, centerY + y);
+                //}
+            }
+
+            ctx.strokeStyle = 'blue';
+            ctx.lineWidth = 2;
+            ctx.stroke();
+        }
+
+        drawFigure8();
+    </script>
+</body>
+</html>
+
diff --git a/icosahedron_centroid.html b/icosahedron_centroid.html
new file mode 100644
index 0000000..148b411
--- /dev/null
+++ b/icosahedron_centroid.html
@@ -0,0 +1,160 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Icosahedron Wireframe with Centroids</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="canvas" width="800" height="800"></canvas>
+    <script>
+        const canvas = document.getElementById('canvas');
+        const ctx = canvas.getContext('2d');
+        const width = canvas.width;
+        const height = canvas.height;
+        const centerX = width / 2;
+        const centerY = height / 2;
+        const scale = 200;
+
+        let angleX = 0;
+        let angleY = 0;
+
+        const vertices = [];
+        const faces = [];
+
+        function initIcosahedron() {
+            const phi = (1 + Math.sqrt(5)) / 2;
+
+            vertices.push([-1, phi, 0]);
+            vertices.push([1, phi, 0]);
+            vertices.push([-1, -phi, 0]);
+            vertices.push([1, -phi, 0]);
+
+            vertices.push([0, -1, phi]);
+            vertices.push([0, 1, phi]);
+            vertices.push([0, -1, -phi]);
+            vertices.push([0, 1, -phi]);
+
+            vertices.push([phi, 0, -1]);
+            vertices.push([phi, 0, 1]);
+            vertices.push([-phi, 0, -1]);
+            vertices.push([-phi, 0, 1]);
+
+            faces.push([0, 11, 5]);
+            faces.push([0, 5, 1]);
+            faces.push([0, 1, 7]);
+            faces.push([0, 7, 10]);
+            faces.push([0, 10, 11]);
+
+            faces.push([1, 5, 9]);
+            faces.push([5, 11, 4]);
+            faces.push([11, 10, 2]);
+            faces.push([10, 7, 6]);
+            faces.push([7, 1, 8]);
+
+            faces.push([3, 9, 4]);
+            faces.push([3, 4, 2]);
+            faces.push([3, 2, 6]);
+            faces.push([3, 6, 8]);
+            faces.push([3, 8, 9]);
+
+            faces.push([4, 9, 5]);
+            faces.push([2, 4, 11]);
+            faces.push([6, 2, 10]);
+            faces.push([8, 6, 7]);
+            faces.push([9, 8, 1]);
+        }
+
+        function rotateX(point, angle) {
+            const cos = Math.cos(angle);
+            const sin = Math.sin(angle);
+            const [x, y, z] = point;
+            return [
+                x,
+                y * cos - z * sin,
+                y * sin + z * cos
+            ];
+        }
+
+        function rotateY(point, angle) {
+            const cos = Math.cos(angle);
+            const sin = Math.sin(angle);
+            const [x, y, z] = point;
+            return [
+                x * cos + z * sin,
+                y,
+                -x * sin + z * cos
+            ];
+        }
+
+        function project(point) {
+            const [x, y, z] = point;
+            const perspective = 1 / (1 - z / 4);
+            return [
+                centerX + x * scale * perspective,
+                centerY - y * scale * perspective
+            ];
+        }
+
+        function drawIcosahedron() {
+            ctx.clearRect(0, 0, width, height);
+            ctx.strokeStyle = 'black';
+
+            const rotatedVertices = vertices.map(v => rotateY(rotateX(v, angleX), angleY));
+
+            faces.forEach(face => {
+                // Draw the triangle
+                ctx.beginPath();
+                const projectedPoint = project(rotatedVertices[face[0]]);
+                ctx.moveTo(projectedPoint[0], projectedPoint[1]);
+
+                face.forEach(index => {
+                    const [x, y] = project(rotatedVertices[index]);
+                    ctx.lineTo(x, y);
+                });
+
+                ctx.closePath();
+                ctx.stroke();
+
+                // Calculate the centroid of the face
+                const centroid = [
+                    (rotatedVertices[face[0]][0] + rotatedVertices[face[1]][0] + rotatedVertices[face[2]][0]) / 3,
+                    (rotatedVertices[face[0]][1] + rotatedVertices[face[1]][1] + rotatedVertices[face[2]][1]) / 3,
+                    (rotatedVertices[face[0]][2] + rotatedVertices[face[1]][2] + rotatedVertices[face[2]][2]) / 3
+                ];
+
+                // Draw the line from the center (0, 0, 0) to the centroid
+                const projectedCentroid = project(centroid);
+                ctx.beginPath();
+                ctx.moveTo(centerX, centerY); // Center of the canvas (0, 0, 0) projected
+                ctx.lineTo(projectedCentroid[0], projectedCentroid[1]);
+                ctx.stroke();
+            });
+        }
+
+        function animate() {
+            angleX += 0.01;
+            angleY += 0.01;
+            drawIcosahedron();
+            requestAnimationFrame(animate);
+        }
+
+        initIcosahedron();
+        animate();
+    </script>
+</body>
+</html>
+
diff --git a/icosahedron_surface.html b/icosahedron_surface.html
new file mode 100644
index 0000000..fe8c4de
--- /dev/null
+++ b/icosahedron_surface.html
@@ -0,0 +1,173 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Icosahedron with Centroid Lines</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="canvas" width="800" height="800"></canvas>
+    <script>
+        const canvas = document.getElementById('canvas');
+        const ctx = canvas.getContext('2d');
+        const width = canvas.width;
+        const height = canvas.height;
+        const centerX = width / 2;
+        const centerY = height / 2;
+        const scale = 200;
+
+        let angleX = 0;
+        let angleY = 0;
+
+        const vertices = [];
+        const faces = [];
+
+        function initIcosahedron() {
+            const phi = (1 + Math.sqrt(5)) / 2;
+
+            vertices.push([-1, phi, 0]);
+            vertices.push([1, phi, 0]);
+            vertices.push([-1, -phi, 0]);
+            vertices.push([1, -phi, 0]);
+
+            vertices.push([0, -1, phi]);
+            vertices.push([0, 1, phi]);
+            vertices.push([0, -1, -phi]);
+            vertices.push([0, 1, -phi]);
+
+            vertices.push([phi, 0, -1]);
+            vertices.push([phi, 0, 1]);
+            vertices.push([-phi, 0, -1]);
+            vertices.push([-phi, 0, 1]);
+
+            faces.push([0, 11, 5]);
+            faces.push([0, 5, 1]);
+            faces.push([0, 1, 7]);
+            faces.push([0, 7, 10]);
+            faces.push([0, 10, 11]);
+
+            faces.push([1, 5, 9]);
+            faces.push([5, 11, 4]);
+            faces.push([11, 10, 2]);
+            faces.push([10, 7, 6]);
+            faces.push([7, 1, 8]);
+
+            faces.push([3, 9, 4]);
+            faces.push([3, 4, 2]);
+            faces.push([3, 2, 6]);
+            faces.push([3, 6, 8]);
+            faces.push([3, 8, 9]);
+
+            faces.push([4, 9, 5]);
+            faces.push([2, 4, 11]);
+            faces.push([6, 2, 10]);
+            faces.push([8, 6, 7]);
+            faces.push([9, 8, 1]);
+        }
+
+        function rotateX(point, angle) {
+            const cos = Math.cos(angle);
+            const sin = Math.sin(angle);
+            const [x, y, z] = point;
+            return [
+                x,
+                y * cos - z * sin,
+                y * sin + z * cos
+            ];
+        }
+
+        function rotateY(point, angle) {
+            const cos = Math.cos(angle);
+            const sin = Math.sin(angle);
+            const [x, y, z] = point;
+            return [
+                x * cos + z * sin,
+                y,
+                -x * sin + z * cos
+            ];
+        }
+
+        function project(point) {
+            const [x, y, z] = point;
+            const perspective = 1 / (1 - z / 4);
+            return [
+                centerX + x * scale * perspective,
+                centerY - y * scale * perspective
+            ];
+        }
+
+        function getRandomColor() {
+            const letters = '0123456789ABCDEF';
+            let color = '#';
+            for (let i = 0; i < 6; i++) {
+                color += letters[Math.floor(Math.random() * 16)];
+            }
+            return color;
+        }
+
+        function drawIcosahedron() {
+            ctx.clearRect(0, 0, width, height);
+
+            const rotatedVertices = vertices.map(v => rotateY(rotateX(v, angleX), angleY));
+
+            faces.forEach(face => {
+                // Draw the triangle
+                ctx.beginPath();
+                const projectedPoint = project(rotatedVertices[face[0]]);
+                ctx.moveTo(projectedPoint[0], projectedPoint[1]);
+
+                face.forEach(index => {
+                    const [x, y] = project(rotatedVertices[index]);
+                    ctx.lineTo(x, y);
+                });
+
+                ctx.closePath();
+                ctx.strokeStyle = 'black';
+                ctx.stroke();
+
+                // Calculate the centroid of the face
+                const centroid = [
+                    (rotatedVertices[face[0]][0] + rotatedVertices[face[1]][0] + rotatedVertices[face[2]][0]) / 3,
+                    (rotatedVertices[face[0]][1] + rotatedVertices[face[1]][1] + rotatedVertices[face[2]][1]) / 3,
+                    (rotatedVertices[face[0]][2] + rotatedVertices[face[1]][2] + rotatedVertices[face[2]][2]) / 3
+                ];
+
+                // Draw lines from the centroid to each vertex
+                face.forEach(index => {
+                    ctx.beginPath();
+                    const projectedCentroid = project(centroid);
+                    const projectedVertex = project(rotatedVertices[index]);
+                    ctx.moveTo(projectedCentroid[0], projectedCentroid[1]);
+                    ctx.lineTo(projectedVertex[0], projectedVertex[1]);
+                    ctx.strokeStyle = getRandomColor();
+                    ctx.stroke();
+                });
+            });
+        }
+
+        function animate() {
+            angleX += 0.01;
+            angleY += 0.01;
+            drawIcosahedron();
+            requestAnimationFrame(animate);
+        }
+
+        initIcosahedron();
+        animate();
+    </script>
+</body>
+</html>
+
diff --git a/icosicosidodecahedron.html b/icosicosidodecahedron.html
new file mode 100644
index 0000000..360a335
--- /dev/null
+++ b/icosicosidodecahedron.html
@@ -0,0 +1,115 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Icosicosidodecahedron Wireframe</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="canvas" width="800" height="800"></canvas>
+    <script>
+        const canvas = document.getElementById('canvas');
+        const ctx = canvas.getContext('2d');
+        const width = canvas.width;
+        const height = canvas.height;
+        const centerX = width / 2;
+        const centerY = height / 2;
+        const scale = 100;
+
+        let angleX = 0;
+        let angleY = 0;
+
+        // Vertices and faces for the Icosicosidodecahedron
+        const vertices = [
+            // Insert the vertices of the Icosicosidodecahedron here
+            // This is a complex polyhedron, so a proper mathematical approach or model data is needed to define it
+        ];
+
+        const faces = [
+            // Insert the faces of the Icosicosidodecahedron here
+            // Each face will be defined by a set of indices corresponding to vertices
+        ];
+
+        function rotateX(point, angle) {
+            const cos = Math.cos(angle);
+            const sin = Math.sin(angle);
+            const [x, y, z] = point;
+            return [
+                x,
+                y * cos - z * sin,
+                y * sin + z * cos
+            ];
+        }
+
+        function rotateY(point, angle) {
+            const cos = Math.cos(angle);
+            const sin = Math.sin(angle);
+            const [x, y, z] = point;
+            return [
+                x * cos + z * sin,
+                y,
+                -x * sin + z * cos
+            ];
+        }
+
+        function project(point) {
+            const [x, y, z] = point;
+            const perspective = 1 / (1 - z / 4);
+            return [
+                centerX + x * scale * perspective,
+                centerY - y * scale * perspective
+            ];
+        }
+
+        function drawIcosicosidodecahedron() {
+            ctx.clearRect(0, 0, width, height);
+
+            const rotatedVertices = vertices.map(v => rotateY(rotateX(v, angleX), angleY));
+
+            faces.forEach(face => {
+                ctx.beginPath();
+                const projectedPoint = project(rotatedVertices[face[0]]);
+                ctx.moveTo(projectedPoint[0], projectedPoint[1]);
+
+                face.forEach(index => {
+                    const [x, y] = project(rotatedVertices[index]);
+                    ctx.lineTo(x, y);
+                });
+
+                ctx.closePath();
+                ctx.strokeStyle = 'black';
+                ctx.stroke();
+            });
+        }
+
+        function animate() {
+            angleX += 0.01;
+            angleY += 0.01;
+            drawIcosicosidodecahedron();
+            requestAnimationFrame(animate);
+        }
+
+        // Call a function to generate the vertices and faces for the icosicosidodecahedron
+        function initIcosicosidodecahedron() {
+            // To be defined: Calculate or retrieve the vertices and faces for the icosicosidodecahedron
+        }
+
+        initIcosicosidodecahedron();
+        animate();
+    </script>
+</body>
+</html>
+
diff --git a/icosicosidodecahedron.txt b/icosicosidodecahedron.txt
new file mode 100644
index 0000000..f23f348
--- /dev/null
+++ b/icosicosidodecahedron.txt
@@ -0,0 +1,242 @@
+
+https://chatgpt.com/share/a3b39c41-dbb1-45de-b9d2-38be95f2a863
+
+Generate all the coordinates of an Icosicosidodecahedron.
+ChatGPT said:
+ChatGPT
+Generating the coordinates of an Icosicosidodecahedron involves defining the vertices of the shape. The Icosicosidodecahedron is a uniform polyhedron with a complex structure consisting of 120 vertices. These vertices are based on a combination of the golden ratio () and various symmetrical properties.
+
+Step-by-Step Approach:
+Golden Ratio: The golden ratio () is defined as:
+
+
+=
+1
++
+5
+2
+= 
+2
+1+ 
+5
+
+ 
+
+ 
+and its inverse:
+
+1
+
+=
+
+
+1
+=
+5
+
+1
+2
+
+1
+
+ =1= 
+2
+5
+
+ 1
+
+ 
+Vertex Coordinates: The vertices of an Icosicosidodecahedron are formed by permutations of the following coordinates:
+
+(1, 1, (2 + ))
+((1 + ), (1 + ), 1)
+(, 2, (2 - 1))
+(, 2, 0)
+Let's generate these coordinates using Python:
+
+python
+Copy code
+import itertools
+import math
+
+# Golden ratio
+phi = (1 + math.sqrt(5)) / 2
+inv_phi = 1 / phi
+
+# Permutations of the base coordinates
+coordinates = []
+
+# (1, 1, (2 + ))
+for x, y, z in itertools.product([1, -1], [1, -1], [2 + phi, -(2 + phi)]):
+    coordinates.append((x, y, z))
+
+# ((1 + ), (1 + ), 1)
+for x, y, z in itertools.product([1 + phi, -(1 + phi)], [1 + phi, -(1 + phi)], [1, -1]):
+    coordinates.append((x, y, z))
+
+# (, 2, (2 - 1))
+for x, y, z in itertools.product([phi, -phi], [2, -2], [(2 * phi - 1), -(2 * phi - 1)]):
+    coordinates.append((x, y, z))
+
+# (, 2, 0)
+for x, y, z in itertools.product([phi**2, -(phi**2)], [2 * phi, -(2 * phi)], [0]):
+    coordinates.append((x, y, z))
+
+# Output the vertices
+for vertex in coordinates:
+    print(vertex)
+Explanation:
+Permutations:
+For each set of base coordinates, all permutations with different signs () are generated using itertools.product.
+Vertices:
+This results in the full set of 120 vertices.
+Final Result:
+The output of this Python script will be the full list of vertices for the Icosicosidodecahedron. Each vertex will be in the form of a tuple (x, y, z), which can be used in your application to construct the shape.
+
+If you prefer the direct list of coordinates without running the Python script, I can provide that as well.
+
+
+
+
+
+
+You said:
+convert the above python into a javascript functions that can return all the coordinates of the Icosicosidodecahedron.
+ChatGPT said:
+ChatGPT
+Certainly! Below is the JavaScript function that generates and returns all the coordinates of the Icosicosidodecahedron.
+
+javascript
+Copy code
+function generateIcosicosidodecahedronVertices() {
+    const phi = (1 + Math.sqrt(5)) / 2;
+
+    const coordinates = [];
+
+    // (1, 1, (2 + ))
+    [[1, 1, 2 + phi], [1, -1, 2 + phi], [-1, 1, 2 + phi], [-1, -1, 2 + phi],
+     [1, 1, -(2 + phi)], [1, -1, -(2 + phi)], [-1, 1, -(2 + phi)], [-1, -1, -(2 + phi)]].forEach(c => {
+        coordinates.push([c[0], c[1], c[2]]);
+    });
+
+    // ((1 + ), (1 + ), 1)
+    [[1 + phi, 1 + phi, 1], [1 + phi, 1 + phi, -1], [1 + phi, -(1 + phi), 1], [1 + phi, -(1 + phi), -1],
+     [-(1 + phi), 1 + phi, 1], [-(1 + phi), 1 + phi, -1], [-(1 + phi), -(1 + phi), 1], [-(1 + phi), -(1 + phi), -1]].forEach(c => {
+        coordinates.push([c[0], c[1], c[2]]);
+    });
+
+    // (, 2, (2 - 1))
+    [[phi, 2, 2 * phi - 1], [phi, 2, -(2 * phi - 1)], [phi, -2, 2 * phi - 1], [phi, -2, -(2 * phi - 1)],
+     [-phi, 2, 2 * phi - 1], [-phi, 2, -(2 * phi - 1)], [-phi, -2, 2 * phi - 1], [-phi, -2, -(2 * phi - 1)]].forEach(c => {
+        coordinates.push([c[0], c[1], c[2]]);
+    });
+
+    // (, 2, 0)
+    [[phi ** 2, 2 * phi, 0], [phi ** 2, -2 * phi, 0], [-phi ** 2, 2 * phi, 0], [-phi ** 2, -2 * phi, 0]].forEach(c => {
+        coordinates.push([c[0], c[1], c[2]]);
+    });
+
+    return coordinates;
+}
+
+// Usage
+const vertices = generateIcosicosidodecahedronVertices();
+console.log(vertices);
+Explanation:
+Golden Ratio:
+
+The golden ratio () is calculated and stored in the variable phi.
+Coordinates Array:
+
+An empty array coordinates is initialized to store all the vertex coordinates.
+Vertex Generation:
+
+For each of the four sets of vertex patterns, we generate the permutations by explicitly listing all possible sign combinations and pushing the resulting vertices into the coordinates array.
+Function Output:
+
+The generateIcosicosidodecahedronVertices function returns the array of vertex coordinates.
+Usage:
+To use the function, simply call generateIcosicosidodecahedronVertices(), and it will return an array containing all the vertices of the Icosicosidodecahedron. Each vertex is represented as an array [x, y, z].
+
+This can be directly integrated into a script where you want to render or process the vertices of the Icosicosidodecahedron.
+
+
+
+
+
+
+You said:
+from the above array, given the sequence of the array as identifier number of the vertice, construct the group of identifier number that defined each surface of the Icosicosidodecahedron, and return all the faces faces that defined the Icosicosidodecahedron.
+ChatGPT said:
+ChatGPT
+To construct the groups of identifier numbers (indices) that define each face of the Icosicosidodecahedron, we need to organize the vertices into the polygons that make up the faces of the polyhedron. The Icosicosidodecahedron has a combination of triangles, squares, and pentagons as faces.
+
+Heres a JavaScript function that calculates and returns the array of faces, with each face being defined by a group of indices corresponding to the vertices:
+
+javascript
+Copy code
+function generateIcosicosidodecahedronVertices() {
+    const phi = (1 + Math.sqrt(5)) / 2;
+    const coordinates = [];
+
+    // (1, 1, (2 + ))
+    [[1, 1, 2 + phi], [1, -1, 2 + phi], [-1, 1, 2 + phi], [-1, -1, 2 + phi],
+     [1, 1, -(2 + phi)], [1, -1, -(2 + phi)], [-1, 1, -(2 + phi)], [-1, -1, -(2 + phi)]].forEach(c => {
+        coordinates.push([c[0], c[1], c[2]]);
+    });
+
+    // ((1 + ), (1 + ), 1)
+    [[1 + phi, 1 + phi, 1], [1 + phi, 1 + phi, -1], [1 + phi, -(1 + phi), 1], [1 + phi, -(1 + phi), -1],
+     [-(1 + phi), 1 + phi, 1], [-(1 + phi), 1 + phi, -1], [-(1 + phi), -(1 + phi), 1], [-(1 + phi), -(1 + phi), -1]].forEach(c => {
+        coordinates.push([c[0], c[1], c[2]]);
+    });
+
+    // (, 2, (2 - 1))
+    [[phi, 2, 2 * phi - 1], [phi, 2, -(2 * phi - 1)], [phi, -2, 2 * phi - 1], [phi, -2, -(2 * phi - 1)],
+     [-phi, 2, 2 * phi - 1], [-phi, 2, -(2 * phi - 1)], [-phi, -2, 2 * phi - 1], [-phi, -2, -(2 * phi - 1)]].forEach(c => {
+        coordinates.push([c[0], c[1], c[2]]);
+    });
+
+    // (, 2, 0)
+    [[phi ** 2, 2 * phi, 0], [phi ** 2, -2 * phi, 0], [-phi ** 2, 2 * phi, 0], [-phi ** 2, -2 * phi, 0]].forEach(c => {
+        coordinates.push([c[0], c[1], c[2]]);
+    });
+
+    return coordinates;
+}
+
+function generateIcosicosidodecahedronFaces() {
+    // The vertices are already ordered, so we can manually specify the faces based on the pattern.
+    const faces = [
+        // The faces are defined manually based on the known structure of the Icosicosidodecahedron.
+        // Each face is defined by a group of vertex indices.
+
+        // Triangular faces
+        [0, 1, 2], [1, 2, 3], [4, 5, 6], [5, 6, 7],
+        // Square faces
+        [8, 9, 10, 11], [12, 13, 14, 15],
+        // Pentagonal faces
+        [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]
+        // Continue listing all faces based on the vertices
+    ];
+
+    return faces;
+}
+
+// Usage
+const vertices = generateIcosicosidodecahedronVertices();
+const faces = generateIcosicosidodecahedronFaces();
+console.log("Vertices: ", vertices);
+console.log("Faces: ", faces);
+Explanation:
+Vertex Generation:
+
+The function generateIcosicosidodecahedronVertices() generates the vertices of the Icosicosidodecahedron based on the permutations of the base coordinates.
+Face Construction:
+
+The function generateIcosicosidodecahedronFaces() defines the faces of the polyhedron. Each face is represented by an array of indices that correspond to the vertices generated by the previous function.
+The faces are categorized as triangles, squares, or pentagons based on the Icosicosidodecahedron's structure.
+Note:
+The actual construction of the face arrays is complex and depends on the precise ordering and structure of the vertices. The indices used here in the faces array are placeholders to illustrate how you would structure the function. In a complete implementation, you would need to accurately identify the indices that correspond to each face by examining the geometric relationships between vertices.
+
+To generate all the correct face definitions, a detailed and careful mapping of each face to its corresponding vertices is necessary, which typically involves either mathematical modeling or using a polyhedron library that can export such data.

commit b52f904619b25ae87e77df3080befa0e479d79c4
Author: tthtlc <htmldeveloper@gmail.com>
Date:   Sat Aug 31 22:33:04 2024 +0800

    modified:   figure_eight.html

diff --git a/figure_eight.html b/figure_eight.html
index d7b3ab5..6411724 100644
--- a/figure_eight.html
+++ b/figure_eight.html
@@ -3,57 +3,58 @@
 <head>
     <meta charset="UTF-8">
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
-    <title>3D Figure Eight with Circles</title>
+    <title>Figure of 8 using Polar Coordinates</title>
     <style>
-        body { margin: 0; }
-        canvas { display: block; }
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            background-color: white;
+            border: 1px solid black;
+        }
     </style>
 </head>
 <body>
-    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
-    <script>
-        // Set up the scene, camera, and renderer
-        const scene = new THREE.Scene();
-        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
-        const renderer = new THREE.WebGLRenderer();
-        renderer.setSize(window.innerWidth, window.innerHeight);
-        document.body.appendChild(renderer.domElement);
-
-        // Create two circular curves
-        const radius = 5;
-        const segments = 64;
-        const curve1 = new THREE.EllipseCurve(0, 0, radius, radius, Math.PI, -Math.PI, true, 0);
-        const curve2 = new THREE.EllipseCurve(0, 0, radius, radius, 0, Math.PI, true, 0);
-
-        // Create points for each curve and join them together
-        const points1 = curve1.getPoints(segments);
-        const points2 = curve2.getPoints(segments);
-        const points = points1.concat(points2);
+    <canvas id="figure8Canvas" width="500" height="500"></canvas>
 
-        // Create geometry and material for the figure-eight line
-        const geometry = new THREE.BufferGeometry().setFromPoints(points);
-        const material = new THREE.LineBasicMaterial({ color: 0xff0000 });
-
-        // Create the figure-eight line
-        const figureEight = new THREE.Line(geometry, material);
-        scene.add(figureEight);
-
-        // Set the camera position
-        camera.position.z = 20;
-
-        // Animation loop
-        function animate() {
-            requestAnimationFrame(animate);
-            renderer.render(scene, camera);
+    <script>
+        const canvas = document.getElementById('figure8Canvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const scale = 100;
+        const parts = 120;
+        const step = 2*Math.PI/parts;
+
+        function drawFigure8() {
+            ctx.clearRect(0, 0, canvas.width, canvas.height);
+            ctx.beginPath();
+
+            for (let theta = 0; theta <= 2 * Math.PI; theta += step) {
+                // Polar coordinates for figure of 8 (lemniscate of Bernoulli)
+                const r = scale * Math.sqrt(Math.cos(2 * theta));
+                const x = r * Math.cos(theta);
+                const y = r * Math.sin(theta);
+
+                // Convert to Cartesian coordinates and draw
+                if (theta === 0) {
+                    ctx.moveTo(centerX + x, centerY + y);
+                } else {
+                    ctx.lineTo(centerX + x, centerY + y);
+                }
+            }
+
+            ctx.strokeStyle = 'blue';
+            ctx.lineWidth = 2;
+            ctx.stroke();
         }
-        animate();
 
-        // Handle window resize
-        window.addEventListener('resize', () => {
-            camera.aspect = window.innerWidth / window.innerHeight;
-            camera.updateProjectionMatrix();
-            renderer.setSize(window.innerWidth, window.innerHeight);
-        });
+        drawFigure8();
     </script>
 </body>
 </html>

commit 60946fba47bab35c382ebe64802b16a981d5a731
Author: tthtlc <htmldeveloper@gmail.com>
Date:   Sat Aug 31 21:46:57 2024 +0800

    modified:   index.html

diff --git a/index.html b/index.html
index a02e2a6..5eaff27 100644
--- a/index.html
+++ b/index.html
@@ -35,15 +35,6 @@
             <a href="torus.html" target="frame_torus.html">torus.html</a>
             <iframe name="frame_torus.html" src="torus.html"></iframe>
             
-            <a href="klein6.html" target="frame_klein6.html">klein6.html</a>
-            <iframe name="frame_klein6.html" src="klein6.html"></iframe>
-            
-            <a href="klein7.html" target="frame_klein7.html">klein7.html</a>
-            <iframe name="frame_klein7.html" src="klein7.html"></iframe>
-            
-            <a href="klein.html" target="frame_klein.html">klein.html</a>
-            <iframe name="frame_klein.html" src="klein.html"></iframe>
-            
             <a href="line_drawing.html" target="frame_line_drawing.html">line_drawing.html</a>
             <iframe name="frame_line_drawing.html" src="line_drawing.html"></iframe>
             

commit f836e1bd4e9b0c162243dcbe3f62b95baf32cefb
Author: tthtlc <htmldeveloper@gmail.com>
Date:   Sat Aug 31 21:45:10 2024 +0800

    deleted:    klein.html
    deleted:    klein6.html
    deleted:    klein7.html

diff --git a/klein.html b/klein.html
deleted file mode 100644
index f7f2339..0000000
--- a/klein.html
+++ /dev/null
@@ -1,81 +0,0 @@
-<!DOCTYPE html>
-<html lang="en">
-<head>
-    <meta charset="UTF-8">
-    <meta name="viewport" content="width=device-width, initial-scale=1.0">
-    <title>Klein Bottle Line Drawing</title>
-    <style>
-        body {
-            display: flex;
-            justify-content: center;
-            align-items: center;
-            height: 100vh;
-            margin: 0;
-            background-color: #f0f0f0;
-        }
-        canvas {
-            border: 1px solid black;
-            background-color: #fff;
-        }
-    </style>
-</head>
-<body>
-    <canvas id="kleinBottleCanvas" width="600" height="600"></canvas>
-    <script>
-        const canvas = document.getElementById('kleinBottleCanvas');
-        const ctx = canvas.getContext('2d');
-        const centerX = canvas.width / 2;
-        const centerY = canvas.height / 2;
-        const scale = 60;
-        const numU = 50;
-        const numV = 50;
-
-        function drawKleinBottle() {
-            ctx.clearRect(0, 0, canvas.width, canvas.height);
-            ctx.strokeStyle = '#000000';
-            ctx.lineWidth = 0.5;
-
-            for (let i = 0; i <= numU; i++) {
-                const u = (i / numU) * 2 * Math.PI;
-                ctx.beginPath();
-                for (let j = 0; j <= numV; j++) {
-                    const v = (j / numV) * 2 * Math.PI;
-                    const x = (scale * (Math.cos(u) * (1 + Math.sin(u)) + (v - Math.PI) * Math.cos(u) / 2));
-                    const y = (scale * (Math.sin(u) * (1 + Math.sin(u)) + (v - Math.PI) * Math.sin(u) / 2));
-                    const z = scale * (Math.cos(u) * Math.sin(u) + Math.cos(v));
-                    const xProj = centerX + x * Math.cos(u) - z * Math.sin(u);
-                    const yProj = centerY + y * Math.cos(v) - z * Math.sin(v);
-                    if (j === 0) {
-                        ctx.moveTo(xProj, yProj);
-                    } else {
-                        ctx.lineTo(xProj, yProj);
-                    }
-                }
-                ctx.stroke();
-            }
-
-            for (let j = 0; j <= numV; j++) {
-                const v = (j / numV) * 2 * Math.PI;
-                ctx.beginPath();
-                for (let i = 0; i <= numU; i++) {
-                    const u = (i / numU) * 2 * Math.PI;
-                    const x = (scale * (Math.cos(u) * (1 + Math.sin(u)) + (v - Math.PI) * Math.cos(u) / 2));
-                    const y = (scale * (Math.sin(u) * (1 + Math.sin(u)) + (v - Math.PI) * Math.sin(u) / 2));
-                    const z = scale * (Math.cos(u) * Math.sin(u) + Math.cos(v));
-                    const xProj = centerX + x * Math.cos(u) - z * Math.sin(u);
-                    const yProj = centerY + y * Math.cos(v) - z * Math.sin(v);
-                    if (i === 0) {
-                        ctx.moveTo(xProj, yProj);
-                    } else {
-                        ctx.lineTo(xProj, yProj);
-                    }
-                }
-                ctx.stroke();
-            }
-        }
-
-        drawKleinBottle();
-    </script>
-</body>
-</html>
-
diff --git a/klein6.html b/klein6.html
deleted file mode 100644
index 3b110b0..0000000
--- a/klein6.html
+++ /dev/null
@@ -1,84 +0,0 @@
-
-<!DOCTYPE html>
-<html lang="en">
-<head>
-    <meta charset="UTF-8">
-    <meta name="viewport" content="width=device-width, initial-scale=1.0">
-    <title>Klein Bottle Wireframe</title>
-    <style>
-        body {
-            display: flex;
-            justify-content: center;
-            align-items: center;
-            height: 100vh;
-            margin: 0;
-            background-color: #f0f0f0;
-        }
-        canvas {
-            border: 1px solid black;
-        }
-    </style>
-</head>
-<body>
-    <canvas id="canvas" width="800" height="800"></canvas>
-    <script>
-        const canvas = document.getElementById('canvas');
-        const ctx = canvas.getContext('2d');
-        const width = canvas.width;
-        const height = canvas.height;
-        const centerX = width / 2;
-        const centerY = height / 2;
-        const scale = 50;
-
-        function drawKleinBottle() {
-            const uStep = Math.PI / 18;
-            const vStep = 2 * Math.PI / 36;
-
-            for (let u = 0; u < 2 * Math.PI; u += uStep) {
-                for (let v = 0; v < 2 * Math.PI; v += vStep) {
-                    const [x, y, z] = kleinCoordinates(u, v);
-                    const [nextX, nextY, nextZ] = kleinCoordinates(u + uStep, v);
-                    const [nextX2, nextY2, nextZ2] = kleinCoordinates(u, v + vStep);
-
-                    drawLine(project(x, y, z), project(nextX, nextY, nextZ));
-                    drawLine(project(x, y, z), project(nextX2, nextY2, nextZ2));
-                }
-            }
-        }
-
-        function kleinCoordinates(u, v) {
-            let x, y, z;
-            if (u < Math.PI) {
-                x = 3 * Math.cos(u) * (1 + Math.sin(u)) + 2 * (1 - Math.cos(u) / 2) * Math.cos(v);
-                y = 8 * Math.sin(u) + 2 * (1 - Math.cos(u) / 2) * Math.sin(v);
-                z = 2 * (1 - Math.cos(u) / 2) * Math.sin(v);
-            } else {
-                x = 3 * Math.cos(u) * (1 + Math.sin(u)) + 2 * (1 - Math.cos(u) / 2) * Math.cos(v + Math.PI);
-                y = 8 * Math.sin(u);
-                z = 2 * (1 - Math.cos(u) / 2) * Math.sin(v + Math.PI);
-            }
-            return [x, y, z];
-        }
-
-        function project(x, y, z) {
-            const perspective = 500 / (500 + z);
-            return [
-                centerX + x * scale * perspective,
-                centerY - y * scale * perspective
-            ];
-        }
-
-        function drawLine(start, end) {
-            ctx.beginPath();
-            ctx.moveTo(start[0], start[1]);
-            ctx.lineTo(end[0], end[1]);
-            ctx.stroke();
-        }
-
-        ctx.clearRect(0, 0, width, height);
-        ctx.strokeStyle = 'black';
-        drawKleinBottle();
-    </script>
-</body>
-</html>
-
diff --git a/klein7.html b/klein7.html
deleted file mode 100644
index 5663326..0000000
--- a/klein7.html
+++ /dev/null
@@ -1,78 +0,0 @@
-
-<!DOCTYPE html>
-<html lang="en">
-<head>
-    <meta charset="UTF-8">
-    <meta name="viewport" content="width=device-width, initial-scale=1.0">
-    <title>Klein Bottle Wireframe</title>
-    <style>
-        body {
-            display: flex;
-            justify-content: center;
-            align-items: center;
-            height: 100vh;
-            margin: 0;
-            background-color: #f0f0f0;
-        }
-        canvas {
-            border: 1px solid black;
-        }
-    </style>
-</head>
-<body>
-    <canvas id="canvas" width="800" height="800"></canvas>
-    <script>
-        const canvas = document.getElementById('canvas');
-        const ctx = canvas.getContext('2d');
-        const width = canvas.width;
-        const height = canvas.height;
-        const centerX = width / 2;
-        const centerY = height / 2;
-        const scale = 50;
-
-        function drawKleinBottle() {
-            const uStep = Math.PI / 18;
-            const vStep = 2 * Math.PI / 36;
-
-            for (let u = 0; u < 2 * Math.PI; u += uStep) {
-                for (let v = 0; v < 2 * Math.PI; v += vStep) {
-                    const [x, y, z] = kleinCoordinates(u, v);
-                    const [nextX, nextY, nextZ] = kleinCoordinates(u + uStep, v);
-                    const [nextX2, nextY2, nextZ2] = kleinCoordinates(u, v + vStep);
-
-                    drawLine(project(x, y, z), project(nextX, nextY, nextZ));
-                    drawLine(project(x, y, z), project(nextX2, nextY2, nextZ2));
-                }
-            }
-        }
-
-        function kleinCoordinates(u, v) {
-            let x, y, z;
-                x = (1 + Math.cos(u/2) * Math.sin(v) - Math.sin(u/2) * Math.sin(2*v))*Math.cos(u);
-                y = (1 + Math.cos(u/2) * Math.sin(v) - Math.sin(u/2) * Math.sin(2*v))*Math.sin(u);
-                z = Math.sin(u/2) * Math.sin(v) + Math.cos(u/2) * Math.sin(2*v);
-            return [x, y, z];
-        }
-
-        function project(x, y, z) {
-            const perspective = 500 / (200 + z);
-            return [
-                centerX + x * scale * perspective,
-                centerY - y * scale * perspective
-            ];
-        }
-
-        function drawLine(start, end) {
-            ctx.beginPath();
-            ctx.moveTo(start[0], start[1]);
-            ctx.lineTo(end[0], end[1]);
-            ctx.stroke();
-        }
-
-        ctx.clearRect(0, 0, width, height);
-        ctx.strokeStyle = 'black';
-        drawKleinBottle();
-    </script>
-</body>
-</html>
-

commit 682f0cb398174b35de86959cd751758f323b3ba6
Author: Peter Teoh <htmldeveloper@gmail.com>
Date:   Sat Aug 31 21:37:27 2024 +0800

    modified:   index.html
    deleted:    klein5.html

diff --git a/index.html b/index.html
index 11dce35..a02e2a6 100644
--- a/index.html
+++ b/index.html
@@ -35,9 +35,6 @@
             <a href="torus.html" target="frame_torus.html">torus.html</a>
             <iframe name="frame_torus.html" src="torus.html"></iframe>
             
-            <a href="klein5.html" target="frame_klein5.html">klein5.html</a>
-            <iframe name="frame_klein5.html" src="klein5.html"></iframe>
-            
             <a href="klein6.html" target="frame_klein6.html">klein6.html</a>
             <iframe name="frame_klein6.html" src="klein6.html"></iframe>
             
diff --git a/klein5.html b/klein5.html
deleted file mode 100644
index 7ac464e..0000000
--- a/klein5.html
+++ /dev/null
@@ -1,115 +0,0 @@
-<!DOCTYPE html>
-<html lang="en">
-<head>
-    <meta charset="UTF-8">
-    <meta name="viewport" content="width=device-width, initial-scale=1.0">
-    <title>Klein Bottle Transformation</title>
-    <style>
-        body {
-            display: flex;
-            justify-content: center;
-            align-items: center;
-            height: 100vh;
-            margin: 0;
-            background-color: #f0f0f0;
-        }
-        canvas {
-            border: 1px solid black;
-        }
-    </style>
-</head>
-<body>
-    <canvas id="canvas" width="800" height="800"></canvas>
-    <script>
-        const canvas = document.getElementById('canvas');
-        const ctx = canvas.getContext('2d');
-        const width = canvas.width;
-        const height = canvas.height;
-        const centerX = width / 2;
-        const centerY = height / 2;
-        const scale = 80;
-
-        // Rotation angles
-        const angleX = Math.PI / 6; // Rotate around the X-axis
-        const angleY = Math.PI / 6; // Rotate around the Y-axis
-        const angleZ = Math.PI / 6; // Rotate around the Z-axis
-
-        function rotateX(x, y, z, angle) {
-            const cos = Math.cos(angle);
-            const sin = Math.sin(angle);
-            return [x, y * cos - z * sin, y * sin + z * cos];
-        }
-
-        function rotateY(x, y, z, angle) {
-            const cos = Math.cos(angle);
-            const sin = Math.sin(angle);
-            return [x * cos + z * sin, y, -x * sin + z * cos];
-        }
-
-        function rotateZ(x, y, z, angle) {
-            const cos = Math.cos(angle);
-            const sin = Math.sin(angle);
-            return [x * cos - y * sin, x * sin + y * cos, z];
-        }
-
-        function drawKleinBottle() {
-            const uStep = Math.PI / 18;
-            const vStep = 2 * Math.PI / 36;
-
-            for (let u = 0; u < 2 * Math.PI; u += uStep) {
-                for (let v = 0; v < 2 * Math.PI; v += vStep) {
-                    const [x, y, z] = torusToKleinBottle(u, v);
-                    const [nextX, nextY, nextZ] = torusToKleinBottle(u + uStep, v);
-                    const [nextX2, nextY2, nextZ2] = torusToKleinBottle(u, v + vStep);
-
-                    drawLine(project(x, y, z), project(nextX, nextY, nextZ));
-                    drawLine(project(x, y, z), project(nextX2, nextY2, nextZ2));
-                }
-            }
-        }
-
-        function torusToKleinBottle(u, v) {
-            const R = 4; // Major radius
-            const r = 2; // Minor radius
-
-            // Parametric equations for a torus
-            let x = (R + r * Math.cos(v)) * Math.cos(u);
-            let y = (R + r * Math.cos(v)) * Math.sin(u);
-            let z = r * Math.sin(v);
-
-            // Transformation to create a Klein bottle
-            if (u > Math.PI) {
-                x = (R + r * Math.cos(v)) * Math.cos(u);
-                y = (R + r * Math.cos(v)) * Math.sin(u);
-                z = r * Math.sin(v);
-            }
-
-            [x, y, z] = rotateX(x, y, z, angleX);
-            [x, y, z] = rotateY(x, y, z, angleY);
-            [x, y, z] = rotateZ(x, y, z, angleZ);
-
-            return [x, y, z];
-        }
-
-        function project(x, y, z) {
-            const perspective = 500 / (500 + z);
-            return [
-                centerX + x * scale * perspective,
-                centerY - y * scale * perspective
-            ];
-        }
-
-        function drawLine(start, end) {
-            ctx.beginPath();
-            ctx.moveTo(start[0], start[1]);
-            ctx.lineTo(end[0], end[1]);
-            ctx.stroke();
-        }
-
-        ctx.clearRect(0, 0, width, height);
-        ctx.strokeStyle = 'black';
-        drawKleinBottle();
-    </script>
-</body>
-</html>
-

commit ab48b426d367b39bcd7c6529fc5b65e6db728b40
Author: Peter Teoh <htmldeveloper@gmail.com>
Date:   Sat Aug 31 19:58:19 2024 +0800

    new file:   torus.html

diff --git a/torus.html b/torus.html
new file mode 100644
index 0000000..0bd34ce
--- /dev/null
+++ b/torus.html
@@ -0,0 +1,150 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Klein Bottle Transformation</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="canvas" width="800" height="800"></canvas>
+    <script>
+        const canvas = document.getElementById('canvas');
+        const ctx = canvas.getContext('2d');
+        const width = canvas.width;
+        const height = canvas.height;
+        const centerX = width / 2;
+        const centerY = height / 2;
+        const scale = 80;
+
+        let angleX = Math.PI / 6; // Rotate around the X-axis
+        let angleY = Math.PI / 6; // Rotate around the Y-axis
+        let angleZ = Math.PI / 6; // Rotate around the Z-axis
+
+        let isDragging = false;
+        let lastMouseX, lastMouseY;
+
+        function rotateX(x, y, z, angle) {
+            const cos = Math.cos(angle);
+            const sin = Math.sin(angle);
+            return [x, y * cos - z * sin, y * sin + z * cos];
+        }
+
+        function rotateY(x, y, z, angle) {
+            const cos = Math.cos(angle);
+            const sin = Math.sin(angle);
+            return [x * cos + z * sin, y, -x * sin + z * cos];
+        }
+
+        function rotateZ(x, y, z, angle) {
+            const cos = Math.cos(angle);
+            const sin = Math.sin(angle);
+            return [x * cos - y * sin, x * sin + y * cos, z];
+        }
+
+        function drawKleinBottle() {
+            ctx.clearRect(0, 0, width, height); // Clear the canvas
+
+            const uStep = Math.PI / 18;
+            const vStep = 2 * Math.PI / 36;
+
+            for (let u = 0; u < 2 * Math.PI; u += uStep) {
+                for (let v = 0; v < 2 * Math.PI; v += vStep) {
+                    const [x, y, z] = torusToKleinBottle(u, v);
+                    const [nextX, nextY, nextZ] = torusToKleinBottle(u + uStep, v);
+                    const [nextX2, nextY2, nextZ2] = torusToKleinBottle(u, v + vStep);
+
+                    drawLine(project(x, y, z), project(nextX, nextY, nextZ));
+                    drawLine(project(x, y, z), project(nextX2, nextY2, nextZ2));
+                }
+            }
+        }
+
+        function torusToKleinBottle(u, v) {
+            const R = 4; // Major radius
+            const r = 2; // Minor radius
+
+            // Parametric equations for a torus
+            let x = (R + r * Math.cos(v)) * Math.cos(u);
+            let y = (R + r * Math.cos(v)) * Math.sin(u);
+            let z = r * Math.sin(v);
+
+            // Transformation to create a Klein bottle
+            if (u > Math.PI) {
+                x = (R + r * Math.cos(v)) * Math.cos(u);
+                y = (R + r * Math.cos(v)) * Math.sin(u);
+                z = r * Math.sin(v);
+            }
+
+            [x, y, z] = rotateX(x, y, z, angleX);
+            [x, y, z] = rotateY(x, y, z, angleY);
+            [x, y, z] = rotateZ(x, y, z, angleZ);
+
+            return [x, y, z];
+        }
+
+        function project(x, y, z) {
+            const perspective = 500 / (500 + z);
+            return [
+                centerX + x * scale * perspective,
+                centerY - y * scale * perspective
+            ];
+        }
+
+        function drawLine(start, end) {
+            ctx.beginPath();
+            ctx.moveTo(start[0], start[1]);
+            ctx.lineTo(end[0], end[1]);
+            ctx.stroke();
+        }
+
+        function onMouseDown(event) {
+            isDragging = true;
+            lastMouseX = event.clientX;
+            lastMouseY = event.clientY;
+        }
+
+        function onMouseMove(event) {
+            if (isDragging) {
+                const deltaX = event.clientX - lastMouseX;
+                const deltaY = event.clientY - lastMouseY;
+
+                angleY += deltaX * 0.01; // Update the Y-axis angle
+                angleX += deltaY * 0.01; // Update the X-axis angle
+
+                lastMouseX = event.clientX;
+                lastMouseY = event.clientY;
+
+                drawKleinBottle(); // Redraw with the updated angles
+            }
+        }
+
+        function onMouseUp() {
+            isDragging = false;
+        }
+
+        canvas.addEventListener('mousedown', onMouseDown);
+        canvas.addEventListener('mousemove', onMouseMove);
+        canvas.addEventListener('mouseup', onMouseUp);
+        canvas.addEventListener('mouseleave', onMouseUp);
+
+        // Initial drawing
+        ctx.strokeStyle = 'black';
+        drawKleinBottle();
+    </script>
+</body>
+</html>
+

commit c51efca73725ef4c4ea972385ef0a9429653a755
Author: Peter Teoh <htmldeveloper@gmail.com>
Date:   Sat Aug 31 19:57:59 2024 +0800

    modified:   index.html
    deleted:    klein4.html
    torus.html

diff --git a/index.html b/index.html
index a0174aa..11dce35 100644
--- a/index.html
+++ b/index.html
@@ -32,8 +32,8 @@
             <a href="klein3.html" target="frame_klein3.html">klein3.html</a>
             <iframe name="frame_klein3.html" src="klein3.html"></iframe>
             
-            <a href="klein4.html" target="frame_klein4.html">klein4.html</a>
-            <iframe name="frame_klein4.html" src="klein4.html"></iframe>
+            <a href="torus.html" target="frame_torus.html">torus.html</a>
+            <iframe name="frame_torus.html" src="torus.html"></iframe>
             
             <a href="klein5.html" target="frame_klein5.html">klein5.html</a>
             <iframe name="frame_klein5.html" src="klein5.html"></iframe>
diff --git a/klein4.html b/klein4.html
deleted file mode 100644
index 7ac464e..0000000
--- a/klein4.html
+++ /dev/null
@@ -1,115 +0,0 @@
-<!DOCTYPE html>
-<html lang="en">
-<head>
-    <meta charset="UTF-8">
-    <meta name="viewport" content="width=device-width, initial-scale=1.0">
-    <title>Klein Bottle Transformation</title>
-    <style>
-        body {
-            display: flex;
-            justify-content: center;
-            align-items: center;
-            height: 100vh;
-            margin: 0;
-            background-color: #f0f0f0;
-        }
-        canvas {
-            border: 1px solid black;
-        }
-    </style>
-</head>
-<body>
-    <canvas id="canvas" width="800" height="800"></canvas>
-    <script>
-        const canvas = document.getElementById('canvas');
-        const ctx = canvas.getContext('2d');
-        const width = canvas.width;
-        const height = canvas.height;
-        const centerX = width / 2;
-        const centerY = height / 2;
-        const scale = 80;
-
-        // Rotation angles
-        const angleX = Math.PI / 6; // Rotate around the X-axis
-        const angleY = Math.PI / 6; // Rotate around the Y-axis
-        const angleZ = Math.PI / 6; // Rotate around the Z-axis
-
-        function rotateX(x, y, z, angle) {
-            const cos = Math.cos(angle);
-            const sin = Math.sin(angle);
-            return [x, y * cos - z * sin, y * sin + z * cos];
-        }
-
-        function rotateY(x, y, z, angle) {
-            const cos = Math.cos(angle);
-            const sin = Math.sin(angle);
-            return [x * cos + z * sin, y, -x * sin + z * cos];
-        }
-
-        function rotateZ(x, y, z, angle) {
-            const cos = Math.cos(angle);
-            const sin = Math.sin(angle);
-            return [x * cos - y * sin, x * sin + y * cos, z];
-        }
-
-        function drawKleinBottle() {
-            const uStep = Math.PI / 18;
-            const vStep = 2 * Math.PI / 36;
-
-            for (let u = 0; u < 2 * Math.PI; u += uStep) {
-                for (let v = 0; v < 2 * Math.PI; v += vStep) {
-                    const [x, y, z] = torusToKleinBottle(u, v);
-                    const [nextX, nextY, nextZ] = torusToKleinBottle(u + uStep, v);
-                    const [nextX2, nextY2, nextZ2] = torusToKleinBottle(u, v + vStep);
-
-                    drawLine(project(x, y, z), project(nextX, nextY, nextZ));
-                    drawLine(project(x, y, z), project(nextX2, nextY2, nextZ2));
-                }
-            }
-        }
-
-        function torusToKleinBottle(u, v) {
-            const R = 4; // Major radius
-            const r = 2; // Minor radius
-
-            // Parametric equations for a torus
-            let x = (R + r * Math.cos(v)) * Math.cos(u);
-            let y = (R + r * Math.cos(v)) * Math.sin(u);
-            let z = r * Math.sin(v);
-
-            // Transformation to create a Klein bottle
-            if (u > Math.PI) {
-                x = (R + r * Math.cos(v)) * Math.cos(u);
-                y = (R + r * Math.cos(v)) * Math.sin(u);
-                z = r * Math.sin(v);
-            }
-
-            [x, y, z] = rotateX(x, y, z, angleX);
-            [x, y, z] = rotateY(x, y, z, angleY);
-            [x, y, z] = rotateZ(x, y, z, angleZ);
-
-            return [x, y, z];
-        }
-
-        function project(x, y, z) {
-            const perspective = 500 / (500 + z);
-            return [
-                centerX + x * scale * perspective,
-                centerY - y * scale * perspective
-            ];
-        }
-
-        function drawLine(start, end) {
-            ctx.beginPath();
-            ctx.moveTo(start[0], start[1]);
-            ctx.lineTo(end[0], end[1]);
-            ctx.stroke();
-        }
-
-        ctx.clearRect(0, 0, width, height);
-        ctx.strokeStyle = 'black';
-        drawKleinBottle();
-    </script>
-</body>
-</html>
-

commit 9cb72539b1ea0356fa4919e2e1351ff0d1a4f349
Author: Peter Teoh <htmldeveloper@gmail.com>
Date:   Sat Aug 31 19:46:40 2024 +0800

    new file:   icosahedron.html
    modified:   index.html

diff --git a/icosahedron.html b/icosahedron.html
new file mode 100644
index 0000000..c6d2380
--- /dev/null
+++ b/icosahedron.html
@@ -0,0 +1,145 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Icosahedron Wireframe</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="canvas" width="800" height="800"></canvas>
+    <script>
+        const canvas = document.getElementById('canvas');
+        const ctx = canvas.getContext('2d');
+        const width = canvas.width;
+        const height = canvas.height;
+        const centerX = width / 2;
+        const centerY = height / 2;
+        const scale = 200;
+
+        let angleX = 0;
+        let angleY = 0;
+
+        const vertices = [];
+        const faces = [];
+
+        function initIcosahedron() {
+            const phi = (1 + Math.sqrt(5)) / 2;
+
+            vertices.push([-1, phi, 0]);
+            vertices.push([1, phi, 0]);
+            vertices.push([-1, -phi, 0]);
+            vertices.push([1, -phi, 0]);
+
+            vertices.push([0, -1, phi]);
+            vertices.push([0, 1, phi]);
+            vertices.push([0, -1, -phi]);
+            vertices.push([0, 1, -phi]);
+
+            vertices.push([phi, 0, -1]);
+            vertices.push([phi, 0, 1]);
+            vertices.push([-phi, 0, -1]);
+            vertices.push([-phi, 0, 1]);
+
+            faces.push([0, 11, 5]);
+            faces.push([0, 5, 1]);
+            faces.push([0, 1, 7]);
+            faces.push([0, 7, 10]);
+            faces.push([0, 10, 11]);
+
+            faces.push([1, 5, 9]);
+            faces.push([5, 11, 4]);
+            faces.push([11, 10, 2]);
+            faces.push([10, 7, 6]);
+            faces.push([7, 1, 8]);
+
+            faces.push([3, 9, 4]);
+            faces.push([3, 4, 2]);
+            faces.push([3, 2, 6]);
+            faces.push([3, 6, 8]);
+            faces.push([3, 8, 9]);
+
+            faces.push([4, 9, 5]);
+            faces.push([2, 4, 11]);
+            faces.push([6, 2, 10]);
+            faces.push([8, 6, 7]);
+            faces.push([9, 8, 1]);
+        }
+
+        function rotateX(point, angle) {
+            const cos = Math.cos(angle);
+            const sin = Math.sin(angle);
+            const [x, y, z] = point;
+            return [
+                x,
+                y * cos - z * sin,
+                y * sin + z * cos
+            ];
+        }
+
+        function rotateY(point, angle) {
+            const cos = Math.cos(angle);
+            const sin = Math.sin(angle);
+            const [x, y, z] = point;
+            return [
+                x * cos + z * sin,
+                y,
+                -x * sin + z * cos
+            ];
+        }
+
+        function project(point) {
+            const [x, y, z] = point;
+            const perspective = 1 / (1 - z / 4);
+            return [
+                centerX + x * scale * perspective,
+                centerY - y * scale * perspective
+            ];
+        }
+
+        function drawIcosahedron() {
+            ctx.clearRect(0, 0, width, height);
+            ctx.strokeStyle = 'black';
+
+            const rotatedVertices = vertices.map(v => rotateY(rotateX(v, angleX), angleY));
+
+            faces.forEach(face => {
+                ctx.beginPath();
+                const projectedPoint = project(rotatedVertices[face[0]]);
+                ctx.moveTo(projectedPoint[0], projectedPoint[1]);
+
+                face.forEach(index => {
+                    const [x, y] = project(rotatedVertices[index]);
+                    ctx.lineTo(x, y);
+                });
+
+                ctx.closePath();
+                ctx.stroke();
+            });
+        }
+
+        function animate() {
+            angleX += 0.01;
+            angleY += 0.01;
+            drawIcosahedron();
+            requestAnimationFrame(animate);
+        }
+
+        initIcosahedron();
+        animate();
+    </script>
+</body>
+</html>
+
diff --git a/index.html b/index.html
index 57a15bd..a0174aa 100644
--- a/index.html
+++ b/index.html
@@ -14,6 +14,9 @@
     <body>
         <h1>Files</h1>
     
+            <a href="icosahedron.html" target="frame_icosahedron.html">icosahedron.html</a>
+            <iframe name="frame_icosahedron.html" src="icosahedron.html"></iframe>
+            
             <a href="sphere.html" target="frame_sphere.html">sphere.html</a>
             <iframe name="frame_sphere.html" src="sphere.html"></iframe>
             
@@ -220,4 +223,4 @@
             
     </body>
     </html>
-    
\ No newline at end of file
+    

commit ade9e8f76865c56d8b2be15b7d1d65b2c8fd63b4
Author: Peter Teoh <htmldeveloper@gmail.com>
Date:   Sat Aug 31 19:38:40 2024 +0800

    modified:   klein3.html

diff --git a/klein3.html b/klein3.html
index e1a8341..ed0271d 100644
--- a/klein3.html
+++ b/klein3.html
@@ -16,96 +16,139 @@
         canvas {
             border: 1px solid black;
         }
+        
     </style>
 </head>
 <body>
     <canvas id="canvas" width="800" height="800"></canvas>
     <script>
-        const canvas = document.getElementById('canvas');
-        const ctx = canvas.getContext('2d');
-        const width = canvas.width;
-        const height = canvas.height;
-        const centerX = width / 2;
-        const centerY = height / 2;
-        const scale = 80;
-
-        // Rotation angles
-        const angleX = Math.PI / 6; // Rotate around the X-axis
-        const angleY = Math.PI / 6; // Rotate around the Y-axis
-        const angleZ = Math.PI / 6; // Rotate around the Z-axis
-
-        function rotateX(x, y, z, angle) {
-            const cos = Math.cos(angle);
-            const sin = Math.sin(angle);
-            return [x, y * cos - z * sin, y * sin + z * cos];
+const canvas = document.getElementById('canvas');
+const ctx = canvas.getContext('2d');
+const width = canvas.width;
+const height = canvas.height;
+const centerX = width / 2;
+const centerY = height / 2;
+const scale = 80;
+
+// Rotation angles
+let angleX = Math.PI / 6; // Rotate around the X-axis
+let angleY = Math.PI / 6; // Rotate around the Y-axis
+let angleZ = Math.PI / 6; // Rotate around the Z-axis
+
+let isDragging = false;
+let lastX = 0;
+let lastY = 0;
+
+canvas.addEventListener('mousedown', (e) => {
+    isDragging = true;
+    lastX = e.clientX;
+    lastY = e.clientY;
+});
+
+canvas.addEventListener('mousemove', (e) => {
+    if (isDragging) {
+        const deltaX = e.clientX - lastX;
+        const deltaY = e.clientY - lastY;
+        
+        // Update the angles based on mouse movement
+        angleY += deltaX * 0.01; // Horizontal movement rotates around Y-axis
+        angleX += deltaY * 0.01; // Vertical movement rotates around X-axis
+
+        // Redraw the Klein bottle with the new rotation angles
+        draw();
+
+        lastX = e.clientX;
+        lastY = e.clientY;
+    }
+});
+
+canvas.addEventListener('mouseup', () => {
+    isDragging = false;
+});
+
+canvas.addEventListener('mouseleave', () => {
+    isDragging = false;
+});
+
+function rotateX(x, y, z, angle) {
+    const cos = Math.cos(angle);
+    const sin = Math.sin(angle);
+    return [x, y * cos - z * sin, y * sin + z * cos];
+}
+
+function rotateY(x, y, z, angle) {
+    const cos = Math.cos(angle);
+    const sin = Math.sin(angle);
+    return [x * cos + z * sin, y, -x * sin + z * cos];
+}
+
+function rotateZ(x, y, z, angle) {
+    const cos = Math.cos(angle);
+    const sin = Math.sin(angle);
+    return [x * cos - y * sin, x * sin + y * cos, z];
+}
+
+function drawKleinBottle() {
+    const uStep = Math.PI / 18;
+    const vStep = 2 * Math.PI / 36;
+
+    for (let u = 0; u < 2 * Math.PI; u += uStep) {
+        for (let v = 0; v < 2 * Math.PI; v += vStep) {
+            let x = (4 + 2 * Math.cos(u)) * Math.cos(v);
+            let y = (4 + 2 * Math.cos(u)) * Math.sin(v);
+            let z = 2 * Math.sin(u) * Math.cos(v / 2);
+
+            [x, y, z] = rotateX(x, y, z, angleX);
+            [x, y, z] = rotateY(x, y, z, angleY);
+            [x, y, z] = rotateZ(x, y, z, angleZ);
+
+            let nextX = (4 + 2 * Math.cos(u + uStep)) * Math.cos(v);
+            let nextY = (4 + 2 * Math.cos(u + uStep)) * Math.sin(v);
+            let nextZ = 2 * Math.sin(u + uStep) * Math.cos(v / 2);
+
+            [nextX, nextY, nextZ] = rotateX(nextX, nextY, nextZ, angleX);
+            [nextX, nextY, nextZ] = rotateY(nextX, nextY, nextZ, angleY);
+            [nextX, nextY, nextZ] = rotateZ(nextX, nextY, nextZ, angleZ);
+
+            let nextX2 = (4 + 2 * Math.cos(u)) * Math.cos(v + vStep);
+            let nextY2 = (4 + 2 * Math.cos(u)) * Math.sin(v + vStep);
+            let nextZ2 = 2 * Math.sin(u) * Math.cos((v + vStep) / 2);
+
+            [nextX2, nextY2, nextZ2] = rotateX(nextX2, nextY2, nextZ2, angleX);
+            [nextX2, nextY2, nextZ2] = rotateY(nextX2, nextY2, nextZ2, angleY);
+            [nextX2, nextY2, nextZ2] = rotateZ(nextX2, nextY2, nextZ2, angleZ);
+
+            drawLine(project(x, y, z), project(nextX, nextY, nextZ));
+            drawLine(project(x, y, z), project(nextX2, nextY2, nextZ2));
         }
+    }
+}
+
+function project(x, y, z) {
+    const perspective = 500 / (500 + z);
+    return [
+        centerX + x * scale * perspective,
+        centerY - y * scale * perspective
+    ];
+}
+
+function drawLine(start, end) {
+    ctx.beginPath();
+    ctx.moveTo(start[0], start[1]);
+    ctx.lineTo(end[0], end[1]);
+    ctx.stroke();
+}
+
+function draw() {
+    ctx.clearRect(0, 0, width, height);
+    ctx.strokeStyle = 'black';
+    drawKleinBottle();
+}
+
+// Initial drawing
+draw();
 
-        function rotateY(x, y, z, angle) {
-            const cos = Math.cos(angle);
-            const sin = Math.sin(angle);
-            return [x * cos + z * sin, y, -x * sin + z * cos];
-        }
-
-        function rotateZ(x, y, z, angle) {
-            const cos = Math.cos(angle);
-            const sin = Math.sin(angle);
-            return [x * cos - y * sin, x * sin + y * cos, z];
-        }
-
-        function drawKleinBottle() {
-            const uStep = Math.PI / 18;
-            const vStep = 2 * Math.PI / 36;
-
-            for (let u = 0; u < 2 * Math.PI; u += uStep) {
-                for (let v = 0; v < 2 * Math.PI; v += vStep) {
-                    let x = (4 + 2 * Math.cos(u)) * Math.cos(v);
-                    let y = (4 + 2 * Math.cos(u)) * Math.sin(v);
-                    let z = 2 * Math.sin(u) * Math.cos(v / 2);
-
-                    [x, y, z] = rotateX(x, y, z, angleX);
-                    [x, y, z] = rotateY(x, y, z, angleY);
-                    [x, y, z] = rotateZ(x, y, z, angleZ);
-
-                    let nextX = (4 + 2 * Math.cos(u + uStep)) * Math.cos(v);
-                    let nextY = (4 + 2 * Math.cos(u + uStep)) * Math.sin(v);
-                    let nextZ = 2 * Math.sin(u + uStep) * Math.cos(v / 2);
-
-                    [nextX, nextY, nextZ] = rotateX(nextX, nextY, nextZ, angleX);
-                    [nextX, nextY, nextZ] = rotateY(nextX, nextY, nextZ, angleY);
-                    [nextX, nextY, nextZ] = rotateZ(nextX, nextY, nextZ, angleZ);
-
-                    let nextX2 = (4 + 2 * Math.cos(u)) * Math.cos(v + vStep);
-                    let nextY2 = (4 + 2 * Math.cos(u)) * Math.sin(v + vStep);
-                    let nextZ2 = 2 * Math.sin(u) * Math.cos((v + vStep) / 2);
-
-                    [nextX2, nextY2, nextZ2] = rotateX(nextX2, nextY2, nextZ2, angleX);
-                    [nextX2, nextY2, nextZ2] = rotateY(nextX2, nextY2, nextZ2, angleY);
-                    [nextX2, nextY2, nextZ2] = rotateZ(nextX2, nextY2, nextZ2, angleZ);
-
-                    drawLine(project(x, y, z), project(nextX, nextY, nextZ));
-                    drawLine(project(x, y, z), project(nextX2, nextY2, nextZ2));
-                }
-            }
-        }
-
-        function project(x, y, z) {
-            const perspective = 500 / (500 + z);
-            return [
-                centerX + x * scale * perspective,
-                centerY - y * scale * perspective
-            ];
-        }
-
-        function drawLine(start, end) {
-            ctx.beginPath();
-            ctx.moveTo(start[0], start[1]);
-            ctx.lineTo(end[0], end[1]);
-            ctx.stroke();
-        }
 
-        ctx.clearRect(0, 0, width, height);
-        ctx.strokeStyle = 'black';
-        drawKleinBottle();
     </script>
 </body>
 </html>

commit 79f0e82d38694f64a080f61549e5a0a26c79cdf9
Author: tthtlc <htmldeveloper@gmail.com>
Date:   Sat Aug 31 13:34:21 2024 +0800

    new file:   ovalellipse.html

diff --git a/ovalellipse.html b/ovalellipse.html
new file mode 100644
index 0000000..0425850
--- /dev/null
+++ b/ovalellipse.html
@@ -0,0 +1,163 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Klein Bottle Line Drawing</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+            background-color: #fff;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="kleinBottleCanvas" width="600" height="600"></canvas>
+    <script>
+        const canvas = document.getElementById('kleinBottleCanvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const scale = 100;
+        const numU = 60;
+        const numV = 60;
+
+        let rotationX = 0;
+        let rotationY = 0;
+        let isDragging = false;
+        let lastMouseX = 0;
+        let lastMouseY = 0;
+
+        function rotateX(x, y, z, angle) {
+            const cos = Math.cos(angle);
+            const sin = Math.sin(angle);
+            return [x, y * cos - z * sin, y * sin + z * cos];
+        }
+
+        function rotateY(x, y, z, angle) {
+            const cos = Math.cos(angle);
+            const sin = Math.sin(angle);
+            return [x * cos + z * sin, y, -x * sin + z * cos];
+        }
+
+        function drawKleinBottle() {
+            ctx.clearRect(0, 0, canvas.width, canvas.height);
+            ctx.strokeStyle = '#000000';
+            ctx.lineWidth = 0.5;
+
+            function kleinBottleX(u, v) {
+                if (u < Math.PI) {
+                    return 3 * Math.cos(u) * (1 + Math.sin(u)) + scale * Math.cos(u) * Math.cos(v);
+                } else {
+                    return 3 * Math.cos(u) * (1 + Math.sin(u)) + scale * Math.cos(v + Math.PI);
+                }
+            }
+
+            function kleinBottleY(u, v) {
+                if (u < Math.PI) {
+                    return 3 * Math.sin(u) * (1 + Math.sin(u)) + scale * Math.sin(u) * Math.cos(v);
+                } else {
+                    return 3 * Math.sin(u) * (1 + Math.sin(u));
+                }
+            }
+
+            function kleinBottleZ(u, v) {
+                if (u < Math.PI) {
+                    return scale * Math.sin(v);
+                } else {
+                    return scale * Math.sin(v + Math.PI);
+                }
+            }
+
+            for (let i = 0; i <= numU; i++) {
+                const u = (i / numU) * 2 * Math.PI;
+                ctx.beginPath();
+                for (let j = 0; j <= numV; j++) {
+                    const v = (j / numV) * 2 * Math.PI;
+                    let x = kleinBottleX(u, v);
+                    let y = kleinBottleY(u, v);
+                    let z = kleinBottleZ(u, v);
+
+                    // Apply rotation
+                    [x, y, z] = rotateX(x, y, z, rotationX);
+                    [x, y, z] = rotateY(x, y, z, rotationY);
+
+                    // Simple 2D projection
+                    const xProj = centerX + x - z * 0.5;
+                    const yProj = centerY + y - z * 0.5;
+
+                    if (j === 0) {
+                        ctx.moveTo(xProj, yProj);
+                    } else {
+                        ctx.lineTo(xProj, yProj);
+                    }
+                }
+                ctx.stroke();
+            }
+
+            for (let j = 0; j <= numV; j++) {
+                const v = (j / numV) * 2 * Math.PI;
+                ctx.beginPath();
+                for (let i = 0; i <= numU; i++) {
+                    const u = (i / numU) * 2 * Math.PI;
+                    let x = kleinBottleX(u, v);
+                    let y = kleinBottleY(u, v);
+                    let z = kleinBottleZ(u, v);
+
+                    // Apply rotation
+                    [x, y, z] = rotateX(x, y, z, rotationX);
+                    [x, y, z] = rotateY(x, y, z, rotationY);
+
+                    // Simple 2D projection
+                    const xProj = centerX + x - z * 0.5;
+                    const yProj = centerY + y - z * 0.5;
+
+                    if (i === 0) {
+                        ctx.moveTo(xProj, yProj);
+                    } else {
+                        ctx.lineTo(xProj, yProj);
+                    }
+                }
+                ctx.stroke();
+            }
+        }
+
+        canvas.addEventListener('mousedown', (event) => {
+            isDragging = true;
+            lastMouseX = event.clientX;
+            lastMouseY = event.clientY;
+        });
+
+        canvas.addEventListener('mousemove', (event) => {
+            if (isDragging) {
+                const deltaX = event.clientX - lastMouseX;
+                const deltaY = event.clientY - lastMouseY;
+                rotationY += deltaX * 0.01;
+                rotationX += deltaY * 0.01;
+                lastMouseX = event.clientX;
+                lastMouseY = event.clientY;
+                drawKleinBottle();
+            }
+        });
+
+        canvas.addEventListener('mouseup', () => {
+            isDragging = false;
+        });
+
+        canvas.addEventListener('mouseleave', () => {
+            isDragging = false;
+        });
+
+        drawKleinBottle();
+    </script>
+</body>
+</html>
+

commit 0a38d6edb81ca58de3f09d4e412722596f14dd78
Author: tthtlc <htmldeveloper@gmail.com>
Date:   Sat Aug 31 13:34:10 2024 +0800

    new file:   sphere.html

diff --git a/sphere.html b/sphere.html
new file mode 100644
index 0000000..ea9eb0a
--- /dev/null
+++ b/sphere.html
@@ -0,0 +1,135 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Sphere Triangulation</title>
+    <style>
+        body { margin: 0; }
+        canvas { display: block; }
+    </style>
+</head>
+<body>
+    <canvas id="canvas"></canvas>
+    <script>
+        const canvas = document.getElementById('canvas');
+        const ctx = canvas.getContext('2d');
+        canvas.width = window.innerWidth;
+        canvas.height = window.innerHeight;
+
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const radius = Math.min(centerX, centerY) * 0.5;
+
+        let rotationX = 0;
+        let rotationY = 0;
+
+        let isDragging = false;
+        let lastMouseX = 0;
+        let lastMouseY = 0;
+
+        canvas.addEventListener('mousedown', (e) => {
+            isDragging = true;
+            lastMouseX = e.clientX;
+            lastMouseY = e.clientY;
+        });
+
+        canvas.addEventListener('mouseup', () => {
+            isDragging = false;
+        });
+
+        canvas.addEventListener('mousemove', (e) => {
+            if (isDragging) {
+                const deltaX = e.clientX - lastMouseX;
+                const deltaY = e.clientY - lastMouseY;
+                rotationX += deltaX * 0.01;
+                rotationY += deltaY * 0.01;
+                lastMouseX = e.clientX;
+                lastMouseY = e.clientY;
+                drawSphere();
+            }
+        });
+
+        function drawLine(x1, y1, x2, y2) {
+            ctx.beginPath();
+            ctx.moveTo(x1, y1);
+            ctx.lineTo(x2, y2);
+            ctx.strokeStyle = 'white';
+            ctx.stroke();
+        }
+
+        function drawSphere() {
+            ctx.clearRect(0, 0, canvas.width, canvas.height);
+            ctx.fillStyle = 'black';
+            ctx.fillRect(0, 0, canvas.width, canvas.height);
+
+            const points = [];
+            const triangles = [];
+            const latLines = 20;
+            const longLines = 20;
+
+            for (let lat = 0; lat <= latLines; lat++) {
+                const theta = lat * Math.PI / latLines;
+                const sinTheta = Math.sin(theta);
+                const cosTheta = Math.cos(theta);
+
+                for (let lon = 0; lon <= longLines; lon++) {
+                    const phi = lon * 2 * Math.PI / longLines;
+                    const x = radius * cosTheta * Math.cos(phi);
+                    const y = radius * sinTheta;
+                    const z = radius * cosTheta * Math.sin(phi);
+
+                    points.push({ x, y, z });
+                }
+            }
+
+            for (let lat = 0; lat < latLines; lat++) {
+                for (let lon = 0; lon < longLines; lon++) {
+                    const first = lat * (longLines + 1) + lon;
+                    const second = first + longLines + 1;
+
+                    triangles.push([first, second, first + 1]);
+                    triangles.push([second, second + 1, first + 1]);
+                }
+            }
+
+            triangles.forEach(triangle => {
+                const p1 = project(rotate(points[triangle[0]]));
+                const p2 = project(rotate(points[triangle[1]]));
+                const p3 = project(rotate(points[triangle[2]]));
+
+                drawLine(p1.x + centerX, p1.y + centerY, p2.x + centerX, p2.y + centerY);
+                drawLine(p2.x + centerX, p2.y + centerY, p3.x + centerX, p3.y + centerY);
+                drawLine(p3.x + centerX, p3.y + centerY, p1.x + centerX, p1.y + centerY);
+            });
+        }
+
+        function rotate(point) {
+            const cosX = Math.cos(rotationX);
+            const sinX = Math.sin(rotationX);
+            const cosY = Math.cos(rotationY);
+            const sinY = Math.sin(rotationY);
+
+            let y = point.y * cosY - point.z * sinY;
+            let z = point.y * sinY + point.z * cosY;
+
+            let x = point.x * cosX - z * sinX;
+            z = point.x * sinX + z * cosX;
+
+            return { x, y, z };
+        }
+
+        function project(point) {
+            const distance = 400;
+            const scale = distance / (distance - point.z);
+            return {
+                x: point.x * scale,
+                y: point.y * scale
+            };
+        }
+
+        drawSphere();
+    </script>
+</body>
+</html>
+

commit 84e6c973109b9b0ca0e6eb1a8d51b067a505d919
Author: tthtlc <htmldeveloper@gmail.com>
Date:   Sat Aug 31 13:32:26 2024 +0800

    modified:   index.html

diff --git a/index.html b/index.html
index 822c950..57a15bd 100644
--- a/index.html
+++ b/index.html
@@ -14,15 +14,18 @@
     <body>
         <h1>Files</h1>
     
+            <a href="sphere.html" target="frame_sphere.html">sphere.html</a>
+            <iframe name="frame_sphere.html" src="sphere.html"></iframe>
+            
+            <a href="ovalellipse.html" target="frame_ovalellipse.html">ovalellipse.html</a>
+            <iframe name="frame_ovalellipse.html" src="ovalellipse.html"></iframe>
+            
             <a href="klein2_animation3.html" target="frame_klein2_animation3.html">klein2_animation3.html</a>
             <iframe name="frame_klein2_animation3.html" src="klein2_animation3.html"></iframe>
             
             <a href="klein2_animation.html" target="frame_klein2_animation.html">klein2_animation.html</a>
             <iframe name="frame_klein2_animation.html" src="klein2_animation.html"></iframe>
             
-            <a href="klein2.html" target="frame_klein2.html">klein2.html</a>
-            <iframe name="frame_klein2.html" src="klein2.html"></iframe>
-            
             <a href="klein3.html" target="frame_klein3.html">klein3.html</a>
             <iframe name="frame_klein3.html" src="klein3.html"></iframe>
             
@@ -62,9 +65,6 @@
             <a href="moving_square.html" target="frame_moving_square.html">moving_square.html</a>
             <iframe name="frame_moving_square.html" src="moving_square.html"></iframe>
             
-            <a href="ovalellipse.html" target="frame_ovalellipse.html">ovalellipse.html</a>
-            <iframe name="frame_ovalellipse.html" src="ovalellipse.html"></iframe>
-            
             <a href="quart_motion.html" target="frame_quart_motion.html">quart_motion.html</a>
             <iframe name="frame_quart_motion.html" src="quart_motion.html"></iframe>
             
@@ -86,9 +86,6 @@
             <a href="solid_torus1.html" target="frame_solid_torus1.html">solid_torus1.html</a>
             <iframe name="frame_solid_torus1.html" src="solid_torus1.html"></iframe>
             
-            <a href="solid_torus.html" target="frame_solid_torus.html">solid_torus.html</a>
-            <iframe name="frame_solid_torus.html" src="solid_torus.html"></iframe>
-            
             <a href="special.html" target="frame_special.html">special.html</a>
             <iframe name="frame_special.html" src="special.html"></iframe>
             

commit ed0cb56a175f55274043753e0d0b084cf7ac6d23
Author: tthtlc <htmldeveloper@gmail.com>
Date:   Sat Aug 31 13:30:13 2024 +0800

    modified:   index.html

diff --git a/index.html b/index.html
index 9552789..822c950 100644
--- a/index.html
+++ b/index.html
@@ -14,9 +14,6 @@
     <body>
         <h1>Files</h1>
     
-            <a href="double1.html" target="frame_double1.html">double1.html</a>
-            <iframe name="frame_double1.html" src="double1.html"></iframe>
-            
             <a href="klein2_animation3.html" target="frame_klein2_animation3.html">klein2_animation3.html</a>
             <iframe name="frame_klein2_animation3.html" src="klein2_animation3.html"></iframe>
             

commit 7fb271625387ba627ae498deeb9b7c6e30d8043b
Author: tthtlc <htmldeveloper@gmail.com>
Date:   Sat Aug 31 13:27:08 2024 +0800

     Please enter the commit message for your changes. Lines starting
     with '#' will be ignored, and an empty message aborts the commit.
    
     On branch main
     Your branch is up to date with 'origin/main'.
    
     Changes to be committed:
            deleted:    double1.html
            deleted:    ellipse.html
            deleted:    ellipse_color.html
            deleted:    ellipse_color2.html
            modified:   index.html
            deleted:    klein2.html
            deleted:    line.html
            deleted:    mywebgl.html
            deleted:    not_working.html
            deleted:    o.html
            deleted:    solid_torus.html
            deleted:    spherical_sinusoid2.html
            deleted:    torus.html
            deleted:    try.html
            deleted:    webgl.html
            deleted:    webgl_3dcube.html
    
     Untracked files:
            convert.py
            convert1.py
            convert1.sh
            file.txt
            ovalellipse.html
            rubbish/
            sphere.html

diff --git a/double1.html b/double1.html
deleted file mode 100644
index 70d5931..0000000
--- a/double1.html
+++ /dev/null
@@ -1,55 +0,0 @@
-
-<!DOCTYPE html>
-<html lang="en">
-<head>
-    <meta charset="UTF-8">
-    <meta name="viewport" content="width=device-width, initial-scale=1.0">
-    <title>Complex Line Drawing</title>
-    <style>
-        body {
-            display: flex;
-            justify-content: center;
-            align-items: center;
-            height: 100vh;
-            margin: 0;
-            background-color: #333;
-        }
-        canvas {
-            border: 1px solid black;
-            background-color: #333;
-        }
-    </style>
-</head>
-<body>
-    <canvas id="complexLineCanvas" width="600" height="600"></canvas>
-    <script>
-        const canvas = document.getElementById('complexLineCanvas');
-        const ctx = canvas.getContext('2d');
-        const centerX = canvas.width / 2;
-        const centerY = canvas.height / 2;
-        const numLines = 360;
-
-        // Function to draw the complex pattern
-        function drawComplexPattern() {
-            ctx.strokeStyle = '#ffffff';
-            ctx.lineWidth = 0.5;
-            for (let i = 0; i < numLines; i++) {
-                const angle1 = (i / numLines) * 2 * Math.PI;
-                const angle2 = ((i + 180) / numLines) * 2 * Math.PI;
-                const x1 = centerX + 100 * Math.cos(angle1) * Math.sin(angle2);
-                const y1 = centerY + 100 * Math.sin(angle1) * Math.sin(angle2);
-                const x2 = centerX + 100 * Math.cos(angle2) * Math.sin(angle1);
-                const y2 = centerY + 100 * Math.sin(angle2) * Math.sin(angle1);
-
-                ctx.beginPath();
-                ctx.moveTo(x1, y1);
-                ctx.lineTo(x2, y2);
-                ctx.stroke();
-            }
-        }
-
-        drawComplexPattern();
-    </script>
-</body>
-</html>
-
diff --git a/ellipse.html b/ellipse.html
deleted file mode 100644
index 327e8d4..0000000
--- a/ellipse.html
+++ /dev/null
@@ -1,51 +0,0 @@
-
-<!DOCTYPE html>
-<html lang="en">
-<head>
-    <meta charset="UTF-8">
-    <meta name="viewport" content="width=device-width, initial-scale=1.0">
-    <title>Circle Spokes</title>
-    <style>
-        body {
-            display: flex;
-            justify-content: center;
-            align-items: center;
-            height: 100vh;
-            margin: 0;
-            background-color: #f0f0f0;
-        }
-        canvas {
-            border: 1px solid black;
-        }
-    </style>
-</head>
-<body>
-    <canvas id="circleSpokesCanvas" width="500" height="500"></canvas>
-    <script>
-        const canvas = document.getElementById('circleSpokesCanvas');
-        const ctx = canvas.getContext('2d');
-        const centerX = canvas.width / 2;
-        const centerY = canvas.height / 2;
-        const radius = 200;
-        const numberOfSpokes = 50;
-
-        // Draw the circle
-        ctx.beginPath();
-        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
-        ctx.stroke();
-
-        // Draw the spokes
-        for (let i = 0; i < numberOfSpokes; i++) {
-            const angle = (i / numberOfSpokes) * 2 * Math.PI;
-            const x = centerX + 1.5 * radius * Math.cos(angle);
-            const y = centerY + radius * Math.sin(2*angle);
-
-            ctx.beginPath();
-            ctx.moveTo(centerX, centerY);
-            ctx.lineTo(x, y);
-            ctx.stroke();
-        }
-    </script>
-</body>
-</html>
-
diff --git a/ellipse_color.html b/ellipse_color.html
deleted file mode 100644
index 0864dec..0000000
--- a/ellipse_color.html
+++ /dev/null
@@ -1,61 +0,0 @@
-<!DOCTYPE html>
-<html lang="en">
-<head>
-    <meta charset="UTF-8">
-    <meta name="viewport" content="width=device-width, initial-scale=1.0">
-    <title>Circle Spokes with Different Colors</title>
-    <style>
-        body {
-            display: flex;
-            justify-content: center;
-            align-items: center;
-            height: 100vh;
-            margin: 0;
-            background-color: #f0f0f0;
-        }
-        canvas {
-            border: 1px solid black;
-        }
-    </style>
-</head>
-<body>
-    <canvas id="circleSpokesCanvas" width="500" height="500"></canvas>
-    <script>
-        const canvas = document.getElementById('circleSpokesCanvas');
-        const ctx = canvas.getContext('2d');
-        const centerX = canvas.width / 2;
-        const centerY = canvas.height / 2;
-        const radius = 200;
-        const numberOfSpokes = 20;
-
-        // Function to generate a random color
-        function getRandomColor() {
-            const letters = '0123456789ABCDEF';
-            let color = '#';
-            for (let i = 0; i < 6; i++) {
-                color += letters[Math.floor(Math.random() * 16)];
-            }
-            return color;
-        }
-
-        // Draw the circle
-        ctx.beginPath();
-        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
-        ctx.stroke();
-
-        // Draw the spokes
-        for (let i = 0; i < numberOfSpokes; i++) {
-            const angle = (i / numberOfSpokes) * 2 * Math.PI;
-            const x = centerX + 2 * radius * Math.cos(angle);
-            const y = centerY + radius * Math.sin(3*angle);
-
-            ctx.beginPath();
-            ctx.moveTo(centerX, centerY);
-            ctx.lineTo(x, y);
-            ctx.strokeStyle = getRandomColor();
-            ctx.stroke();
-        }
-    </script>
-</body>
-</html>
-
diff --git a/ellipse_color2.html b/ellipse_color2.html
deleted file mode 100644
index 42b3fbc..0000000
--- a/ellipse_color2.html
+++ /dev/null
@@ -1,63 +0,0 @@
-<!DOCTYPE html>
-<html lang="en">
-<head>
-    <meta charset="UTF-8">
-    <meta name="viewport" content="width=device-width, initial-scale=1.0">
-    <title>Circle Spokes with Different Colors</title>
-    <style>
-        body {
-            display: flex;
-            justify-content: center;
-            align-items: center;
-            height: 100vh;
-            margin: 0;
-            background-color: #f0f0f0;
-        }
-        canvas {
-            border: 1px solid black;
-        }
-    </style>
-</head>
-<body>
-    <canvas id="circleSpokesCanvas" width="500" height="500"></canvas>
-    <script>
-        const canvas = document.getElementById('circleSpokesCanvas');
-        const ctx = canvas.getContext('2d');
-        const centerX = canvas.width / 2;
-        const centerY = canvas.height / 2;
-        const radius = 200;
-        const numberOfSpokes = 20;
-
-        // Function to generate a random color
-        function getRandomColor() {
-            const letters = '0123456789ABCDEF';
-            let color = '#';
-            for (let i = 0; i < 6; i++) {
-                color += letters[Math.floor(Math.random() * 16)];
-            }
-            return color;
-        }
-
-        // Draw the circle
-        ctx.beginPath();
-        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
-        ctx.stroke();
-
-        // Draw the spokes
-        for (let i = 0; i < numberOfSpokes; i++) {
-            const angle = (i / numberOfSpokes) * 2 * Math.PI;
-            centerX =  2 * radius * Math.cos(angle);
-            centerY = radius * Math.sin(3*angle);
-            const x = centerX + 2 * radius * Math.cos(angle);
-            const y = centerY + radius * Math.sin(3*angle);
-
-            ctx.beginPath();
-            ctx.moveTo(centerX, centerY);
-            ctx.lineTo(x, y);
-            ctx.strokeStyle = getRandomColor();
-            ctx.stroke();
-        }
-    </script>
-</body>
-</html>
-
diff --git a/index.html b/index.html
index 8080f18..9552789 100644
--- a/index.html
+++ b/index.html
@@ -1,80 +1,229 @@
-<li><a href="four_petal_rotate.html"> four_petal_rotate.html </a></li>
-<li><a href="four_petal_double.html"> four_petal_double.html </a></li>
-<li><a href="two_ellipse.html"> two_ellipse.html </a></li>
-<li><a href="ellipsical_line_rotate.html"> ellipsical_line_rotate.html </a></li>
-<li><a href="ellipsical_line.html"> ellipsical_line.html </a></li>
-<li><a href="three_petal.html"> three_petal.html </a></li>
-<li><a href="four_petal.html"> four_petal.html </a></li>
-<li><a href="two_petal.html"> two_petal.html </a></li>
-<li><a href="chasing_square2.html"> chasing_square2.html </a></li>
-<li><a href="concentric.html"> concentric.html </a></li>
-<li><a href="static_concentric.html"> static_concentric.html </a></li>
-<li><a href="2d_surface.html"> 2d_surface.html </a></li>
-<li><a href="chasing_square1.html"> chasing_square1.html </a></li>
-<li><a href="chasing_square.html"> chasing_square.html </a></li>
-<li><a href="spherical_sinusoid3.html"> spherical_sinusoid3.html </a></li>
-<li><a href="spherical_sinusoid2.html"> spherical_sinusoid2.html </a></li>
-<li><a href="spherical_sinusoid.html"> spherical_sinusoid.html </a></li>
-<li><a href="spherical_sinusoid1.html"> spherical_sinusoid1.html </a></li>
-<li><a href="sinsoidal5.html"> sinsoidal5.html </a></li>
-<li><a href="sinusoidal.html"> sinusoidal.html </a></li>
-<li><a href="solid_torus1.html"> solid_torus1.html </a></li>
-<li><a href="solid_torus.html"> solid_torus.html </a></li>
-<li><a href="ellipse4.html"> ellipse4.html </a></li>
-<li><a href="o.html"> o.html </a></li>
-<li><a href="torus.html"> torus.html </a></li>
-<li><a href="circle2.html"> circle2.html </a></li>
-<li><a href="css_circle1.html"> css_circle1.html </a></li>
-<li><a href="css_circle.html"> css_circle.html </a></li>
-<li><a href="d3_graph.html"> d3_graph.html </a></li>
-<li><a href="ellipse2.html"> ellipse2.html </a></li>
-<li><a href="ellipse3.html"> ellipse3.html </a></li>
-<li><a href="figure_eight2.html"> figure_eight2.html </a></li>
-<li><a href="figure_eight.html"> figure_eight.html </a></li>
-<li><a href="klein3.html"> klein3.html </a></li>
-<li><a href="klein4.html"> klein4.html </a></li>
-<li><a href="klein5.html"> klein5.html </a></li>
-<li><a href="klein6.html"> klein6.html </a></li>
-<li><a href="klein7.html"> klein7.html </a></li>
-<li><a href="mobius.html"> mobius.html </a></li>
-<li><a href="webgl_3dcube.html"> webgl_3dcube.html </a></li>
-<li><a href="css_3dcube.html"> css_3dcube.html </a></li>
-<li><a href="line_drawing.html"> line_drawing.html </a></li>
-<li><a href="webgl.html"> webgl.html </a></li>
-<li><a href="circle_color.html"> circle_color.html </a></li>
-<li><a href="circle.html"> circle.html </a></li>
-<li><a href="double1.html"> double1.html </a></li>
-<li><a href="double3.html"> double3.html </a></li>
-<li><a href="double4.html"> double4.html </a></li>
-<li><a href="double5.html"> double5.html </a></li>
-<li><a href="double_globe.html"> double_globe.html </a></li>
-<li><a href="double.html"> double.html </a></li>
-<li><a href="double_motion.html"> double_motion.html </a></li>
-<li><a href="drawsector.html"> drawsector.html </a></li>
-<li><a href="ellipse_color2.html"> ellipse_color2.html </a></li>
-<li><a href="ellipse_color.html"> ellipse_color.html </a></li>
-<li><a href="ellipse.html"> ellipse.html </a></li>
-<li><a href="klein2_animation2.html"> klein2_animation2.html </a></li>
-<li><a href="klein2_animation3.html"> klein2_animation3.html </a></li>
-<li><a href="klein2_animation.html"> klein2_animation.html </a></li>
-<li><a href="klein2.html"> klein2.html </a></li>
-<li><a href="klein.html"> klein.html </a></li>
-<li><a href="quart_motion.html"> quart_motion.html </a></li>
-<li><a href="special.html"> special.html </a></li>
-<li><a href="triple_motion.html"> triple_motion.html </a></li>
-<li><a href="mywebgl.html"> mywebgl.html </a></li>
-<li><a href="counter_rotating_sector.html"> counter_rotating_sector.html </a></li>
-<li><a href="rotating_sector.html"> rotating_sector.html </a></li>
-<li><a href="five_rotate_spoke_sector.html"> five_rotate_spoke_sector.html </a></li>
-<li><a href="not_working.html"> not_working.html </a></li>
-<li><a href="five_rotate_spoke.html"> five_rotate_spoke.html </a></li>
-<li><a href="rotating_spoke.html"> rotating_spoke.html </a></li>
-<li><a href="rotating_spiral.html"> rotating_spiral.html </a></li>
-<li><a href="spiral.html"> spiral.html </a></li>
-<li><a href="spoke_subspokes.html"> spoke_subspokes.html </a></li>
-<li><a href="moving_square5.html"> moving_square5.html </a></li>
-<li><a href="moving_square4.html"> moving_square4.html </a></li>
-<li><a href="moving_square3.html"> moving_square3.html </a></li>
-<li><a href="moving_square2.html"> moving_square2.html </a></li>
-<li><a href="moving_square.html"> moving_square.html </a></li>
-<li><a href="line.html"> line.html </a></li>
+
+    <!DOCTYPE html>
+    <html lang="en">
+    <head>
+        <meta charset="UTF-8">
+        <meta name="viewport" content="width=device-width, initial-scale=1.0">
+        <title>Files List</title>
+        <style>
+            body { font-family: Arial, sans-serif; margin: 20px; }
+            a { display: block; margin-bottom: 10px; text-decoration: none; color: blue; }
+            iframe { width: 100%; height: 500px; border: none; margin-top: 20px; }
+        </style>
+    </head>
+    <body>
+        <h1>Files</h1>
+    
+            <a href="double1.html" target="frame_double1.html">double1.html</a>
+            <iframe name="frame_double1.html" src="double1.html"></iframe>
+            
+            <a href="klein2_animation3.html" target="frame_klein2_animation3.html">klein2_animation3.html</a>
+            <iframe name="frame_klein2_animation3.html" src="klein2_animation3.html"></iframe>
+            
+            <a href="klein2_animation.html" target="frame_klein2_animation.html">klein2_animation.html</a>
+            <iframe name="frame_klein2_animation.html" src="klein2_animation.html"></iframe>
+            
+            <a href="klein2.html" target="frame_klein2.html">klein2.html</a>
+            <iframe name="frame_klein2.html" src="klein2.html"></iframe>
+            
+            <a href="klein3.html" target="frame_klein3.html">klein3.html</a>
+            <iframe name="frame_klein3.html" src="klein3.html"></iframe>
+            
+            <a href="klein4.html" target="frame_klein4.html">klein4.html</a>
+            <iframe name="frame_klein4.html" src="klein4.html"></iframe>
+            
+            <a href="klein5.html" target="frame_klein5.html">klein5.html</a>
+            <iframe name="frame_klein5.html" src="klein5.html"></iframe>
+            
+            <a href="klein6.html" target="frame_klein6.html">klein6.html</a>
+            <iframe name="frame_klein6.html" src="klein6.html"></iframe>
+            
+            <a href="klein7.html" target="frame_klein7.html">klein7.html</a>
+            <iframe name="frame_klein7.html" src="klein7.html"></iframe>
+            
+            <a href="klein.html" target="frame_klein.html">klein.html</a>
+            <iframe name="frame_klein.html" src="klein.html"></iframe>
+            
+            <a href="line_drawing.html" target="frame_line_drawing.html">line_drawing.html</a>
+            <iframe name="frame_line_drawing.html" src="line_drawing.html"></iframe>
+            
+            <a href="mobius.html" target="frame_mobius.html">mobius.html</a>
+            <iframe name="frame_mobius.html" src="mobius.html"></iframe>
+            
+            <a href="moving_square2.html" target="frame_moving_square2.html">moving_square2.html</a>
+            <iframe name="frame_moving_square2.html" src="moving_square2.html"></iframe>
+            
+            <a href="moving_square3.html" target="frame_moving_square3.html">moving_square3.html</a>
+            <iframe name="frame_moving_square3.html" src="moving_square3.html"></iframe>
+            
+            <a href="moving_square4.html" target="frame_moving_square4.html">moving_square4.html</a>
+            <iframe name="frame_moving_square4.html" src="moving_square4.html"></iframe>
+            
+            <a href="moving_square5.html" target="frame_moving_square5.html">moving_square5.html</a>
+            <iframe name="frame_moving_square5.html" src="moving_square5.html"></iframe>
+            
+            <a href="moving_square.html" target="frame_moving_square.html">moving_square.html</a>
+            <iframe name="frame_moving_square.html" src="moving_square.html"></iframe>
+            
+            <a href="ovalellipse.html" target="frame_ovalellipse.html">ovalellipse.html</a>
+            <iframe name="frame_ovalellipse.html" src="ovalellipse.html"></iframe>
+            
+            <a href="quart_motion.html" target="frame_quart_motion.html">quart_motion.html</a>
+            <iframe name="frame_quart_motion.html" src="quart_motion.html"></iframe>
+            
+            <a href="rotating_sector.html" target="frame_rotating_sector.html">rotating_sector.html</a>
+            <iframe name="frame_rotating_sector.html" src="rotating_sector.html"></iframe>
+            
+            <a href="rotating_spiral.html" target="frame_rotating_spiral.html">rotating_spiral.html</a>
+            <iframe name="frame_rotating_spiral.html" src="rotating_spiral.html"></iframe>
+            
+            <a href="rotating_spoke.html" target="frame_rotating_spoke.html">rotating_spoke.html</a>
+            <iframe name="frame_rotating_spoke.html" src="rotating_spoke.html"></iframe>
+            
+            <a href="sinsoidal5.html" target="frame_sinsoidal5.html">sinsoidal5.html</a>
+            <iframe name="frame_sinsoidal5.html" src="sinsoidal5.html"></iframe>
+            
+            <a href="sinusoidal.html" target="frame_sinusoidal.html">sinusoidal.html</a>
+            <iframe name="frame_sinusoidal.html" src="sinusoidal.html"></iframe>
+            
+            <a href="solid_torus1.html" target="frame_solid_torus1.html">solid_torus1.html</a>
+            <iframe name="frame_solid_torus1.html" src="solid_torus1.html"></iframe>
+            
+            <a href="solid_torus.html" target="frame_solid_torus.html">solid_torus.html</a>
+            <iframe name="frame_solid_torus.html" src="solid_torus.html"></iframe>
+            
+            <a href="special.html" target="frame_special.html">special.html</a>
+            <iframe name="frame_special.html" src="special.html"></iframe>
+            
+            <a href="spherical_sinusoid1.html" target="frame_spherical_sinusoid1.html">spherical_sinusoid1.html</a>
+            <iframe name="frame_spherical_sinusoid1.html" src="spherical_sinusoid1.html"></iframe>
+            
+            <a href="spherical_sinusoid3.html" target="frame_spherical_sinusoid3.html">spherical_sinusoid3.html</a>
+            <iframe name="frame_spherical_sinusoid3.html" src="spherical_sinusoid3.html"></iframe>
+            
+            <a href="spherical_sinusoid.html" target="frame_spherical_sinusoid.html">spherical_sinusoid.html</a>
+            <iframe name="frame_spherical_sinusoid.html" src="spherical_sinusoid.html"></iframe>
+            
+            <a href="spiral.html" target="frame_spiral.html">spiral.html</a>
+            <iframe name="frame_spiral.html" src="spiral.html"></iframe>
+            
+            <a href="spoke_subspokes.html" target="frame_spoke_subspokes.html">spoke_subspokes.html</a>
+            <iframe name="frame_spoke_subspokes.html" src="spoke_subspokes.html"></iframe>
+            
+            <a href="static_concentric.html" target="frame_static_concentric.html">static_concentric.html</a>
+            <iframe name="frame_static_concentric.html" src="static_concentric.html"></iframe>
+            
+            <a href="three_petal.html" target="frame_three_petal.html">three_petal.html</a>
+            <iframe name="frame_three_petal.html" src="three_petal.html"></iframe>
+            
+            <a href="torus2.html" target="frame_torus2.html">torus2.html</a>
+            <iframe name="frame_torus2.html" src="torus2.html"></iframe>
+            
+            <a href="triple_motion.html" target="frame_triple_motion.html">triple_motion.html</a>
+            <iframe name="frame_triple_motion.html" src="triple_motion.html"></iframe>
+            
+            <a href="try5.html" target="frame_try5.html">try5.html</a>
+            <iframe name="frame_try5.html" src="try5.html"></iframe>
+            
+            <a href="two_ellipse.html" target="frame_two_ellipse.html">two_ellipse.html</a>
+            <iframe name="frame_two_ellipse.html" src="two_ellipse.html"></iframe>
+            
+            <a href="two_petal.html" target="frame_two_petal.html">two_petal.html</a>
+            <iframe name="frame_two_petal.html" src="two_petal.html"></iframe>
+            
+            <a href="double_motion.html" target="frame_double_motion.html">double_motion.html</a>
+            <iframe name="frame_double_motion.html" src="double_motion.html"></iframe>
+            
+            <a href="drawsector.html" target="frame_drawsector.html">drawsector.html</a>
+            <iframe name="frame_drawsector.html" src="drawsector.html"></iframe>
+            
+            <a href="ellipse2.html" target="frame_ellipse2.html">ellipse2.html</a>
+            <iframe name="frame_ellipse2.html" src="ellipse2.html"></iframe>
+            
+            <a href="ellipse3.html" target="frame_ellipse3.html">ellipse3.html</a>
+            <iframe name="frame_ellipse3.html" src="ellipse3.html"></iframe>
+            
+            <a href="ellipse4.html" target="frame_ellipse4.html">ellipse4.html</a>
+            <iframe name="frame_ellipse4.html" src="ellipse4.html"></iframe>
+            
+            <a href="ellipsical_line.html" target="frame_ellipsical_line.html">ellipsical_line.html</a>
+            <iframe name="frame_ellipsical_line.html" src="ellipsical_line.html"></iframe>
+            
+            <a href="ellipsical_line_rotate.html" target="frame_ellipsical_line_rotate.html">ellipsical_line_rotate.html</a>
+            <iframe name="frame_ellipsical_line_rotate.html" src="ellipsical_line_rotate.html"></iframe>
+            
+            <a href="figure_eight2.html" target="frame_figure_eight2.html">figure_eight2.html</a>
+            <iframe name="frame_figure_eight2.html" src="figure_eight2.html"></iframe>
+            
+            <a href="figure_eight.html" target="frame_figure_eight.html">figure_eight.html</a>
+            <iframe name="frame_figure_eight.html" src="figure_eight.html"></iframe>
+            
+            <a href="five_rotate_spoke.html" target="frame_five_rotate_spoke.html">five_rotate_spoke.html</a>
+            <iframe name="frame_five_rotate_spoke.html" src="five_rotate_spoke.html"></iframe>
+            
+            <a href="five_rotate_spoke_sector.html" target="frame_five_rotate_spoke_sector.html">five_rotate_spoke_sector.html</a>
+            <iframe name="frame_five_rotate_spoke_sector.html" src="five_rotate_spoke_sector.html"></iframe>
+            
+            <a href="four_petal_double.html" target="frame_four_petal_double.html">four_petal_double.html</a>
+            <iframe name="frame_four_petal_double.html" src="four_petal_double.html"></iframe>
+            
+            <a href="four_petal.html" target="frame_four_petal.html">four_petal.html</a>
+            <iframe name="frame_four_petal.html" src="four_petal.html"></iframe>
+            
+            <a href="four_petal_rotate.html" target="frame_four_petal_rotate.html">four_petal_rotate.html</a>
+            <iframe name="frame_four_petal_rotate.html" src="four_petal_rotate.html"></iframe>
+            
+            <a href="klein2_animation2.html" target="frame_klein2_animation2.html">klein2_animation2.html</a>
+            <iframe name="frame_klein2_animation2.html" src="klein2_animation2.html"></iframe>
+            
+            <a href="chasing_square1.html" target="frame_chasing_square1.html">chasing_square1.html</a>
+            <iframe name="frame_chasing_square1.html" src="chasing_square1.html"></iframe>
+            
+            <a href="chasing_square2.html" target="frame_chasing_square2.html">chasing_square2.html</a>
+            <iframe name="frame_chasing_square2.html" src="chasing_square2.html"></iframe>
+            
+            <a href="chasing_square.html" target="frame_chasing_square.html">chasing_square.html</a>
+            <iframe name="frame_chasing_square.html" src="chasing_square.html"></iframe>
+            
+            <a href="circle2.html" target="frame_circle2.html">circle2.html</a>
+            <iframe name="frame_circle2.html" src="circle2.html"></iframe>
+            
+            <a href="circle_color.html" target="frame_circle_color.html">circle_color.html</a>
+            <iframe name="frame_circle_color.html" src="circle_color.html"></iframe>
+            
+            <a href="circle.html" target="frame_circle.html">circle.html</a>
+            <iframe name="frame_circle.html" src="circle.html"></iframe>
+            
+            <a href="concentric.html" target="frame_concentric.html">concentric.html</a>
+            <iframe name="frame_concentric.html" src="concentric.html"></iframe>
+            
+            <a href="counter_rotating_sector.html" target="frame_counter_rotating_sector.html">counter_rotating_sector.html</a>
+            <iframe name="frame_counter_rotating_sector.html" src="counter_rotating_sector.html"></iframe>
+            
+            <a href="css_3dcube.html" target="frame_css_3dcube.html">css_3dcube.html</a>
+            <iframe name="frame_css_3dcube.html" src="css_3dcube.html"></iframe>
+            
+            <a href="css_circle1.html" target="frame_css_circle1.html">css_circle1.html</a>
+            <iframe name="frame_css_circle1.html" src="css_circle1.html"></iframe>
+            
+            <a href="css_circle.html" target="frame_css_circle.html">css_circle.html</a>
+            <iframe name="frame_css_circle.html" src="css_circle.html"></iframe>
+            
+            <a href="d3_graph.html" target="frame_d3_graph.html">d3_graph.html</a>
+            <iframe name="frame_d3_graph.html" src="d3_graph.html"></iframe>
+            
+            <a href="double3.html" target="frame_double3.html">double3.html</a>
+            <iframe name="frame_double3.html" src="double3.html"></iframe>
+            
+            <a href="double4.html" target="frame_double4.html">double4.html</a>
+            <iframe name="frame_double4.html" src="double4.html"></iframe>
+            
+            <a href="double5.html" target="frame_double5.html">double5.html</a>
+            <iframe name="frame_double5.html" src="double5.html"></iframe>
+            
+            <a href="double.html" target="frame_double.html">double.html</a>
+            <iframe name="frame_double.html" src="double.html"></iframe>
+            
+    </body>
+    </html>
+    
\ No newline at end of file
diff --git a/klein2.html b/klein2.html
deleted file mode 100644
index 673538d..0000000
--- a/klein2.html
+++ /dev/null
@@ -1,111 +0,0 @@
-<!DOCTYPE html>
-<html lang="en">
-<head>
-    <meta charset="UTF-8">
-    <meta name="viewport" content="width=device-width, initial-scale=1.0">
-    <title>Klein Bottle Line Drawing</title>
-    <style>
-        body {
-            display: flex;
-            justify-content: center;
-            align-items: center;
-            height: 100vh;
-            margin: 0;
-            background-color: #f0f0f0;
-        }
-        canvas {
-            border: 1px solid black;
-            background-color: #fff;
-        }
-    </style>
-</head>
-<body>
-    <canvas id="kleinBottleCanvas" width="600" height="600"></canvas>
-    <script>
-        const canvas = document.getElementById('kleinBottleCanvas');
-        const ctx = canvas.getContext('2d');
-        const centerX = canvas.width / 2;
-        const centerY = canvas.height / 2;
-        const scale = 100;
-        const numU = 60;
-        const numV = 60;
-
-        function drawKleinBottle() {
-            ctx.clearRect(0, 0, canvas.width, canvas.height);
-            ctx.strokeStyle = '#000000';
-            ctx.lineWidth = 0.5;
-
-            function kleinBottleX(u, v) {
-                if (u < Math.PI) {
-                    return 3 * Math.cos(u) * (1 + Math.sin(u)) + scale * Math.cos(u) * Math.cos(v);
-                } else {
-                    return 3 * Math.cos(u) * (1 + Math.sin(u)) + scale * Math.cos(v + Math.PI);
-                }
-            }
-
-            function kleinBottleY(u, v) {
-                if (u < Math.PI) {
-                    return 3 * Math.sin(u) * (1 + Math.sin(u)) + scale * Math.sin(u) * Math.cos(v);
-                } else {
-                    return 3 * Math.sin(u) * (1 + Math.sin(u));
-                }
-            }
-
-            function kleinBottleZ(u, v) {
-                if (u < Math.PI) {
-                    return scale * Math.sin(v);
-                } else {
-                    return scale * Math.sin(v + Math.PI);
-                }
-            }
-
-            for (let i = 0; i <= numU; i++) {
-                const u = (i / numU) * 2 * Math.PI;
-                ctx.beginPath();
-                for (let j = 0; j <= numV; j++) {
-                    const v = (j / numV) * 2 * Math.PI;
-                    const x = kleinBottleX(u, v);
-                    const y = kleinBottleY(u, v);
-                    const z = kleinBottleZ(u, v);
-
-                    // Simple 2D projection
-                    const xProj = centerX + x - z * 0.5;
-                    const yProj = centerY + y - z * 0.5;
-
-                    if (j === 0) {
-                        ctx.moveTo(xProj, yProj);
-                    } else {
-                        ctx.lineTo(xProj, yProj);
-                    }
-                }
-                ctx.stroke();
-            }
-
-            for (let j = 0; j <= numV; j++) {
-                const v = (j / numV) * 2 * Math.PI;
-                ctx.beginPath();
-                for (let i = 0; i <= numU; i++) {
-                    const u = (i / numU) * 2 * Math.PI;
-                    const x = kleinBottleX(u, v);
-                    const y = kleinBottleY(u, v);
-                    const z = kleinBottleZ(u, v);
-
-                    // Simple 2D projection
-                    const xProj = centerX + x - z * 0.5;
-                    const yProj = centerY + y - z * 0.5;
-
-                    if (i === 0) {
-                        ctx.moveTo(xProj, yProj);
-                    } else {
-                        ctx.lineTo(xProj, yProj);
-                    }
-                }
-                ctx.stroke();
-            }
-        }
-
-        drawKleinBottle();
-    </script>
-</body>
-</html>
-
diff --git a/line.html b/line.html
deleted file mode 100644
index 4b8775e..0000000
--- a/line.html
+++ /dev/null
@@ -1,47 +0,0 @@
-
-<!DOCTYPE html>
-<html lang="en">
-<head>
-<meta charset="UTF-8">
-<title>Animated Line Drawing</title>
-<style>
-    canvas {
-        border: 1px solid black;
-    }
-</style>
-</head>
-<body>
-
-<canvas id="myCanvas" width="480" height="320"></canvas>
-
-<script>
-    var canvas = document.getElementById('myCanvas');
-    var ctx = canvas.getContext('2d');
-
-    var startX = 0;
-    var startY = 160;
-    var endX = 0;
-    var endY = 160;
-    var speed = 2;
-
-    function drawLine() {
-        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
-
-        ctx.beginPath();
-        ctx.moveTo(startX, startY);
-        ctx.lineTo(endX, endY);
-        ctx.stroke();
-
-        endX += speed; // Update the end X position for animation
-
-        if (endX < canvas.width) {
-            window.requestAnimationFrame(drawLine); // Recursively call drawLine to animate
-        }
-    }
-
-    drawLine(); // Initial call to start the animation
-</script>
-
-</body>
-</html>
-
diff --git a/mywebgl.html b/mywebgl.html
deleted file mode 100644
index a57b06d..0000000
--- a/mywebgl.html
+++ /dev/null
@@ -1,13 +0,0 @@
-
-<!DOCTYPE html>
-<html lang="en">
-<head>
-    <meta charset="UTF-8">
-    <title>Sector of a Circle</title>
-</head>
-<body>
-    <canvas id="webgl-canvas" width="400" height="400"></canvas>
-    <script src="mywebgl.js"></script>
-</body>
-</html>
-
diff --git a/not_working.html b/not_working.html
deleted file mode 100644
index 00703e1..0000000
--- a/not_working.html
+++ /dev/null
@@ -1,58 +0,0 @@
-<!DOCTYPE html>
-<html>
-<body>
-
-<canvas id="illusionCanvas" width="1200" height="1200"></canvas>
-
-<script>
-const canvas = document.getElementById('illusionCanvas');
-const ctx = canvas.getContext('2d');
-
-const centerX = canvas.width / 2;
-const centerY = canvas.height / 2;
-const sector = 30;
-const star_ngon = 5;
-const maxRadius = Math.min(canvas.width, canvas.height) / 2;
-var sub_shift_angle = 0;
-
-	sub_shift_angle += 2*Math.PI/sector/10;
-function draw_main_spoke(cx, cy, sub_shift_angle) {
-        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
-for (let i = 0; i < star_ngon; i++) {
-	let angle = (i / star_ngon) * 2 * Math.PI;
-    let x = centerX + maxRadius * Math.cos(angle+sub_shift_angle);
-    let y = centerY + maxRadius * Math.sin(angle+sub_shift_angle);
-
-    ctx.strokeStyle = (i % 2 === 0) ? 'black' : 'blue';
-    ctx.lineWidth = 2;
-
-    ctx.beginPath();
-    ctx.moveTo(centerX, centerY);
-    ctx.lineTo(x, y);
-    ctx.stroke();
-}
-        window.requestAnimationFrame(draw_main_spoke); // Continue the animation if the square is not yet at its max size
-}
-
-function draw_spoke(myx, myy, radius, mysector) {
-    for (let i = 0; i < mysector; i++) {
-        let angle = (i / mysector) * 2 * Math.PI;
-
-        let x = myx + radius * Math.cos(angle);
-        let y = myy + radius * Math.sin(angle);
-
-        ctx.strokeStyle = (i % 2 === 0) ? 'black' : 'red';
-
-        ctx.beginPath();
-        ctx.moveTo(myx, myy);
-        ctx.lineTo(x, y);
-        ctx.stroke();
-    }
-}
-
-draw_main_spoke();
-</script>
-
-</body>
-</html>
-
diff --git a/o.html b/o.html
deleted file mode 100644
index 673538d..0000000
--- a/o.html
+++ /dev/null
@@ -1,111 +0,0 @@
-<!DOCTYPE html>
-<html lang="en">
-<head>
-    <meta charset="UTF-8">
-    <meta name="viewport" content="width=device-width, initial-scale=1.0">
-    <title>Klein Bottle Line Drawing</title>
-    <style>
-        body {
-            display: flex;
-            justify-content: center;
-            align-items: center;
-            height: 100vh;
-            margin: 0;
-            background-color: #f0f0f0;
-        }
-        canvas {
-            border: 1px solid black;
-            background-color: #fff;
-        }
-    </style>
-</head>
-<body>
-    <canvas id="kleinBottleCanvas" width="600" height="600"></canvas>
-    <script>
-        const canvas = document.getElementById('kleinBottleCanvas');
-        const ctx = canvas.getContext('2d');
-        const centerX = canvas.width / 2;
-        const centerY = canvas.height / 2;
-        const scale = 100;
-        const numU = 60;
-        const numV = 60;
-
-        function drawKleinBottle() {
-            ctx.clearRect(0, 0, canvas.width, canvas.height);
-            ctx.strokeStyle = '#000000';
-            ctx.lineWidth = 0.5;
-
-            function kleinBottleX(u, v) {
-                if (u < Math.PI) {
-                    return 3 * Math.cos(u) * (1 + Math.sin(u)) + scale * Math.cos(u) * Math.cos(v);
-                } else {
-                    return 3 * Math.cos(u) * (1 + Math.sin(u)) + scale * Math.cos(v + Math.PI);
-                }
-            }
-
-            function kleinBottleY(u, v) {
-                if (u < Math.PI) {
-                    return 3 * Math.sin(u) * (1 + Math.sin(u)) + scale * Math.sin(u) * Math.cos(v);
-                } else {
-                    return 3 * Math.sin(u) * (1 + Math.sin(u));
-                }
-            }
-
-            function kleinBottleZ(u, v) {
-                if (u < Math.PI) {
-                    return scale * Math.sin(v);
-                } else {
-                    return scale * Math.sin(v + Math.PI);
-                }
-            }
-
-            for (let i = 0; i <= numU; i++) {
-                const u = (i / numU) * 2 * Math.PI;
-                ctx.beginPath();
-                for (let j = 0; j <= numV; j++) {
-                    const v = (j / numV) * 2 * Math.PI;
-                    const x = kleinBottleX(u, v);
-                    const y = kleinBottleY(u, v);
-                    const z = kleinBottleZ(u, v);
-
-                    // Simple 2D projection
-                    const xProj = centerX + x - z * 0.5;
-                    const yProj = centerY + y - z * 0.5;
-
-                    if (j === 0) {
-                        ctx.moveTo(xProj, yProj);
-                    } else {
-                        ctx.lineTo(xProj, yProj);
-                    }
-                }
-                ctx.stroke();
-            }
-
-            for (let j = 0; j <= numV; j++) {
-                const v = (j / numV) * 2 * Math.PI;
-                ctx.beginPath();
-                for (let i = 0; i <= numU; i++) {
-                    const u = (i / numU) * 2 * Math.PI;
-                    const x = kleinBottleX(u, v);
-                    const y = kleinBottleY(u, v);
-                    const z = kleinBottleZ(u, v);
-
-                    // Simple 2D projection
-                    const xProj = centerX + x - z * 0.5;
-                    const yProj = centerY + y - z * 0.5;
-
-                    if (i === 0) {
-                        ctx.moveTo(xProj, yProj);
-                    } else {
-                        ctx.lineTo(xProj, yProj);
-                    }
-                }
-                ctx.stroke();
-            }
-        }
-
-        drawKleinBottle();
-    </script>
-</body>
-</html>
-
diff --git a/solid_torus.html b/solid_torus.html
deleted file mode 100644
index 4af7c1d..0000000
--- a/solid_torus.html
+++ /dev/null
@@ -1,157 +0,0 @@
-
-
-
-<!DOCTYPE html>
-<html lang="en">
-<head>
-    <meta charset="UTF-8">
-    <meta name="viewport" content="width=device-width, initial-scale=1.0">
-    <title>3D Shapes with Three.js</title>
-    <style>
-        body { margin: 0; }
-        canvas { display: block; }
-    </style>
-</head>
-<body>
-    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
-    <script>
-        let scene, camera, renderer;
-        let xrot = 0.2, yrot = 0.0, zrot = 0.0;
-        let mouseDown = false;
-        let xdiff = 0.0, ydiff = 0.0;
-        let counter = 0;
-
-        function init() {
-            scene = new THREE.Scene();
-            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 100);
-            camera.position.z = 10;
-
-            renderer = new THREE.WebGLRenderer();
-            renderer.setSize(window.innerWidth, window.innerHeight);
-            document.body.appendChild(renderer.domElement);
-
-            // Wireframe sphere
-            const wireframeSphere = new THREE.Mesh(
-                new THREE.SphereGeometry(2, 10, 10),
-                new THREE.MeshBasicMaterial({ color: 0x800080, wireframe: true })
-            );
-            scene.add(wireframeSphere);
-
-            // Wireframe cube
-            const wireframeCube = new THREE.Mesh(
-                new THREE.BoxGeometry(1, 1, 1),
-                new THREE.MeshBasicMaterial({ color: 0x805050, wireframe: true })
-            );
-            scene.add(wireframeCube);
-
-            // Wireframe torus
-            const wireframeTorus = new THREE.Mesh(
-                new THREE.TorusGeometry(3, 1, 5, 5),
-                new THREE.MeshBasicMaterial({ color: 0x809999, wireframe: true })
-            );
-            scene.add(wireframeTorus);
-
-            // Solid torus
-            const solidTorus = new THREE.Mesh(
-                new THREE.TorusGeometry(4, 2, 6, 18),
-                new THREE.MeshBasicMaterial({ color: 0x80e6ff })
-            );
-            scene.add(solidTorus);
-
-            // Solid shapes
-            const solidDodecahedron = new THREE.Mesh(
-                new THREE.DodecahedronGeometry(),
-                new THREE.MeshBasicMaterial({ color: 0xff0000 })
-            );
-            scene.add(solidDodecahedron);
-
-            const solidOctahedron = new THREE.Mesh(
-                new THREE.OctahedronGeometry(),
-                new THREE.MeshBasicMaterial({ color: 0x00ff00 })
-            );
-            scene.add(solidOctahedron);
-
-            const solidTetrahedron = new THREE.Mesh(
-                new THREE.TetrahedronGeometry(),
-                new THREE.MeshBasicMaterial({ color: 0xffff00 })
-            );
-            scene.add(solidTetrahedron);
-
-            const solidIcosahedron = new THREE.Mesh(
-                new THREE.IcosahedronGeometry(),
-                new THREE.MeshBasicMaterial({ color: 0xff0000 })
-            );
-            scene.add(solidIcosahedron);
-
-            // Conditional teapot shape (approximated with a torus knot for demo)
-            const teapotGeometry = new THREE.TorusKnotGeometry(0.5, 0.2, 100, 16);
-            const teapotMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
-            const solidTeapot = new THREE.Mesh(teapotGeometry, teapotMaterial);
-            scene.add(solidTeapot);
-
-            // Solid cone
-            const solidCone = new THREE.Mesh(
-                new THREE.ConeGeometry(1, 1, 10),
-                new THREE.MeshBasicMaterial({ color: 0x00ff00 })
-            );
-            scene.add(solidCone);
-
-            // Solid cube
-            const solidCube = new THREE.Mesh(
-                new THREE.BoxGeometry(1, 1, 1),
-                new THREE.MeshBasicMaterial({ color: 0xffff00 })
-            );
-            scene.add(solidCube);
-
-            window.addEventListener('resize', onWindowResize, false);
-            document.addEventListener('mousemove', onMouseMove, false);
-            document.addEventListener('mousedown', onMouseDown, false);
-            document.addEventListener('mouseup', onMouseUp, false);
-
-            animate();
-        }
-
-        function animate() {
-            requestAnimationFrame(animate);
-
-            if (!mouseDown) {
-                xrot += 0.3;
-                yrot += 0.3;
-                zrot += 1.0;
-            }
-
-            scene.rotation.x = xrot * Math.PI / 180;
-            scene.rotation.y = yrot * Math.PI / 180;
-            scene.rotation.z = zrot * Math.PI / 180;
-
-            renderer.render(scene, camera);
-        }
-
-        function onWindowResize() {
-            camera.aspect = window.innerWidth / window.innerHeight;
-            camera.updateProjectionMatrix();
-            renderer.setSize(window.innerWidth, window.innerHeight);
-        }
-
-        function onMouseMove(event) {
-            if (mouseDown) {
-                yrot = event.clientX - xdiff;
-                xrot = event.clientY + ydiff;
-            }
-        }
-
-        function onMouseDown(event) {
-            mouseDown = true;
-            xdiff = event.clientX - yrot;
-            ydiff = event.clientY - xrot;
-        }
-
-        function onMouseUp() {
-            mouseDown = false;
-        }
-
-        init();
-    </script>
-</body>
-</html>
-
diff --git a/spherical_sinusoid2.html b/spherical_sinusoid2.html
deleted file mode 100644
index 4a1f7d8..0000000
--- a/spherical_sinusoid2.html
+++ /dev/null
@@ -1,39 +0,0 @@
-<!DOCTYPE html>
-<html lang="en">
-<head>
-    <meta charset="UTF-8">
-    <meta name="viewport" content="width=device-width, initial-scale=1.0">
-    <title>Sinusoidal Waves Around a Sphere (Side View)</title>
-    <style>
-        body, html {
-            margin: 0;
-            padding: 0;
-            overflow: hidden;
-            background-color: #000;
-        }
-        canvas {
-            display: block;
-            background-color: #111;
-        }
-    </style>
-</head>
-<body>
-    <canvas id="waveCanvas"></canvas>
-
-    <script>
-        const canvas = document.getElementById('waveCanvas');
-        const ctx = canvas.getContext('2d');
-
-        canvas.width = window.innerWidth;
-        canvas.height = window.innerHeight;
-
-        const centerX = canvas.width / 2;
-        const centerY = canvas.height / 2;
-        const radius = Math.min(canvas.width, canvas.height) / 3;
-
-        let waveOffset1 = 0;
-        let waveOffset2 = 0;
-        let waveOffset3 = 0;
-        let waveOffset4 = 0;
-        let waveOffset5 =
-
diff --git a/torus.html b/torus.html
deleted file mode 100644
index efc0ec9..0000000
--- a/torus.html
+++ /dev/null
@@ -1,118 +0,0 @@
-<!DOCTYPE html>
-<html lang="en">
-<head>
-    <meta charset="UTF-8">
-    <meta name="viewport" content="width=device-width, initial-scale=1.0">
-    <title>3D Shapes Wireframe</title>
-    <style>
-        body {
-            display: flex;
-            justify-content: center;
-            align-items: center;
-            height: 100vh;
-            margin: 0;
-            background-color: #f0f0f0;
-        }
-        canvas {
-            border: 1px solid black;
-        }
-    </style>
-</head>
-<body>
-    <canvas id="canvas" width="800" height="800"></canvas>
-    <script>
-        const canvas = document.getElementById('canvas');
-        const ctx = canvas.getContext('2d');
-        const width = canvas.width;
-        const height = canvas.height;
-        const centerX = width / 2;
-        const centerY = height / 2;
-        const scale = 50;
-
-        function drawShapes() {
-            //drawMobiusStrip(centerX - 250, centerY - 250);
-            //drawKleinBottle(centerX + 250, centerY - 250);
-            drawTorus(centerX, centerY); 
-        }
-
-        function drawMobiusStrip(offsetX, offsetY) {
-            const uStep = Math.PI / 18;
-            const vStep = 2 * Math.PI / 36;
-
-            for (let u = 0; u < 4 * Math.PI; u += uStep) {
-                for (let v = 1.0; v < 12.5; v += vStep) {
-                    const x = (1 + v * Math.cos(u / 2)) * Math.cos(u);
-                    const y = (1 + v * Math.cos(u / 2)) * Math.sin(u);
-                    const z = v * Math.sin(u / 2);
-
-                    const nextX = (1 + v * Math.cos((u + uStep) / 2)) * Math.cos(u + uStep);
-                    const nextY = (1 + v * Math.cos((u + uStep) / 2)) * Math.sin(u + uStep);
-                    const nextZ = v * Math.sin((u + uStep) / 2);
-
-                    drawLine(offsetX, offsetY, project(x, y, z), project(nextX, nextY, nextZ));
-                }
-            }
-        }
-
-        function drawKleinBottle(offsetX, offsetY) {
-            const uStep = Math.PI / 18;
-            const vStep = 2 * Math.PI / 36;
-
-            for (let u = 0; u < 4 * Math.PI; u += uStep) {
-                for (let v = 0; v < 4 * Math.PI; v += vStep) {
-                    const x = (10 + 20 * Math.cos(u)) * Math.cos(v);
-                    const y = (30 + 10* Math.cos(u)) * Math.sin(v);
-                    const z = 20 * Math.sin(u) * Math.cos(v / 2);
-
-                    const nextX = (40 + 2 * Math.cos(u + uStep)) * Math.cos(v);
-                    const nextY = (40 + 2 * Math.cos(u + uStep)) * Math.sin(v);
-                    const nextZ = 2 * Math.sin(u + uStep) * Math.cos(v / 2);
-
-                    drawLine(offsetX, offsetY, project(x, y, z), project(nextX, nextY, nextZ));
-                }
-            }
-        }
-
-        function drawTorus(offsetX, offsetY) {
-            const uStep = Math.PI / 18;
-            const vStep = 2 * Math.PI / 36;
-
-            for (let u = 0; u < 4 * Math.PI; u += uStep) {
-                for (let v = 0; v < 4 * Math.PI; v += vStep) {
-                    const R = 40;
-                    const r = 10;
-                    const x = (R + r * Math.cos(v)) * Math.cos(u);
-                    const y = (R + r * Math.cos(v)) * Math.sin(u);
-                    const z = r * Math.sin(v);
-
-                    const nextX = (R + r * Math.cos(v + vStep)) * Math.cos(u);
-                    const nextY = (R + r * Math.cos(v + vStep)) * Math.sin(u);
-                    const nextZ = r * Math.sin(v + vStep);
-
-                    drawLine(offsetX, offsetY, project(x, y, z), project(nextX, nextY, nextZ));
-                }
-            }
-        }
-
-        function project(x, y, z) {
-            const perspective = 500 / (500 + z);
-            return [
-                centerX + x * scale * perspective,
-                centerY - y * scale * perspective
-            ];
-        }
-
-        function drawLine(offsetX, offsetY, start, end) {
-            ctx.beginPath();
-            ctx.moveTo(start[0] + offsetX, start[1] + offsetY);
-            ctx.lineTo(end[0] + offsetX, end[1] + offsetY);
-            ctx.stroke();
-        }
-
-        ctx.clearRect(0, 0, width, height);
-        ctx.strokeStyle = 'black';
-        drawShapes();
-    </script>
-</body>
-</html>
-
diff --git a/try.html b/try.html
deleted file mode 100644
index 483a050..0000000
--- a/try.html
+++ /dev/null
@@ -1,83 +0,0 @@
-<!DOCTYPE html>
-<html lang="en">
-<head>
-    <meta charset="UTF-8">
-    <meta name="viewport" content="width=device-width, initial-scale=1.0">
-    <title>Enneper Surface Visualization</title>
-    <style>
-        body { margin: 0; }
-        canvas { display: block; }
-    </style>
-</head>
-<body>
-    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
-
-    <script>
-        function enneperSurface(u, v, n) {
-            const x = u - Math.pow(u, 2*n+1) / (2*n+1) + u * v * v;
-            const y = -v + Math.pow(v, 2*n+1) / (2*n+1) + v * u * u;
-            const z = u * u - v * v;
-            return { x, y, z };
-        }
-
-        function createSurfaceGeometry(n, resolution = 50) {
-            const geometry = new THREE.BufferGeometry();
-            const vertices = [];
-
-            for (let i = 0; i < resolution; i++) {
-                for (let j = 0; j < resolution; j++) {
-                    const u = (i / resolution) * 4 - 2;  // Map i to range [-2, 2]
-                    const v = (j / resolution) * 4 - 2;  // Map j to range [-2, 2]
-                    const point = enneperSurface(u, v, n);
-                    vertices.push(point.x, point.y, point.z);
-                }
-            }
-
-            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
-            return geometry;
-        }
-
-        function createScene() {
-            const scene = new THREE.Scene();
-            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
-            const renderer = new THREE.WebGLRenderer({ antialias: true });
-            renderer.setSize(window.innerWidth, window.innerHeight);
-            document.body.appendChild(renderer.domElement);
-
-            const light = new THREE.DirectionalLight(0xffffff, 1);
-            light.position.set(5, 5, 5).normalize();
-            scene.add(light);
-
-            const material = new THREE.MeshPhongMaterial({ color: 0x00cccc, side: THREE.DoubleSide, wireframe: false, transparent: true, opacity: 0.6 });
-
-            const surfaces = [];
-            const nValues = [1, 2, 3, 4];
-
-            nValues.forEach((n) => {
-                const geometry = createSurfaceGeometry(n);
-                const surface = new THREE.Mesh(geometry, material);
-                surfaces.push(surface);
-                scene.add(surface);
-            });
-
-            camera.position.z = 5;
-
-            function animate() {
-                requestAnimationFrame(animate);
-
-                surfaces.forEach((surface, index) => {
-                    surface.rotation.x += 0.01;
-                    surface.rotation.y += 0.01;
-                });
-
-                renderer.render(scene, camera);
-            }
-
-            animate();
-        }
-
-        createScene();
-    </script>
-</body>
-</html>
-
diff --git a/webgl.html b/webgl.html
deleted file mode 100644
index 33572f4..0000000
--- a/webgl.html
+++ /dev/null
@@ -1,18 +0,0 @@
-
-<!DOCTYPE html>
-<html lang="en">
-<head>
-    <meta charset="UTF-8">
-    <meta name="viewport" content="width=device-width, initial-scale=1.0">
-    <title>WebGL Example</title>
-    <style>
-        body { margin: 0; }
-        canvas { display: block; width: 100vw; height: 100vh; }
-    </style>
-</head>
-<body>
-    <canvas id="glCanvas"></canvas>
-    <script src="main.js"></script>
-</body>
-</html>
-
diff --git a/webgl_3dcube.html b/webgl_3dcube.html
deleted file mode 100644
index 9f6f63e..0000000
--- a/webgl_3dcube.html
+++ /dev/null
@@ -1,344 +0,0 @@
-<!DOCTYPE html>
-<html lang="en">
-<head>
-  <meta charset="UTF-8">
-  <meta name="viewport" content="width=device-width, initial-scale=1.0">
-  <title>3D Rotating Cube with WebGL</title>
-  <style>
-    body {
-      margin: 0;
-      display: flex;
-      justify-content: center;
-      align-items: center;
-      height: 100vh;
-      background-color: #f0f0f0;
-    }
-    canvas {
-      border: 1px solid #000;
-    }
-  </style>
-</head>
-<body>
-  <canvas id="glCanvas" width="640" height="480"></canvas>
-  <script>
-    // Add the JavaScript code here
-
-const canvas = document.getElementById('glCanvas');
-const gl = canvas.getContext('webgl');
-
-if (!gl) {
-  console.log('WebGL not supported, falling back on experimental-webgl');
-  gl = canvas.getContext('experimental-webgl');
-}
-
-if (!gl) {
-  alert('Your browser does not support WebGL');
-}
-
-// Vertex shader program
-const vsSource = `
-  attribute vec4 aVertexPosition;
-  attribute vec4 aVertexColor;
-  uniform mat4 uModelViewMatrix;
-  uniform mat4 uProjectionMatrix;
-  varying lowp vec4 vColor;
-  void main(void) {
-    gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
-    vColor = aVertexColor;
-  }
-`;
-
-// Fragment shader program
-const fsSource = `
-  varying lowp vec4 vColor;
-  void main(void) {
-    gl_FragColor = vColor;
-  }
-`;
-
-// Initialize a shader program; this is where all the lighting for the vertices and so forth is established.
-const shaderProgram = initShaderProgram(gl, vsSource, fsSource);
-
-// Collect all the info needed to use the shader program.
-const programInfo = {
-  program: shaderProgram,
-  attribLocations: {
-    vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
-    vertexColor: gl.getAttribLocation(shaderProgram, 'aVertexColor'),
-  },
-  uniformLocations: {
-    projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
-    modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
-  },
-};
-
-// Here's where we call the routine that builds all the objects we'll be drawing.
-const buffers = initBuffers(gl);
-
-let then = 0;
-
-// Draw the scene repeatedly
-function render(now) {
-  now *= 0.001;  // convert to seconds
-  const deltaTime = now - then;
-  then = now;
-
-  drawScene(gl, programInfo, buffers, deltaTime);
-
-  requestAnimationFrame(render);
-}
-requestAnimationFrame(render);
-
-// Initialize the buffers we'll need. For this demo, we just have one object -- a simple three-dimensional cube.
-function initBuffers(gl) {
-
-  // Create a buffer for the cube's vertex positions.
-  const positionBuffer = gl.createBuffer();
-
-  // Select the positionBuffer as the one to apply buffer operations to from here out.
-  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
-
-  // Now create an array of positions for the cube.
-  const positions = [
-     // Front face
-     -1.0, -1.0,  1.0,
-      1.0, -1.0,  1.0,
-      1.0,  1.0,  1.0,
-     -1.0,  1.0,  1.0,
-
-     // Back face
-     -1.0, -1.0, -1.0,
-     -1.0,  1.0, -1.0,
-      1.0,  1.0, -1.0,
-      1.0, -1.0, -1.0,
-
-     // Top face
-     -1.0,  1.0, -1.0,
-     -1.0,  1.0,  1.0,
-      1.0,  1.0,  1.0,
-      1.0,  1.0, -1.0,
-
-     // Bottom face
-     -1.0, -1.0, -1.0,
-      1.0, -1.0, -1.0,
-      1.0, -1.0,  1.0,
-     -1.0, -1.0,  1.0,
-
-     // Right face
-      1.0, -1.0, -1.0,
-      1.0,  1.0, -1.0,
-      1.0,  1.0,  1.0,
-      1.0, -1.0,  1.0,
-
-     // Left face
-     -1.0, -1.0, -1.0,
-     -1.0, -1.0,  1.0,
-     -1.0,  1.0,  1.0,
-     -1.0,  1.0, -1.0,
-  ];
-
-  // Now pass the list of positions into WebGL to build the shape. We do this by creating a Float32Array from the JavaScript array, then use it to fill the current buffer.
-  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
-
-  // Now set up the colors for the faces. We'll use solid colors for each face.
-  const faceColors = [
-    [1.0,  1.0,  1.0,  1.0],    // Front face: white
-    [1.0,  0.0,  0.0,  1.0],    // Back face: red
-    [0.0,  1.0,  0.0,  1.0],    // Top face: green
-    [0.0,  0.0,  1.0,  1.0],    // Bottom face: blue
-    [1.0,  1.0,  0.0,  1.0],    // Right face: yellow
-    [1.0,  0.0,  1.0,  1.0],    // Left face: purple
-  ];
-
-  // Convert the array of colors into a table for all the vertices.
-  var colors = [];
-
-  for (var j = 0; j < faceColors.length; ++j) {
-    const c = faceColors[j];
-
-    // Repeat each color four times for the four vertices of the face
-    colors = colors.concat(c, c, c, c);
-  }
-
-  const colorBuffer = gl.createBuffer();
-  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
-  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
-
-  // Build the element array buffer; this specifies the indices into the vertex arrays for each face's vertices.
-  const indexBuffer = gl.createBuffer();
-  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
-
-  // This array defines each face as two triangles, using the indices into the vertex array to specify each triangle's position.
-  const indices = [
-    0,  1,  2,      0,  2,  3,    // front
-    4,  5,  6,      4,  6,  7,    // back
-    8,  9,  10,     8,  10, 11,   // top
-    12, 13, 14,     12, 14, 15,   // bottom
-    16, 17, 18,     16, 18, 19,   // right
-    20, 21, 22,     20, 22, 23,   // left
-  ];
-
-  // Now send the element array to GL
-  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
-
-  return {
-    position: positionBuffer,
-    color: colorBuffer,
-    indices: indexBuffer,
-  };
-}
-
-// Draw the scene.
-function drawScene(gl, programInfo, buffers, deltaTime) {
-  gl.clearColor(0.0, 0.0, 0.0, 1.0);  // Clear to black, fully opaque
-  gl.clearDepth(1.0);                 // Clear everything
-  gl.enable(gl.DEPTH_TEST);           // Enable depth testing
-  gl.depthFunc(gl.LEQUAL);            // Near things obscure far things
-
-  // Clear the canvas before we start drawing on it.
-  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
-
-  // Create a perspective matrix, a special matrix that is used to simulate the distortion of perspective in a camera. Our field of view is 45 degrees, with a width/height ratio that matches the display size of the canvas and we only want to see objects between 0.1 units and 100 units away from the camera.
-  const fieldOfView = 45 * Math.PI / 180;   // in radians
-  const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
-  const zNear = 0.1;
-  const zFar = 100.0;
-  const projectionMatrix = mat4.create();
-
-  mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);
-
-  // Set the drawing position to the "identity" point, which is the center of the scene.
-  const modelViewMatrix = mat4.create();
-
-  // Now move the drawing position a bit to where we want to start drawing the square.
-  mat4.translate(modelViewMatrix,     // destination matrix
-                 modelViewMatrix,     // matrix to translate
-                 [-0.0, 0.0, -6.0]);  // amount to translate
-
-  mat4.rotate(modelViewMatrix,  // destination matrix
-              modelViewMatrix,  // matrix to rotate
-              cubeRotation,     // amount to rotate in radians
-              [0, 0, 1]);       // axis to rotate around (Z)
-
-  mat4.rotate(modelViewMatrix,  // destination matrix
-              modelViewMatrix,  // matrix to rotate
-              cubeRotation * .7,// amount to rotate in radians
-              [0, 1, 0]);       // axis to rotate around (Y)
-
-  mat4.rotate(modelViewMatrix,  // destination matrix
-              modelViewMatrix,  // matrix to rotate
-              cubeRotation * .3,// amount to rotate in radians
-              [1, 0, 0]);       // axis to rotate around (X)
-
-  // Tell WebGL how to pull out the positions from the position buffer into the vertexPosition attribute.
-  {
-    const numComponents = 3;
-    const type = gl.FLOAT;
-    const normalize = false;
-    const stride = 0;
-    const offset = 0;
-    gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
-    gl.vertexAttribPointer(
-        programInfo.attribLocations.vertexPosition,
-        numComponents,
-        type,
-        normalize,
-        stride,
-        offset);
-    gl.enableVertexAttribArray(
-        programInfo.attribLocations.vertexPosition);
-  }
-
-  // Tell WebGL how to pull out the colors from the color buffer into the vertexColor attribute.
-  {
-    const numComponents = 4;
-    const type = gl.FLOAT;
-    const normalize = false;
-    const stride = 0;
-    const offset = 0;
-    gl.bindBuffer(gl.ARRAY_BUFFER, buffers.color);
-    gl.vertexAttribPointer(
-        programInfo.attribLocations.vertexColor,
-        numComponents,
-        type,
-        normalize,
-        stride,
-        offset);
-    gl.enableVertexAttribArray(
-        programInfo.attribLocations.vertexColor);
-  }
-
-  // Tell WebGL which indices to use to index the vertices
-  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);
-
-  // Tell WebGL to use our program when drawing
-  gl.useProgram(programInfo.program);
-
-  // Set the shader uniforms
-  gl.uniformMatrix4fv(
-      programInfo.uniformLocations.projectionMatrix,
-      false,
-      projectionMatrix);
-  gl.uniformMatrix4fv(
-      programInfo.uniformLocations.modelViewMatrix,
-      false,
-      modelViewMatrix);
-
-  {
-    const vertexCount = 36;
-    const type = gl.UNSIGNED_SHORT;
-    const offset = 0;
-    gl.drawElements(gl.TRIANGLES, vertexCount, type, offset);
-  }
-
-  // Update the rotation for the next draw
-  cubeRotation += deltaTime;
-}
-
-// Initialize a shader program, so WebGL knows how to draw our data
-function initShaderProgram(gl, vsSource, fsSource) {
-  const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
-  const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
-
-  // Create the shader program
-  const shaderProgram = gl.createProgram();
-  gl.attachShader(shaderProgram, vertexShader);
-  gl.attachShader(shaderProgram, fragmentShader);
-  gl.linkProgram(shaderProgram);
-
-  // If creating the shader program failed, alert
-  if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
-    alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
-    return null;
-  }
-
-  return shaderProgram;
-}
-
-// creates a shader of the given type, uploads the source and compiles it.
-function loadShader(gl, type, source) {
-  const shader = gl.createShader(type);
-
-  // Send the source to the shader object
-  gl.shaderSource(shader, source);
-
-  // Compile the shader program
-  gl.compileShader(shader);
-
-  // See if it compiled successfully
-  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
-    alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
-    gl.deleteShader(shader);
-    return null;
-  }
-
-  return shader;
-}
-
-var cubeRotation = 0.0;
-
-
-  </script>
-</body>
-</html>
-

commit 3deb71df55296edfe1aa71548394b5b5305da8b6
Author: tthtlc <htmldeveloper@gmail.com>
Date:   Sat Aug 31 10:03:41 2024 +0800

     Changes to be committed:
            new file:   chasing_square.html
            new file:   chasing_square1.html
            new file:   chasing_square2.html
            new file:   circle.html
            new file:   circle2.html
            new file:   circle_color.html
            new file:   concentric.html
            new file:   counter_rotating_sector.html
            new file:   css_3dcube.html
            new file:   css_circle.html
            new file:   css_circle1.html
            new file:   css_script.js
            new file:   css_script1.js
            new file:   css_style.css
            new file:   css_style1.css
            new file:   d3_graph.html
            new file:   d3_graph.js
            new file:   double.html
            new file:   double1.html
            new file:   double3.html
            new file:   double4.html
            new file:   double5.html
            new file:   double_motion.html
            new file:   drawsector.html
            new file:   drawsector.js
            new file:   drawsector0.js
            new file:   drawsector1.js
            new file:   drawsector2.js
            new file:   ellipse.html
            new file:   ellipse2.html
            new file:   ellipse3.html
            new file:   ellipse4.html
            new file:   ellipse_color.html
            new file:   ellipse_color2.html
            new file:   ellipsical_line.html
            new file:   ellipsical_line.js
            new file:   ellipsical_line_rotate.html
            new file:   ellipsical_line_rotate.js
            new file:   figure_eight.html
            new file:   figure_eight2.html
            new file:   five_rotate_spoke.html
            new file:   five_rotate_spoke_sector.html
            new file:   four_petal.html
            new file:   four_petal.js
            new file:   four_petal_double.html
            new file:   four_petal_double.js
            new file:   four_petal_rotate.html
            new file:   four_petal_rotate.js
            new file:   index.html
            new file:   klein.html
            new file:   klein2.html
            new file:   klein2_animation.html
            new file:   klein2_animation2.html
            new file:   klein2_animation3.html
            new file:   klein3.html
            new file:   klein4.html
            new file:   klein5.html
            new file:   klein6.html
            new file:   klein7.html
            new file:   line.html
            new file:   line_drawing.html
            new file:   main.js
            new file:   mobius.html
            new file:   moving_square.html
            new file:   moving_square2.html
            new file:   moving_square3.html
            new file:   moving_square4.html
            new file:   moving_square5.html
            new file:   mywebgl.html
            new file:   mywebgl.js
            new file:   not_working.html
            new file:   o.html
            new file:   quart_motion.html
            new file:   rotating_sector.html
            new file:   rotating_spiral.html
            new file:   rotating_spoke.html
            new file:   sinsoidal5.html
            new file:   sinusoidal.html
            new file:   solid_torus.html
            new file:   solid_torus1.html
            new file:   special.html
            new file:   spherical_sinusoid.html
            new file:   spherical_sinusoid1.html
            new file:   spherical_sinusoid2.html
            new file:   spherical_sinusoid3.html
            new file:   spiral.html
            new file:   spoke_subspokes.html
            new file:   static_concentric.html
            new file:   three_petal.html
            new file:   three_petal.js
            new file:   torus.html
            new file:   torus2.html
            new file:   triple_motion.html
            new file:   try.html
            new file:   try5.html
            new file:   two_ellipse.html
            new file:   two_ellipse.js
            new file:   two_petal.html
            new file:   two_petal.js
            new file:   webgl.html
            new file:   webgl_3dcube.html

diff --git a/chasing_square.html b/chasing_square.html
new file mode 100644
index 0000000..187d6da
--- /dev/null
+++ b/chasing_square.html
@@ -0,0 +1,54 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Canvas Pattern</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #fff;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="patternCanvas" width="500" height="500"></canvas>
+    <script>
+        const canvas = document.getElementById('patternCanvas');
+        const ctx = canvas.getContext('2d');
+
+        function drawPattern() {
+            const radius = 100;
+            const spacing = 10;
+            const rows = 5;
+            const cols = 5;
+
+            for (let row = 0; row < rows; row++) {
+                for (let col = 0; col < cols; col++) {
+                    const x = col * 2 * radius * 0.5 + radius;
+                    const y = row * 2 * radius * 0.5 + radius;
+                    drawArcSet(x, y, radius, spacing);
+                }
+            }
+        }
+
+        function drawArcSet(x, y, radius, spacing) {
+            for (let i = 0; i < radius / spacing; i++) {
+                ctx.beginPath();
+                ctx.arc(x, y, radius - i * spacing, 0, Math.PI, false);
+                ctx.stroke();
+            }
+        }
+
+        drawPattern();
+    </script>
+</body>
+</html>
+
diff --git a/chasing_square1.html b/chasing_square1.html
new file mode 100644
index 0000000..5938e61
--- /dev/null
+++ b/chasing_square1.html
@@ -0,0 +1,58 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Canvas Pattern</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #fff;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="patternCanvas" width="500" height="500"></canvas>
+    <script>
+        const canvas = document.getElementById('patternCanvas');
+        const ctx = canvas.getContext('2d');
+        const width = canvas.width;
+        const height = canvas.height;
+        const radius = 100;
+        const lineWidth = 2;
+
+        ctx.lineWidth = lineWidth;
+        ctx.strokeStyle = '#000';
+
+        function drawPattern() {
+            const offsetX = radius;
+            const offsetY = radius;
+            const spacing = 10;
+
+            for (let i = 0; i <= width / radius; i++) {
+                for (let j = 0; j <= height / radius; j++) {
+                    drawArcs(i * offsetX, j * offsetY, radius, spacing);
+                }
+            }
+        }
+
+        function drawArcs(x, y, radius, spacing) {
+            for (let r = radius; r > 0; r -= spacing) {
+                ctx.beginPath();
+                ctx.arc(x, y, r, 0, Math.PI * 2, false);
+                ctx.stroke();
+            }
+        }
+
+        drawPattern();
+    </script>
+</body>
+</html>
+
diff --git a/chasing_square2.html b/chasing_square2.html
new file mode 100644
index 0000000..5f39f53
--- /dev/null
+++ b/chasing_square2.html
@@ -0,0 +1,64 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Canvas Pattern</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #fff;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="patternCanvas" width="500" height="500"></canvas>
+    <script>
+        const canvas = document.getElementById('patternCanvas');
+        const ctx = canvas.getContext('2d');
+        const width = canvas.width;
+        const height = canvas.height;
+        const radius = 100;
+        const lineWidth = 2;
+
+        ctx.lineWidth = lineWidth;
+
+        const colors = ['#FF5733', '#33FF57', '#3357FF', '#FF33A1', '#A133FF']; // Array of colors
+        const numColors = colors.length;
+
+        function drawPattern() {
+            const offsetX = radius;
+            const offsetY = radius;
+            const spacing = 10;
+
+            for (let i = 0; i <= width / radius; i++) {
+                for (let j = 0; j <= height / radius; j++) {
+                    drawArcs(i * offsetX, j * offsetY, radius, spacing);
+                }
+            }
+        }
+
+        function drawArcs(x, y, radius, spacing) {
+            let colorIndex = Math.floor(Math.random() * 16);
+
+            for (let r = radius; r > 0; r -= spacing) {
+                ctx.strokeStyle = colors[colorIndex % numColors];
+                ctx.beginPath();
+                ctx.arc(x, y, r, 0, Math.PI * 2, false);
+                ctx.stroke();
+                
+                colorIndex++; // Move to the next color in the array
+            }
+        }
+ 	drawPattern();
+    </script>
+</body>
+</html>
+
diff --git a/circle.html b/circle.html
new file mode 100644
index 0000000..3be1287
--- /dev/null
+++ b/circle.html
@@ -0,0 +1,51 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Circle Spokes</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="circleSpokesCanvas" width="500" height="500"></canvas>
+    <script>
+        const canvas = document.getElementById('circleSpokesCanvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const radius = 200;
+        const numberOfSpokes = 20;
+
+        // Draw the circle
+        ctx.beginPath();
+        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
+        ctx.stroke();
+
+        // Draw the spokes
+        for (let i = 0; i < numberOfSpokes; i++) {
+            const angle = (i / numberOfSpokes) * 2 * Math.PI;
+            const x = centerX + radius * Math.cos(angle);
+            const y = centerY + radius * Math.sin(angle);
+
+            ctx.beginPath();
+            ctx.moveTo(centerX, centerY);
+            ctx.lineTo(x, y);
+            ctx.stroke();
+        }
+    </script>
+</body>
+</html>
+
diff --git a/circle2.html b/circle2.html
new file mode 100644
index 0000000..c3c7a44
--- /dev/null
+++ b/circle2.html
@@ -0,0 +1,85 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Draw Circles with Polar Coordinates</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+        #controls {
+            position: absolute;
+            top: 20px;
+            left: 20px;
+        }
+    </style>
+</head>
+<body>
+    <div id="controls">
+        <label for="radius">Radius: </label>
+        <input type="number" id="radius" value="50">
+        <input type="number" id="nodenumber" value="2">
+        <button onclick="drawCircle()">Draw Circle</button>
+    </div>
+    <canvas id="canvas" width="800" height="600"></canvas>
+
+    <script>
+        const canvas = document.getElementById('canvas');
+        const context = canvas.getContext('2d');
+
+        canvas.addEventListener('click', (event) => {
+            const rect = canvas.getBoundingClientRect();
+            const x = event.clientX - rect.left;
+            const y = event.clientY - rect.top;
+            const radius = parseInt(document.getElementById('radius').value, 10);
+            const radius2 = 2 * parseInt(document.getElementById('radius').value, 10);
+            const nodenumber = parseInt(document.getElementById('nodenumber').value, 2);
+            const delta0 = (Math.PI / 15);
+            for (let delta = 0; delta <= Math.PI * 2; delta += delta0) {
+            	drawCirclePolar(x, y, radius, radius2, nodenumber, delta);
+	    }
+        });
+
+        function drawCirclePolar(centerX, centerY, radius, radius2, nodenumber, delta) {
+            context.beginPath();
+            for (let angle = 0; angle <= 360; angle++) {
+                const theta = angle * (Math.PI / 180);
+                const x = centerX + ( radius2 + radius * Math.cos(nodenumber*theta + delta)) * Math.cos(theta + delta);
+                const y = centerY + ( radius2 + radius * Math.cos(nodenumber*theta + delta)) * Math.sin(theta + delta);
+                if (angle === 0) {
+                    context.moveTo(x, y);
+                } else {
+                    context.lineTo(x, y);
+                }
+            }
+            context.closePath();
+            //context.fillStyle = 'blue';
+            //context.fill();
+            context.stroke();
+        }
+
+        function drawCircle() {
+            const radius = parseInt(document.getElementById('radius').value, 10);
+            const radius2 = 2 * parseInt(document.getElementById('radius').value, 10);
+            const nodenumber = parseInt(document.getElementById('nodenumber').value, 2);
+            const x = canvas.width / 2;
+            const y = canvas.height / 2;
+            const delta0 = (Math.PI / 15);
+            for (let delta = 0; delta <= Math.PI * 2; delta += delta0) {
+            	drawCirclePolar(x, y, radius, radius2, nodenumber, delta);
+	    }
+        }
+    </script>
+</body>
+</html>
+
diff --git a/circle_color.html b/circle_color.html
new file mode 100644
index 0000000..38b532a
--- /dev/null
+++ b/circle_color.html
@@ -0,0 +1,61 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Circle Spokes with Different Colors</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="circleSpokesCanvas" width="500" height="500"></canvas>
+    <script>
+        const canvas = document.getElementById('circleSpokesCanvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const radius = 200;
+        const numberOfSpokes = 20;
+
+        // Function to generate a random color
+        function getRandomColor() {
+            const letters = '0123456789ABCDEF';
+            let color = '#';
+            for (let i = 0; i < 6; i++) {
+                color += letters[Math.floor(Math.random() * 16)];
+            }
+            return color;
+        }
+
+        // Draw the circle
+        ctx.beginPath();
+        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
+        ctx.stroke();
+
+        // Draw the spokes
+        for (let i = 0; i < numberOfSpokes; i++) {
+            const angle = (i / numberOfSpokes) * 2 * Math.PI;
+            const x = centerX + radius * Math.cos(angle);
+            const y = centerY + radius * Math.sin(angle);
+
+            ctx.beginPath();
+            ctx.moveTo(centerX, centerY);
+            ctx.lineTo(x, y);
+            ctx.strokeStyle = getRandomColor();
+            ctx.stroke();
+        }
+    </script>
+</body>
+</html>
+
diff --git a/concentric.html b/concentric.html
new file mode 100644
index 0000000..2d6fe57
--- /dev/null
+++ b/concentric.html
@@ -0,0 +1,67 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Canvas Pattern</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #fff;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="patternCanvas" width="500" height="500"></canvas>
+    <script>
+        const canvas = document.getElementById('patternCanvas');
+        const ctx = canvas.getContext('2d');
+        const width = canvas.width;
+        const height = canvas.height;
+        const radius = 100;
+        const lineWidth = 2;
+
+        ctx.lineWidth = lineWidth;
+
+        const colors = ['#FF5733', '#33FF57', '#3357FF', '#FF33A1', '#A133FF']; // Array of colors
+        const numColors = colors.length;
+        let baseColorIndex = 0;
+
+        function drawPattern() {
+            ctx.clearRect(0, 0, width, height); // Clear the canvas
+
+            const offsetX = width / 2;
+            const offsetY = height / 2;
+            const spacing = 10;
+
+            drawArcs(offsetX, offsetY, radius, spacing);
+        }
+
+        function drawArcs(x, y, radius, spacing) {
+            let colorIndex = baseColorIndex;
+
+            for (let r = radius; r > 0; r -= spacing) {
+                ctx.strokeStyle = colors[colorIndex % numColors];
+                ctx.beginPath();
+                ctx.arc(x, y, r, 0, Math.PI * 2, false);
+                ctx.stroke();
+                
+                colorIndex++; // Move to the next color in the array
+            }
+
+            baseColorIndex = (baseColorIndex + 1) % numColors; // Shift the base color index for the next frame
+        }
+
+        setInterval(drawPattern, 100); // Redraw the pattern every 100ms
+    </script>
+</body>
+</html>
+
diff --git a/counter_rotating_sector.html b/counter_rotating_sector.html
new file mode 100644
index 0000000..ced0a92
--- /dev/null
+++ b/counter_rotating_sector.html
@@ -0,0 +1,59 @@
+<!DOCTYPE html>
+<html>
+<body>
+
+<canvas id="illusionCanvas" width="1200" height="1200"></canvas>
+
+<script>
+// Function to draw a sector of a circle and radially cut it into half
+function drawSector(ctx, x, y, radius, startAngle, endAngle, fillColor) {
+    ctx.beginPath(); // Start a new path
+    ctx.moveTo(x, y); // Move to the center of the circle
+    ctx.arc(x, y, radius, startAngle, endAngle); // Draw the outer arc
+    ctx.closePath(); // Create a straight line back to the center of the circle
+    ctx.fillStyle = fillColor; // Set the fill color
+    ctx.fill(); // Fill the sector with color
+    ctx.strokeStyle = 'white'; // Fill the sector with color
+    ctx.stroke(); // Draw the line
+}
+
+// Get the canvas element and its context
+const canvas = document.getElementById('illusionCanvas');
+const ctx = canvas.getContext('2d');
+var shift_angle = 0;
+var shift_angle1 = 0; // counter-rotating
+var sub_shift_angle = 2 * Math.PI / 180; // Slow rotation for the pentagon
+
+function draw() {
+
+    shift_angle += sub_shift_angle;
+    shift_angle1 -= sub_shift_angle;
+    ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
+
+    //draw_rotating_spoke(spokeCenterX, spokeCenterY, maxRadius / 5, sub_shift_angle); // Draw each spoke
+// Example usage: Draw a sector of a circle and radially cut it into half
+// Parameters: context, centerX, centerY, radius, startAngle, endAngle, fillColor
+var ngon = 6;
+var mysize = Math.PI * 2/ngon;
+var mysize_diff = mysize/10;
+
+for (let angle = 0.0; angle < 2*Math.PI; angle += mysize) {
+drawSector(ctx, 200, 200, 100, angle+shift_angle, angle+mysize-mysize_diff+shift_angle, 'blue'); // Drawing and cutting a quarter circle sector
+drawSector(ctx, 200, 200, 3*100/4, angle+shift_angle, angle+mysize-mysize_diff+shift_angle, 'white'); // Drawing and cutting a quarter circle sector
+drawSector(ctx, 200, 200, 100/2, angle+shift_angle1, angle+mysize-mysize_diff+shift_angle1, 'blue'); // Drawing and cutting a quarter circle sector
+drawSector(ctx, 200, 200, 100/4, angle+shift_angle1, angle+mysize-mysize_diff+shift_angle1, 'white'); // Drawing and cutting a quarter circle sector
+drawSector(ctx, 400, 400, 100/2, angle+shift_angle1, angle+mysize-mysize_diff+shift_angle1, 'blue'); // Drawing and cutting a quarter circle sector
+drawSector(ctx, 400, 400, 100/4, angle+shift_angle1, angle+mysize-mysize_diff+shift_angle1, 'white'); // Drawing and cutting a quarter circle sector
+}
+    window.requestAnimationFrame(draw); // Continue the animation
+}
+
+
+
+
+draw();
+</script>
+
+</body>
+</html>
+
diff --git a/css_3dcube.html b/css_3dcube.html
new file mode 100644
index 0000000..d726af2
--- /dev/null
+++ b/css_3dcube.html
@@ -0,0 +1,78 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+  <meta charset="UTF-8">
+  <meta name="viewport" content="width=device-width, initial-scale=1.0">
+  <title>3D Rotating Cube</title>
+  <style>
+    /* Add the CSS code here */
+body {
+  display: flex;
+  justify-content: center;
+  align-items: center;
+  height: 100vh;
+  background-color: #f0f0f0;
+  margin: 0;
+  perspective: 1000px;
+}
+
+.cube {
+  position: relative;
+  width: 200px;
+  transform-style: preserve-3d;
+  animation: rotateCube 2s infinite linear;
+}
+
+.face {
+  position: absolute;
+  width: 200px;
+  height: 200px;
+  background: rgba(0, 128, 255, 0.7);
+  border: 1px solid #000;
+  display: flex;
+  justify-content: center;
+  align-items: center;
+  font-size: 24px;
+  color: white;
+}
+
+.front  { transform: translateZ(100px); }
+.back   { transform: rotateY(180deg) translateZ(100px); }
+.right  { transform: rotateY(90deg) translateZ(100px); }
+.left   { transform: rotateY(-90deg) translateZ(100px); }
+.top    { transform: rotateX(90deg) translateZ(100px); }
+.bottom { transform: rotateX(-90deg) translateZ(100px); }
+
+@keyframes rotateCube {
+  0% {
+    transform: rotateX(0deg) rotateY(0deg) rotateZ(0deg);
+  }
+  33% {
+    transform: rotateX(360deg) rotateY(0deg) rotateZ(0deg);
+  }
+  66% {
+    transform: rotateX(360deg) rotateY(360deg) rotateZ(0deg);
+  }
+  100% {
+    transform: rotateX(360deg) rotateY(360deg) rotateZ(360deg);
+  }
+}
+
+
+  </style>
+</head>
+<body>
+  <div class="cube">
+    <div class="face front">Front</div>
+    <div class="face back">Back</div>
+    <div class="face right">Right</div>
+    <div class="face left">Left</div>
+    <div class="face top">Top</div>
+    <div class="face bottom">Bottom</div>
+  </div>
+</body>
+</html>
+
+
+
diff --git a/css_circle.html b/css_circle.html
new file mode 100644
index 0000000..442e404
--- /dev/null
+++ b/css_circle.html
@@ -0,0 +1,19 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Circle Slider</title>
+    <link rel="stylesheet" href="css_style.css">
+</head>
+<body>
+    <div class="container">
+        <input type="range" id="radiusSlider" min="10" max="200" value="50">
+        <button id="startButton">Start</button>
+        <canvas id="circleCanvas"></canvas>
+    </div>
+    <script src="css_script.js"></script>
+</body>
+</html>
+
diff --git a/css_circle1.html b/css_circle1.html
new file mode 100644
index 0000000..5eb5f9a
--- /dev/null
+++ b/css_circle1.html
@@ -0,0 +1,20 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Circle Slider</title>
+    <link rel="stylesheet" href="css_style1.css">
+</head>
+<body>
+    <div class="container">
+        <input type="range" id="radiusSlider" min="10" max="200" value="100">
+        <input type="number" id="innerCircleCount" min="1" max="100" value="20">
+        <button id="startButton">Start</button>
+        <canvas id="circleCanvas"></canvas>
+    </div>
+    <script src="css_script1.js"></script>
+</body>
+</html>
+
diff --git a/css_script.js b/css_script.js
new file mode 100644
index 0000000..5a26c5f
--- /dev/null
+++ b/css_script.js
@@ -0,0 +1,37 @@
+
+document.getElementById('startButton').addEventListener('click', drawCircles);
+
+function drawCircles() {
+    const radius = document.getElementById('radiusSlider').value;
+    const canvas = document.getElementById('circleCanvas');
+    const ctx = canvas.getContext('2d');
+    const smallerRadius = radius / 2;
+
+    canvas.width = radius * 2 + 20;  // Add some margin
+    canvas.height = radius * 2 + 20;
+
+    ctx.clearRect(0, 0, canvas.width, canvas.height);
+
+    // Draw outer circle
+    ctx.beginPath();
+    ctx.arc(canvas.width / 2, canvas.height / 2, radius, 0, Math.PI * 2);
+    ctx.stroke();
+
+    // Calculate positions for smaller circles
+    const innerCircleX = canvas.width / 2;
+    const innerCircleY = canvas.height / 2;
+    const positions = [
+        { x: innerCircleX - smallerRadius, y: innerCircleY },
+        { x: innerCircleX + smallerRadius, y: innerCircleY },
+        { x: innerCircleX, y: innerCircleY - smallerRadius },
+        { x: innerCircleX, y: innerCircleY + smallerRadius }
+    ];
+
+    // Draw smaller circles
+    positions.forEach(pos => {
+        ctx.beginPath();
+        ctx.arc(pos.x, pos.y, smallerRadius, 0, Math.PI * 2);
+        ctx.stroke();
+    });
+}
+
diff --git a/css_script1.js b/css_script1.js
new file mode 100644
index 0000000..459485e
--- /dev/null
+++ b/css_script1.js
@@ -0,0 +1,36 @@
+
+document.getElementById('startButton').addEventListener('click', drawCircles);
+
+function drawCircles() {
+    const radius = parseInt(document.getElementById('radiusSlider').value);
+    const innerCircleCount = parseInt(document.getElementById('innerCircleCount').value);
+    const canvas = document.getElementById('circleCanvas');
+    const ctx = canvas.getContext('2d');
+    const smallerRadius = radius / 2;
+
+    canvas.width = radius * 2 + 20;  // Add some margin
+    canvas.height = radius * 2 + 20;
+
+    ctx.clearRect(0, 0, canvas.width, canvas.height);
+
+    // Draw outer circle
+    ctx.beginPath();
+    ctx.arc(canvas.width / 2, canvas.height / 2, radius, 0, Math.PI * 2);
+    ctx.stroke();
+
+    // Calculate positions for smaller circles
+    const innerCircleX = canvas.width / 2;
+    const innerCircleY = canvas.height / 2;
+    const angleStep = (2 * Math.PI) / innerCircleCount;
+
+    for (let i = 0; i < innerCircleCount; i++) {
+        const angle = i * angleStep;
+        const x = innerCircleX + smallerRadius * Math.cos(angle); //### - smallerRadius;
+        const y = innerCircleY + smallerRadius * Math.sin(angle); // #### - smallerRadius;
+
+        ctx.beginPath();
+        ctx.arc(x, y, smallerRadius, 0, Math.PI * 2);
+        ctx.stroke();
+    }
+}
+
diff --git a/css_style.css b/css_style.css
new file mode 100644
index 0000000..b4f919f
--- /dev/null
+++ b/css_style.css
@@ -0,0 +1,19 @@
+
+body {
+    display: flex;
+    justify-content: center;
+    align-items: center;
+    height: 100vh;
+    margin: 0;
+    font-family: Arial, sans-serif;
+}
+
+.container {
+    text-align: center;
+}
+
+#circleCanvas {
+    border: 1px solid #000;
+    margin-top: 20px;
+}
+
diff --git a/css_style1.css b/css_style1.css
new file mode 100644
index 0000000..b4f919f
--- /dev/null
+++ b/css_style1.css
@@ -0,0 +1,19 @@
+
+body {
+    display: flex;
+    justify-content: center;
+    align-items: center;
+    height: 100vh;
+    margin: 0;
+    font-family: Arial, sans-serif;
+}
+
+.container {
+    text-align: center;
+}
+
+#circleCanvas {
+    border: 1px solid #000;
+    margin-top: 20px;
+}
+
diff --git a/d3_graph.html b/d3_graph.html
new file mode 100644
index 0000000..6cb3629
--- /dev/null
+++ b/d3_graph.html
@@ -0,0 +1,18 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <title>Scatter Plot with D3.js</title>
+    <script src="https://d3js.org/d3.v7.min.js"></script>
+    <style>
+        .dot {
+            fill: steelblue;
+        }
+    </style>
+</head>
+<body>
+    <svg width="800" height="600"></svg>
+    <script src="d3_graph.js"></script>
+</body>
+</html>
+
diff --git a/d3_graph.js b/d3_graph.js
new file mode 100644
index 0000000..92edc39
--- /dev/null
+++ b/d3_graph.js
@@ -0,0 +1,50 @@
+
+// Set the dimensions and margins of the graph
+const margin = {top: 20, right: 30, bottom: 40, left: 50},
+      width = 800 - margin.left - margin.right,
+      height = 600 - margin.top - margin.bottom;
+
+// Append the svg object to the body of the page
+const svg = d3.select("svg")
+    .attr("width", width + margin.left + margin.right)
+    .attr("height", height + margin.top + margin.bottom)
+  .append("g")
+    .attr("transform", `translate(${margin.left},${margin.top})`);
+
+// Sample data
+const data = [
+  {x: 30, y: 20},
+  {x: 50, y: 90},
+  {x: 70, y: 50},
+  {x: 90, y: 120},
+  {x: 110, y: 70},
+  {x: 130, y: 200},
+  {x: 150, y: 150},
+];
+
+// Add X axis
+const x = d3.scaleLinear()
+  .domain([0, 200])
+  .range([ 0, width ]);
+svg.append("g")
+  .attr("transform", `translate(0,${height})`)
+  .call(d3.axisBottom(x));
+
+// Add Y axis
+const y = d3.scaleLinear()
+  .domain([0, 200])
+  .range([ height, 0]);
+svg.append("g")
+  .call(d3.axisLeft(y));
+
+// Add dots
+svg.append('g')
+  .selectAll("dot")
+  .data(data)
+  .enter()
+  .append("circle")
+    .attr("cx", d => x(d.x))
+    .attr("cy", d => y(d.y))
+    .attr("r", 5)
+    .attr("class", "dot");
+
diff --git a/double.html b/double.html
new file mode 100644
index 0000000..dc4252e
--- /dev/null
+++ b/double.html
@@ -0,0 +1,55 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Complex Line Drawing</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #333;
+        }
+        canvas {
+            border: 1px solid black;
+            background-color: #333;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="complexLineCanvas" width="600" height="600"></canvas>
+    <script>
+        const canvas = document.getElementById('complexLineCanvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const numLines = 160;
+
+        // Function to draw the complex pattern
+        function drawComplexPattern() {
+            ctx.strokeStyle = '#ffffff';
+            ctx.lineWidth = 0.5;
+            for (let i = 0; i < numLines; i++) {
+                const angle1 = (i / numLines) * 2 * Math.PI;
+                const angle2 = ((i + 180) / numLines) * 2 * Math.PI;
+                const x1 = centerX + 100 * Math.cos(angle1) * Math.sin(angle2);
+                const y1 = centerY + 200 * Math.sin(angle1) * Math.sin(angle2);
+                const x2 = centerX + 300 * Math.cos(angle2) * Math.sin(angle1);
+                const y2 = centerY + 400 * Math.sin(angle2) * Math.sin(angle1);
+
+                ctx.beginPath();
+                ctx.moveTo(x1, y1);
+                ctx.lineTo(x2, y2);
+                ctx.stroke();
+            }
+        }
+
+        drawComplexPattern();
+    </script>
+</body>
+</html>
+
diff --git a/double1.html b/double1.html
new file mode 100644
index 0000000..70d5931
--- /dev/null
+++ b/double1.html
@@ -0,0 +1,55 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Complex Line Drawing</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #333;
+        }
+        canvas {
+            border: 1px solid black;
+            background-color: #333;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="complexLineCanvas" width="600" height="600"></canvas>
+    <script>
+        const canvas = document.getElementById('complexLineCanvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const numLines = 360;
+
+        // Function to draw the complex pattern
+        function drawComplexPattern() {
+            ctx.strokeStyle = '#ffffff';
+            ctx.lineWidth = 0.5;
+            for (let i = 0; i < numLines; i++) {
+                const angle1 = (i / numLines) * 2 * Math.PI;
+                const angle2 = ((i + 180) / numLines) * 2 * Math.PI;
+                const x1 = centerX + 100 * Math.cos(angle1) * Math.sin(angle2);
+                const y1 = centerY + 100 * Math.sin(angle1) * Math.sin(angle2);
+                const x2 = centerX + 100 * Math.cos(angle2) * Math.sin(angle1);
+                const y2 = centerY + 100 * Math.sin(angle2) * Math.sin(angle1);
+
+                ctx.beginPath();
+                ctx.moveTo(x1, y1);
+                ctx.lineTo(x2, y2);
+                ctx.stroke();
+            }
+        }
+
+        drawComplexPattern();
+    </script>
+</body>
+</html>
+
diff --git a/double3.html b/double3.html
new file mode 100644
index 0000000..c1cb63d
--- /dev/null
+++ b/double3.html
@@ -0,0 +1,55 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Complex Line Drawing</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #333;
+        }
+        canvas {
+            border: 1px solid black;
+            background-color: #333;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="complexLineCanvas" width="600" height="600"></canvas>
+    <script>
+        const canvas = document.getElementById('complexLineCanvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const numLines = 360;
+
+        // Function to draw the complex pattern
+        function drawComplexPattern() {
+            ctx.strokeStyle = '#ffffff';
+            ctx.lineWidth = 0.5;
+            for (let i = 0; i < numLines; i++) {
+                const angle1 = (i / numLines) * 2 * Math.PI;
+                const angle2 = ((i + 180) / numLines) * 2 * Math.PI;
+                const x1 = centerX + 100 * Math.cos(2*angle1) * Math.sin(angle2);
+                const y1 = centerY + 200 * Math.sin(3*angle1) * Math.sin(angle2);
+                const x2 = centerX + 300 * Math.cos(angle2) * Math.sin(angle1);
+                const y2 = centerY + 400 * Math.sin(angle2) * Math.sin(angle1);
+
+                ctx.beginPath();
+                ctx.moveTo(x1, y1);
+                ctx.lineTo(x2, y2);
+                ctx.stroke();
+            }
+        }
+
+        drawComplexPattern();
+    </script>
+</body>
+</html>
+
diff --git a/double4.html b/double4.html
new file mode 100644
index 0000000..57f833b
--- /dev/null
+++ b/double4.html
@@ -0,0 +1,55 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Complex Line Drawing</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #333;
+        }
+        canvas {
+            border: 1px solid black;
+            background-color: #333;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="complexLineCanvas" width="600" height="600"></canvas>
+    <script>
+        const canvas = document.getElementById('complexLineCanvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const numLines = 360;
+
+        // Function to draw the complex pattern
+        function drawComplexPattern() {
+            ctx.strokeStyle = '#ffffff';
+            ctx.lineWidth = 0.5;
+            for (let i = 0; i < numLines; i++) {
+                const angle1 = (i / numLines) * 2 * Math.PI;
+                const angle2 = ((i + 180) / numLines) * 2 * Math.PI;
+                const x1 = centerX + 100 * Math.cos(2*angle1) * Math.sin(angle2);
+                const y1 = centerY + 200 * Math.sin(4*angle1) * Math.sin(angle2);
+                const x2 = centerX + 300 * Math.cos(angle2) * Math.sin(angle1);
+                const y2 = centerY + 400 * Math.sin(angle2) * Math.sin(angle1);
+
+                ctx.beginPath();
+                ctx.moveTo(x1, y1);
+                ctx.lineTo(x2, y2);
+                ctx.stroke();
+            }
+        }
+
+        drawComplexPattern();
+    </script>
+</body>
+</html>
+
diff --git a/double5.html b/double5.html
new file mode 100644
index 0000000..219e083
--- /dev/null
+++ b/double5.html
@@ -0,0 +1,55 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Complex Line Drawing</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #333;
+        }
+        canvas {
+            border: 1px solid black;
+            background-color: #333;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="complexLineCanvas" width="600" height="600"></canvas>
+    <script>
+        const canvas = document.getElementById('complexLineCanvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const numLines = 360;
+
+        // Function to draw the complex pattern
+        function drawComplexPattern() {
+            ctx.strokeStyle = '#ffffff';
+            ctx.lineWidth = 0.5;
+            for (let i = 0; i < numLines; i++) {
+                const angle1 = (i / numLines) * 2 * Math.PI;
+                const angle2 = ((i + 180) / numLines) * 2 * Math.PI;
+                const x1 = centerX + 100 * Math.cos(angle1) * Math.sin(angle2);
+                const y1 = centerY + 100 * Math.sin(angle1) * Math.sin(angle2);
+                const x2 = centerX + 400 * Math.cos(angle2) * Math.sin(angle1);
+                const y2 = centerY + 400 * Math.sin(angle2) * Math.sin(angle1);
+
+                ctx.beginPath();
+                ctx.moveTo(x1, y1);
+                ctx.lineTo(x2, y2);
+                ctx.stroke();
+            }
+        }
+
+        drawComplexPattern();
+    </script>
+</body>
+</html>
+
diff --git a/double_motion.html b/double_motion.html
new file mode 100644
index 0000000..45e845c
--- /dev/null
+++ b/double_motion.html
@@ -0,0 +1,71 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Dynamic Complex Line Drawing</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #333;
+        }
+        canvas {
+            border: 1px solid black;
+            background-color: #333;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="complexLineCanvas" width="600" height="600"></canvas>
+    <script>
+        const canvas = document.getElementById('complexLineCanvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const numLines = 360;
+
+        let angleMultiplier1 = 2;
+        let angleMultiplier2 = 4;
+        let radius1 = 100;
+        let radius2 = 400;
+        let angleOffset = 0;
+
+        // Function to draw the complex pattern
+        function drawComplexPattern() {
+            ctx.clearRect(0, 0, canvas.width, canvas.height);
+            ctx.strokeStyle = '#ffffff';
+            ctx.lineWidth = 0.5;
+
+            for (let i = 0; i < numLines; i++) {
+                const angle1 = (i / numLines) * 2 * Math.PI;
+                const angle2 = ((i + 180) / numLines) * 2 * Math.PI;
+                const x1 = centerX + radius1 * Math.cos(angleMultiplier1 * (angle1 + angleOffset)) * Math.sin(angle2 + angleOffset);
+                const y1 = centerY + radius1 * Math.sin(angleMultiplier2 * (angle1 + angleOffset)) * Math.sin(angle2 + angleOffset);
+                const x2 = centerX + radius2 * Math.cos(angle2 + angleOffset) * Math.sin(angle1 + angleOffset);
+                const y2 = centerY + radius2 * Math.sin(angle2 + angleOffset) * Math.sin(angle1 + angleOffset);
+
+                ctx.beginPath();
+                ctx.moveTo(x1, y1);
+                ctx.lineTo(x2, y2);
+                ctx.stroke();
+            }
+
+            // Update parameters to create animation
+            angleOffset += 0.01;
+            angleMultiplier1 = 2 + Math.sin(angleOffset) * 2;
+            angleMultiplier2 = 4 + Math.cos(angleOffset) * 2;
+            radius1 = 100 + Math.sin(angleOffset) * 50;
+            radius2 = 400 + Math.cos(angleOffset) * 50;
+
+            requestAnimationFrame(drawComplexPattern);
+        }
+
+        drawComplexPattern();
+    </script>
+</body>
+</html>
+
diff --git a/drawsector.html b/drawsector.html
new file mode 100644
index 0000000..da0f186
--- /dev/null
+++ b/drawsector.html
@@ -0,0 +1,13 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <title>Sector of a Circle</title>
+</head>
+<body>
+    <canvas id="circleSector" width="400" height="400"></canvas>
+    <script src="drawsector2.js"></script>
+</body>
+</html>
+
diff --git a/drawsector.js b/drawsector.js
new file mode 100644
index 0000000..f8112e9
--- /dev/null
+++ b/drawsector.js
@@ -0,0 +1,29 @@
+
+// Function to draw a sector of a circle and radially cut it into half
+function drawSectorAndCut(ctx, x, y, radius, startAngle, endAngle, fillColor) {
+    ctx.beginPath(); // Start a new path
+    ctx.moveTo(x, y); // Move to the center of the circle
+    ctx.arc(x, y, radius, startAngle, endAngle); // Draw the outer arc
+    ctx.closePath(); // Create a straight line back to the center of the circle
+    ctx.fillStyle = fillColor; // Set the fill color
+    ctx.fill(); // Fill the sector with color
+
+    // Calculate the midpoint angle
+    const midAngle = (startAngle + endAngle) / 2;
+
+    // Draw a line to radially cut the sector into half
+    ctx.beginPath(); // Start a new path for the line
+    ctx.moveTo(x, y); // Start from the center of the circle
+    // Calculate the end point of the line on the circle's edge
+    ctx.lineTo(x + radius * Math.cos(midAngle), y + radius * Math.sin(midAngle));
+    ctx.stroke(); // Draw the line
+}
+
+// Get the canvas element and its context
+const canvas = document.getElementById('circleSector');
+const ctx = canvas.getContext('2d');
+
+// Example usage: Draw a sector of a circle and radially cut it into half
+// Parameters: context, centerX, centerY, radius, startAngle, endAngle, fillColor
+drawSectorAndCut(ctx, 200, 200, 100, 0, Math.PI / 2, 'blue'); // Drawing and cutting a quarter circle sector
+
diff --git a/drawsector0.js b/drawsector0.js
new file mode 100644
index 0000000..019a41b
--- /dev/null
+++ b/drawsector0.js
@@ -0,0 +1,20 @@
+
+// Function to draw a sector of a circle
+function drawSector(ctx, x, y, radius, startAngle, endAngle, fillColor) {
+    ctx.beginPath(); // Start a new path
+    ctx.moveTo(x, y); // Move to the center of the circle
+    ctx.arc(x, y, radius, startAngle, endAngle); // Draw the outer arc
+    ctx.closePath(); // Create a straight line back to the center of the circle
+    ctx.fillStyle = fillColor; // Set the fill color
+    ctx.fill(); // Fill the sector with color
+}
+
+// Get the canvas element and its context
+const canvas = document.getElementById('circleSector');
+const ctx = canvas.getContext('2d');
+
+// Example usage: Draw a sector of a circle
+// Parameters: context, centerX, centerY, radius, startAngle, endAngle, fillColor
+// Note: Angles in radians, where 0 at the 3 o'clock position, and PI/2 at the 6 o'clock position
+drawSector(ctx, 200, 200, 100, 0, Math.PI / 2, 'blue'); // Drawing a quarter circle sector
+
diff --git a/drawsector1.js b/drawsector1.js
new file mode 100644
index 0000000..60ea140
--- /dev/null
+++ b/drawsector1.js
@@ -0,0 +1,36 @@
+
+// Function to draw a sector of a circle and bisect it perpendicularly to the radial direction
+function drawSectorAndBisectPerpendicularly(ctx, x, y, radius, startAngle, endAngle, fillColor) {
+    ctx.beginPath(); // Start a new path
+    ctx.moveTo(x, y); // Move to the center of the circle
+    ctx.arc(x, y, radius, startAngle, endAngle); // Draw the outer arc
+    ctx.closePath(); // Create a straight line back to the center of the circle
+    ctx.fillStyle = fillColor; // Set the fill color
+    ctx.fill(); // Fill the sector with color
+
+    // Calculate points for the bisecting line
+    const midAngle = (startAngle + endAngle) / 2;
+    const bisectStartAngle = midAngle - (Math.PI / 2 - (endAngle - startAngle) / 2);
+    const bisectEndAngle = midAngle + (Math.PI / 2 - (endAngle - startAngle) / 2);
+
+    // Calculate start and end points for the bisecting line
+    const startX = x + radius * Math.cos(bisectStartAngle);
+    const startY = y + radius * Math.sin(bisectStartAngle);
+    const endX = x + radius * Math.cos(bisectEndAngle);
+    const endY = y + radius * Math.sin(bisectEndAngle);
+
+    // Draw the bisecting line
+    ctx.beginPath(); // Start a new path for the bisecting line
+    ctx.moveTo(startX, startY); // Move to the start point of the bisecting line
+    ctx.lineTo(endX, endY); // Draw a line to the end point
+    ctx.stroke(); // Stroke the line
+}
+
+// Get the canvas element and its context
+const canvas = document.getElementById('circleSector');
+const ctx = canvas.getContext('2d');
+
+// Example usage: Draw a sector of a circle and bisect it perpendicularly
+// Parameters: context, centerX, centerY, radius, startAngle, endAngle, fillColor
+drawSectorAndBisectPerpendicularly(ctx, 200, 200, 100, 0, Math.PI / 2, 'blue'); // Drawing and bisecting a quarter circle sector
+
diff --git a/drawsector2.js b/drawsector2.js
new file mode 100644
index 0000000..c585cf7
--- /dev/null
+++ b/drawsector2.js
@@ -0,0 +1,48 @@
+
+// Function to draw a sector of a circle and radially cut it into half
+function drawSector(ctx, x, y, radius, startAngle, endAngle, fillColor) {
+    ctx.beginPath(); // Start a new path
+    ctx.moveTo(x, y); // Move to the center of the circle
+    ctx.arc(x, y, radius, startAngle, endAngle); // Draw the outer arc
+    ctx.closePath(); // Create a straight line back to the center of the circle
+    ctx.fillStyle = fillColor; // Set the fill color
+    ctx.fill(); // Fill the sector with color
+    ctx.strokeStyle = 'white'; // Fill the sector with color
+
+    ctx.stroke(); // Draw the line
+}
+// Function to draw a sector of a circle and radially cut it into half
+function drawSectorAndCut(ctx, x, y, radius, startAngle, endAngle, fillColor) {
+    ctx.beginPath(); // Start a new path
+    ctx.moveTo(x, y); // Move to the center of the circle
+    ctx.arc(x, y, radius, startAngle, endAngle); // Draw the outer arc
+    ctx.closePath(); // Create a straight line back to the center of the circle
+    ctx.fillStyle = fillColor; // Set the fill color
+    ctx.fill(); // Fill the sector with color
+
+    // Calculate the midpoint angle
+    const midAngle = (startAngle + endAngle) / 2;
+
+    // Draw a line to radially cut the sector into half
+    ctx.beginPath(); // Start a new path for the line
+    ctx.moveTo(x, y); // Start from the center of the circle
+    // Calculate the end point of the line on the circle's edge
+    ctx.lineTo(x + radius * Math.cos(midAngle), y + radius * Math.sin(midAngle));
+    ctx.stroke(); // Draw the line
+}
+
+// Get the canvas element and its context
+const canvas = document.getElementById('circleSector');
+const ctx = canvas.getContext('2d');
+
+// Example usage: Draw a sector of a circle and radially cut it into half
+// Parameters: context, centerX, centerY, radius, startAngle, endAngle, fillColor
+var ngon = 6;
+var mysize = Math.PI * 2/ngon;
+var mysize_diff = mysize/10;
+
+
+for (let angle = 0.0; angle < 2*Math.PI; angle += mysize) {
+drawSector(ctx, 200, 200, 100, angle, angle+mysize-mysize_diff, 'blue'); // Drawing and cutting a quarter circle sector
+drawSector(ctx, 200, 200, 100/2, angle, angle+mysize-mysize_diff, 'white'); // Drawing and cutting a quarter circle sector
+}
diff --git a/ellipse.html b/ellipse.html
new file mode 100644
index 0000000..327e8d4
--- /dev/null
+++ b/ellipse.html
@@ -0,0 +1,51 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Circle Spokes</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="circleSpokesCanvas" width="500" height="500"></canvas>
+    <script>
+        const canvas = document.getElementById('circleSpokesCanvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const radius = 200;
+        const numberOfSpokes = 50;
+
+        // Draw the circle
+        ctx.beginPath();
+        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
+        ctx.stroke();
+
+        // Draw the spokes
+        for (let i = 0; i < numberOfSpokes; i++) {
+            const angle = (i / numberOfSpokes) * 2 * Math.PI;
+            const x = centerX + 1.5 * radius * Math.cos(angle);
+            const y = centerY + radius * Math.sin(2*angle);
+
+            ctx.beginPath();
+            ctx.moveTo(centerX, centerY);
+            ctx.lineTo(x, y);
+            ctx.stroke();
+        }
+    </script>
+</body>
+</html>
+
diff --git a/ellipse2.html b/ellipse2.html
new file mode 100644
index 0000000..43d1021
--- /dev/null
+++ b/ellipse2.html
@@ -0,0 +1,80 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Rotating Ellipses</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+        #controls {
+            position: absolute;
+            top: 20px;
+            left: 20px;
+        }
+    </style>
+</head>
+<body>
+    <div id="controls">
+        <label for="radiusX">Radius X: </label>
+        <input type="number" id="radiusX" value="100">
+        <label for="radiusY">Radius Y: </label>
+        <input type="number" id="radiusY" value="50">
+        <button onclick="drawEllipse()">Draw Ellipse</button>
+    </div>
+    <canvas id="canvas" width="800" height="600"></canvas>
+
+    <script>
+        const canvas = document.getElementById('canvas');
+        const context = canvas.getContext('2d');
+        let ellipses = [];
+
+        canvas.addEventListener('click', (event) => {
+            const rect = canvas.getBoundingClientRect();
+            const x = event.clientX - rect.left;
+            const y = event.clientY - rect.top;
+            const radiusX = parseInt(document.getElementById('radiusX').value, 10);
+            const radiusY = parseInt(document.getElementById('radiusY').value, 10);
+            ellipses.push({x: x, y: y, radiusX: radiusX, radiusY: radiusY, angle: 0});
+        });
+
+        function drawEllipse() {
+            const radiusX = parseInt(document.getElementById('radiusX').value, 10);
+            const radiusY = parseInt(document.getElementById('radiusY').value, 10);
+            const x = canvas.width / 2;
+            const y = canvas.height / 2;
+            ellipses.push({x: x, y: y, radiusX: radiusX, radiusY: radiusY, angle: 0});
+        }
+
+        function drawEllipses() {
+            context.clearRect(0, 0, canvas.width, canvas.height);
+            ellipses.forEach(ellipse => {
+                context.save();
+                context.translate(ellipse.x, ellipse.y);
+                context.rotate(ellipse.angle);
+                context.beginPath();
+                context.ellipse(0, 0, ellipse.radiusX, ellipse.radiusY, 0, 0, 2 * Math.PI);
+                context.fillStyle = 'blue';
+                context.fill();
+                context.stroke();
+                context.restore();
+                ellipse.angle += 0.01;
+            });
+            requestAnimationFrame(drawEllipses);
+        }
+
+        drawEllipses();
+    </script>
+</body>
+</html>
+
diff --git a/ellipse3.html b/ellipse3.html
new file mode 100644
index 0000000..183ed7f
--- /dev/null
+++ b/ellipse3.html
@@ -0,0 +1,88 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Rotating Ellipses</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+        #controls {
+            position: absolute;
+            top: 20px;
+            left: 20px;
+        }
+    </style>
+</head>
+<body>
+    <div id="controls">
+        <label for="radiusX">Radius X: </label>
+        <input type="number" id="radiusX" value="100">
+        <label for="radiusY">Radius Y: </label>
+        <input type="number" id="radiusY" value="50">
+        <button onclick="drawEllipse()">Draw Ellipse</button>
+    </div>
+    <canvas id="canvas" width="800" height="600"></canvas>
+    
+    <script>
+        const canvas = document.getElementById('canvas');
+        const context = canvas.getContext('2d');
+        let ellipses = [];
+
+        canvas.addEventListener('click', (event) => {
+            const rect = canvas.getBoundingClientRect();
+            const x = event.clientX - rect.left;
+            const y = event.clientY - rect.top;
+            const radiusX = parseInt(document.getElementById('radiusX').value, 10);
+            const radiusY = parseInt(document.getElementById('radiusY').value, 10);
+            ellipses.push({x: x, y: y, radiusX: radiusX, radiusY: radiusY, angle: 0});
+            drawEllipseAtPosition(x, y, radiusX, radiusY);
+        });
+
+        function drawEllipseAtPosition(x, y, radiusX, radiusY) {
+            context.beginPath();
+            context.ellipse(x, y, radiusX, radiusY, 0, 0, 2 * Math.PI);
+            context.fillStyle = 'blue';
+            context.fill();
+            context.stroke();
+        }
+
+        function drawEllipse() {
+            const radiusX = parseInt(document.getElementById('radiusX').value, 10);
+            const radiusY = parseInt(document.getElementById('radiusY').value, 10);
+            const x = canvas.width / 2;
+            const y = canvas.height / 2;
+            ellipses.push({x: x, y: y, radiusX: radiusX, radiusY: radiusY, angle: 0});
+            drawEllipseAtPosition(x, y, radiusX, radiusY);
+        }
+
+        function animateEllipses() {
+            ellipses.forEach(ellipse => {
+                context.save();
+                context.translate(ellipse.x, ellipse.y);
+                context.rotate(ellipse.angle);
+                context.beginPath();
+                context.ellipse(0, 0, ellipse.radiusX, ellipse.radiusY, 0, 0, 2 * Math.PI);
+                context.fillStyle = 'blue';
+                context.fill();
+                context.stroke();
+                context.restore();
+                ellipse.angle += 0.2;
+            });
+            requestAnimationFrame(animateEllipses);
+        }
+
+        animateEllipses();
+    </script>
+</body>
+</html>
+
diff --git a/ellipse4.html b/ellipse4.html
new file mode 100644
index 0000000..6500d9b
--- /dev/null
+++ b/ellipse4.html
@@ -0,0 +1,96 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Rotating Ellipses</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+        #controls {
+            position: absolute;
+            top: 20px;
+            left: 20px;
+        }
+    </style>
+</head>
+<body>
+    <div id="controls">
+        <label for="radiusX">Radius X: </label>
+        <input type="number" id="radiusX" value="100">
+        <label for="radiusY">Radius Y: </label>
+        <input type="number" id="radiusY" value="50">
+        <button onclick="drawEllipse()">Draw Ellipse</button>
+    </div>
+    <canvas id="canvas" width="800" height="600"></canvas>
+    
+    <script>
+        const canvas = document.getElementById('canvas');
+        const context = canvas.getContext('2d');
+        let ellipses = [];
+        let centerX = canvas.width / 2;
+        let centerY = canvas.height / 2;
+        let traverseAngle = 0;
+        const traverseRadius = 50;
+
+        canvas.addEventListener('click', (event) => {
+            const radiusX = parseInt(document.getElementById('radiusX').value, 10);
+            const radiusY = parseInt(document.getElementById('radiusY').value, 10);
+            drawEllipseAtPosition(centerX, centerY, radiusX, radiusY);
+            ellipses.push({x: centerX, y: centerY, radiusX: radiusX, radiusY: radiusY, angle: 0});
+            updateCenter();
+        });
+
+        function drawEllipseAtPosition(x, y, radiusX, radiusY) {
+            context.beginPath();
+            context.ellipse(x, y, radiusX, radiusY, 0, 0, 2 * Math.PI);
+            context.fillStyle = 'blue';
+            context.fill();
+            context.stroke();
+        }
+
+        function drawEllipse() {
+            const radiusX = parseInt(document.getElementById('radiusX').value, 10);
+            const radiusY = parseInt(document.getElementById('radiusY').value, 10);
+            drawEllipseAtPosition(centerX, centerY, radiusX, radiusY);
+            ellipses.push({x: centerX, y: centerY, radiusX: radiusX, radiusY: radiusY, angle: 0});
+            updateCenter();
+        }
+
+        function updateCenter() {
+            traverseAngle += Math.PI / 12;  // Update the angle by 30 degrees
+            centerX = canvas.width / 2 + traverseRadius * Math.cos(4*traverseAngle);
+            centerY = canvas.height / 2 + traverseRadius * Math.sin(4*traverseAngle);
+        }
+
+        function animateEllipses() {
+            ellipses.forEach(ellipse => {
+                context.save();
+                context.translate(ellipse.x, ellipse.y);
+                context.rotate(ellipse.angle);
+                context.beginPath();
+                context.ellipse(0, 0, ellipse.radiusX, ellipse.radiusY, 0, 0, 2 * Math.PI);
+                context.fillStyle = 'blue';
+                context.fill();
+                context.stroke();
+                context.restore();
+                ellipse.angle += 0.2;
+            	updateCenter();
+            	//ellipses.push({x: centerX, y: centerY, radiusX: radiusX, radiusY: radiusY, angle: 0});
+            });
+            requestAnimationFrame(animateEllipses);
+        }
+
+        animateEllipses();
+    </script>
+</body>
+</html>
diff --git a/ellipse_color.html b/ellipse_color.html
new file mode 100644
index 0000000..0864dec
--- /dev/null
+++ b/ellipse_color.html
@@ -0,0 +1,61 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Circle Spokes with Different Colors</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="circleSpokesCanvas" width="500" height="500"></canvas>
+    <script>
+        const canvas = document.getElementById('circleSpokesCanvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const radius = 200;
+        const numberOfSpokes = 20;
+
+        // Function to generate a random color
+        function getRandomColor() {
+            const letters = '0123456789ABCDEF';
+            let color = '#';
+            for (let i = 0; i < 6; i++) {
+                color += letters[Math.floor(Math.random() * 16)];
+            }
+            return color;
+        }
+
+        // Draw the circle
+        ctx.beginPath();
+        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
+        ctx.stroke();
+
+        // Draw the spokes
+        for (let i = 0; i < numberOfSpokes; i++) {
+            const angle = (i / numberOfSpokes) * 2 * Math.PI;
+            const x = centerX + 2 * radius * Math.cos(angle);
+            const y = centerY + radius * Math.sin(3*angle);
+
+            ctx.beginPath();
+            ctx.moveTo(centerX, centerY);
+            ctx.lineTo(x, y);
+            ctx.strokeStyle = getRandomColor();
+            ctx.stroke();
+        }
+    </script>
+</body>
+</html>
+
diff --git a/ellipse_color2.html b/ellipse_color2.html
new file mode 100644
index 0000000..42b3fbc
--- /dev/null
+++ b/ellipse_color2.html
@@ -0,0 +1,63 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Circle Spokes with Different Colors</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="circleSpokesCanvas" width="500" height="500"></canvas>
+    <script>
+        const canvas = document.getElementById('circleSpokesCanvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const radius = 200;
+        const numberOfSpokes = 20;
+
+        // Function to generate a random color
+        function getRandomColor() {
+            const letters = '0123456789ABCDEF';
+            let color = '#';
+            for (let i = 0; i < 6; i++) {
+                color += letters[Math.floor(Math.random() * 16)];
+            }
+            return color;
+        }
+
+        // Draw the circle
+        ctx.beginPath();
+        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
+        ctx.stroke();
+
+        // Draw the spokes
+        for (let i = 0; i < numberOfSpokes; i++) {
+            const angle = (i / numberOfSpokes) * 2 * Math.PI;
+            centerX =  2 * radius * Math.cos(angle);
+            centerY = radius * Math.sin(3*angle);
+            const x = centerX + 2 * radius * Math.cos(angle);
+            const y = centerY + radius * Math.sin(3*angle);
+
+            ctx.beginPath();
+            ctx.moveTo(centerX, centerY);
+            ctx.lineTo(x, y);
+            ctx.strokeStyle = getRandomColor();
+            ctx.stroke();
+        }
+    </script>
+</body>
+</html>
+
diff --git a/ellipsical_line.html b/ellipsical_line.html
new file mode 100644
index 0000000..4731aae
--- /dev/null
+++ b/ellipsical_line.html
@@ -0,0 +1,28 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Ellipse Animation</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            background-color: white;
+            border: 1px solid #ccc;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="animationCanvas" width="600" height="600"></canvas>
+    <script src="ellipsical_line.js"></script>
+</body>
+</html>
+
diff --git a/ellipsical_line.js b/ellipsical_line.js
new file mode 100644
index 0000000..7a3619b
--- /dev/null
+++ b/ellipsical_line.js
@@ -0,0 +1,57 @@
+
+const canvas = document.getElementById('animationCanvas');
+const ctx = canvas.getContext('2d');
+const nPoints = 60;
+const a = 200; // Semi-major axis length (scaled)
+const b = 100; // Semi-minor axis length (scaled)
+let step = 1;
+
+function getPoints() {
+    const points = [];
+    const centerX = canvas.width / 2;
+    const centerY = canvas.height / 2;
+
+    for (let i = 0; i < nPoints; i++) {
+        const theta = (2 * Math.PI * i) / nPoints;
+        const x = centerX + a * Math.cos(theta);
+        const y = centerY + b * Math.sin(theta);
+        points.push({ x, y });
+    }
+
+    return points;
+}
+
+function drawPoints(points) {
+    ctx.clearRect(0, 0, canvas.width, canvas.height);
+    ctx.fillStyle = 'blue';
+
+    for (const point of points) {
+        ctx.beginPath();
+        ctx.arc(point.x, point.y, 3, 0, 2 * Math.PI);
+        ctx.fill();
+    }
+}
+
+function drawLines(points, step) {
+    ctx.strokeStyle = 'blue';
+
+    for (let i = 0; i < points.length; i++) {
+        const j = (i + step) % points.length;
+        ctx.beginPath();
+        ctx.moveTo(points[i].x, points[i].y);
+        ctx.lineTo(points[j].x, points[j].y);
+        ctx.stroke();
+    }
+}
+
+function animate() {
+    const points = getPoints();
+    drawPoints(points);
+    drawLines(points, step);
+    step = (step % (nPoints - 1)) + 1; // Increment step from 1 to 59
+
+    setTimeout(animate, 200); // Control animation speed
+}
+
+animate();
+
diff --git a/ellipsical_line_rotate.html b/ellipsical_line_rotate.html
new file mode 100644
index 0000000..2ef239d
--- /dev/null
+++ b/ellipsical_line_rotate.html
@@ -0,0 +1,28 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Ellipse Animation</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            background-color: white;
+            border: 1px solid #ccc;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="animationCanvas" width="600" height="600"></canvas>
+    <script src="ellipsical_line_rotate.js"></script>
+</body>
+</html>
+
diff --git a/ellipsical_line_rotate.js b/ellipsical_line_rotate.js
new file mode 100644
index 0000000..6d06066
--- /dev/null
+++ b/ellipsical_line_rotate.js
@@ -0,0 +1,61 @@
+
+const canvas = document.getElementById('animationCanvas');
+const ctx = canvas.getContext('2d');
+const nPoints = 60;
+const a = 200; // Semi-major axis length (scaled)
+const b = 100; // Semi-minor axis length (scaled)
+let step = 1;
+let rotationAngle = 0; // Initialize rotation angle
+
+function getPoints() {
+    const points = [];
+    const centerX = canvas.width / 2;
+    const centerY = canvas.height / 2;
+    const rotationRadians = rotationAngle * Math.PI / 180; // Convert degrees to radians
+
+    for (let i = 0; i < nPoints; i++) {
+        const theta = (2 * Math.PI * i) / nPoints;
+        // Apply rotation to the angle
+        const x = centerX + (a * Math.cos(theta) * Math.cos(rotationRadians) - b * Math.sin(theta) * Math.sin(rotationRadians));
+        const y = centerY + (a * Math.cos(theta) * Math.sin(rotationRadians) + b * Math.sin(theta) * Math.cos(rotationRadians));
+        points.push({ x, y });
+    }
+
+    return points;
+}
+
+function drawPoints(points) {
+    ctx.clearRect(0, 0, canvas.width, canvas.height);
+    ctx.fillStyle = 'blue';
+
+    for (const point of points) {
+        ctx.beginPath();
+        ctx.arc(point.x, point.y, 3, 0, 2 * Math.PI);
+        ctx.fill();
+    }
+}
+
+function drawLines(points, step) {
+    ctx.strokeStyle = 'blue';
+
+    for (let i = 0; i < points.length; i++) {
+        const j = (i + step) % points.length;
+        ctx.beginPath();
+        ctx.moveTo(points[i].x, points[i].y);
+        ctx.lineTo(points[j].x, points[j].y);
+        ctx.stroke();
+    }
+}
+
+function animate() {
+    const points = getPoints();
+    drawPoints(points);
+    drawLines(points, step);
+    step = (step % (nPoints - 1)) + 1; // Increment step from 1 to 59
+    rotationAngle += 5; // Rotate by 5 degrees for the next frame
+
+    setTimeout(animate, 200); // Control animation speed
+}
+
+animate();
+
diff --git a/figure_eight.html b/figure_eight.html
new file mode 100644
index 0000000..d7b3ab5
--- /dev/null
+++ b/figure_eight.html
@@ -0,0 +1,60 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>3D Figure Eight with Circles</title>
+    <style>
+        body { margin: 0; }
+        canvas { display: block; }
+    </style>
+</head>
+<body>
+    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
+    <script>
+        // Set up the scene, camera, and renderer
+        const scene = new THREE.Scene();
+        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
+        const renderer = new THREE.WebGLRenderer();
+        renderer.setSize(window.innerWidth, window.innerHeight);
+        document.body.appendChild(renderer.domElement);
+
+        // Create two circular curves
+        const radius = 5;
+        const segments = 64;
+        const curve1 = new THREE.EllipseCurve(0, 0, radius, radius, Math.PI, -Math.PI, true, 0);
+        const curve2 = new THREE.EllipseCurve(0, 0, radius, radius, 0, Math.PI, true, 0);
+
+        // Create points for each curve and join them together
+        const points1 = curve1.getPoints(segments);
+        const points2 = curve2.getPoints(segments);
+        const points = points1.concat(points2);
+
+        // Create geometry and material for the figure-eight line
+        const geometry = new THREE.BufferGeometry().setFromPoints(points);
+        const material = new THREE.LineBasicMaterial({ color: 0xff0000 });
+
+        // Create the figure-eight line
+        const figureEight = new THREE.Line(geometry, material);
+        scene.add(figureEight);
+
+        // Set the camera position
+        camera.position.z = 20;
+
+        // Animation loop
+        function animate() {
+            requestAnimationFrame(animate);
+            renderer.render(scene, camera);
+        }
+        animate();
+
+        // Handle window resize
+        window.addEventListener('resize', () => {
+            camera.aspect = window.innerWidth / window.innerHeight;
+            camera.updateProjectionMatrix();
+            renderer.setSize(window.innerWidth, window.innerHeight);
+        });
+    </script>
+</body>
+</html>
+
diff --git a/figure_eight2.html b/figure_eight2.html
new file mode 100644
index 0000000..075a948
--- /dev/null
+++ b/figure_eight2.html
@@ -0,0 +1,81 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>3D Figure Eight with Rotating Wheel</title>
+    <style>
+        body { margin: 0; }
+        canvas { display: block; }
+    </style>
+</head>
+<body>
+    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
+    <script>
+        // Set up the scene, camera, and renderer
+        const scene = new THREE.Scene();
+        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
+        const renderer = new THREE.WebGLRenderer();
+        renderer.setSize(window.innerWidth, window.innerHeight);
+        document.body.appendChild(renderer.domElement);
+
+        // Create the figure-eight path
+        const curve = new THREE.CatmullRomCurve3([
+            new THREE.Vector3(10, 0, 0),
+            new THREE.Vector3(5, 5, 0),
+            new THREE.Vector3(0, 0, 0),
+            new THREE.Vector3(-5, -5, 0),
+            new THREE.Vector3(-10, 0, 0),
+            new THREE.Vector3(-5, 5, 0),
+            new THREE.Vector3(0, 0, 0),
+            new THREE.Vector3(5, -5, 0),
+            new THREE.Vector3(10, 0, 0),
+        ]);
+        curve.closed = true;
+
+        const points = curve.getPoints(50);
+        const geometry = new THREE.BufferGeometry().setFromPoints(points);
+        const material = new THREE.LineBasicMaterial({ color: 0xff0000 });
+
+        // Create the figure-eight line
+        const figureEight = new THREE.Line(geometry, material);
+        scene.add(figureEight);
+
+        // Create a wheel
+        const wheelGeometry = new THREE.TorusGeometry(0.5, 0.2, 16, 100);
+        const wheelMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
+        const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
+        scene.add(wheel);
+
+        // Set the camera position
+        camera.position.z = 20;
+
+        // Animation loop
+        let t = 0;
+        function animate() {
+            requestAnimationFrame(animate);
+
+            // Update the wheel position
+            const point = curve.getPointAt(t);
+            wheel.position.set(point.x, point.y, point.z);
+
+            // Update the wheel rotation
+            const tangent = curve.getTangentAt(t).normalize();
+            wheel.quaternion.setFromUnitVectors(new THREE.Vector3(1, 0, 0), tangent);
+
+            t = (t + 0.001) % 1;  // Move along the curve
+
+            renderer.render(scene, camera);
+        }
+        animate();
+
+        // Handle window resize
+        window.addEventListener('resize', () => {
+            camera.aspect = window.innerWidth / window.innerHeight;
+            camera.updateProjectionMatrix();
+            renderer.setSize(window.innerWidth, window.innerHeight);
+        });
+    </script>
+</body>
+</html>
+
diff --git a/five_rotate_spoke.html b/five_rotate_spoke.html
new file mode 100644
index 0000000..2913d23
--- /dev/null
+++ b/five_rotate_spoke.html
@@ -0,0 +1,58 @@
+<!DOCTYPE html>
+<html>
+<body>
+
+<canvas id="illusionCanvas" width="1200" height="1200"></canvas>
+
+<script>
+const canvas = document.getElementById('illusionCanvas');
+const ctx = canvas.getContext('2d');
+
+const centerX = canvas.width / 2;
+const centerY = canvas.height / 2;
+const sector = 30; // Number of sectors in a spoke
+const maxRadius = Math.min(canvas.width, canvas.height) / 2;
+const pentagonRadius = maxRadius / 3; // Radius of the pentagon
+var sub_shift_angle = 0; // Angle for rotating the main spoke
+var pentagon_shift_angle = 0; // Angle for rotating the pentagon
+
+function draw_rotating_spoke(centerX, centerY, maxRadius, sub_shift_angle) {
+    for (let i = 0; i < sector; i++) {
+        let angle = (i / sector) * 2 * Math.PI;
+        let x = centerX + maxRadius * Math.cos(angle + sub_shift_angle);
+        let y = centerY + maxRadius * Math.sin(angle + sub_shift_angle);
+
+        ctx.strokeStyle = (i % 2 === 0) ? 'black' : 'blue';
+        ctx.lineWidth = 2;
+
+        ctx.beginPath();
+        ctx.moveTo(centerX, centerY);
+        ctx.lineTo(x, y);
+        ctx.stroke();
+    }
+}
+
+function draw() {
+    sub_shift_angle += 2 * Math.PI / sector / 10;
+    pentagon_shift_angle += 2 * Math.PI / 360; // Slow rotation for the pentagon
+
+    ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
+
+    // Draw 5 spokes, each at a vertex of a rotating pentagon
+    for (let i = 0; i < 5; i++) {
+        let angle = (i / 5) * 2 * Math.PI + pentagon_shift_angle; // Angle for pentagon vertices
+        let spokeCenterX = centerX + pentagonRadius * Math.cos(angle);
+        let spokeCenterY = centerY + pentagonRadius * Math.sin(angle);
+
+        draw_rotating_spoke(spokeCenterX, spokeCenterY, maxRadius / 5, sub_shift_angle); // Draw each spoke
+    }
+
+    window.requestAnimationFrame(draw); // Continue the animation
+}
+
+draw();
+</script>
+
+</body>
+</html>
+
diff --git a/five_rotate_spoke_sector.html b/five_rotate_spoke_sector.html
new file mode 100644
index 0000000..8cf6b80
--- /dev/null
+++ b/five_rotate_spoke_sector.html
@@ -0,0 +1,65 @@
+<!DOCTYPE html>
+<html>
+<body>
+
+<canvas id="illusionCanvas" width="1200" height="1200"></canvas>
+
+<script>
+const canvas = document.getElementById('illusionCanvas');
+const ctx = canvas.getContext('2d');
+
+const centerX = canvas.width / 2;
+const centerY = canvas.height / 2;
+const sector = 30; // Number of sectors in a spoke
+const maxRadius = Math.min(canvas.width, canvas.height) / 2;
+const pentagonRadius = maxRadius / 3; // Radius of the pentagon
+var sub_shift_angle = 0; // Angle for rotating the main spoke
+var pentagon_shift_angle = 0; // Angle for rotating the pentagon
+
+// Define a set of colors for the sectors
+const colors = ['red', 'green', 'blue', 'yellow', 'purple'];
+
+function draw_rotating_spoke(centerX, centerY, maxRadius, sub_shift_angle) {
+    for (let i = 0; i < sector; i++) {
+        let angle = (i / sector) * 2 * Math.PI;
+        let endAngle = ((i + 1) / sector) * 2 * Math.PI;
+        let x1 = centerX + maxRadius * Math.cos(angle + sub_shift_angle);
+        let y1 = centerY + maxRadius * Math.sin(angle + sub_shift_angle);
+        let x2 = centerX + maxRadius * Math.cos(endAngle + sub_shift_angle);
+        let y2 = centerY + maxRadius * Math.sin(endAngle + sub_shift_angle);
+
+        ctx.fillStyle = colors[i % colors.length];
+
+        ctx.beginPath();
+        ctx.moveTo(centerX, centerY);
+        ctx.lineTo(x1, y1);
+        ctx.lineTo(x2, y2);
+        ctx.closePath();
+        ctx.fill();
+    }
+}
+
+function draw() {
+    sub_shift_angle += 2 * Math.PI / sector / 10;
+    pentagon_shift_angle += 2 * Math.PI / 360; // Slow rotation for the pentagon
+
+    ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
+
+    // Draw 5 spokes, each at a vertex of a rotating pentagon
+    for (let i = 0; i < 5; i++) {
+        let angle = (i / 5) * 2 * Math.PI + pentagon_shift_angle; // Angle for pentagon vertices
+        let spokeCenterX = centerX + pentagonRadius * Math.cos(angle);
+        let spokeCenterY = centerY + pentagonRadius * Math.sin(angle);
+
+        draw_rotating_spoke(spokeCenterX, spokeCenterY, maxRadius / 5, sub_shift_angle); // Draw each spoke
+    }
+
+    window.requestAnimationFrame(draw); // Continue the animation
+}
+
+draw();
+</script>
+
+</body>
+</html>
+
diff --git a/four_petal.html b/four_petal.html
new file mode 100644
index 0000000..b61f8ca
--- /dev/null
+++ b/four_petal.html
@@ -0,0 +1,28 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Four-Petal Shape Animation</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            background-color: white;
+            border: 1px solid #ccc;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="animationCanvas" width="600" height="600"></canvas>
+    <script src="four_petal.js"></script>
+</body>
+</html>
+
diff --git a/four_petal.js b/four_petal.js
new file mode 100644
index 0000000..fed8978
--- /dev/null
+++ b/four_petal.js
@@ -0,0 +1,57 @@
+
+const canvas = document.getElementById('animationCanvas');
+const ctx = canvas.getContext('2d');
+const nPoints = 240;
+let step = 1;
+
+function getPoints() {
+    const points = [];
+    const centerX = canvas.width / 2;
+    const centerY = canvas.height / 2;
+    const radius = Math.min(centerX, centerY) * 0.9;
+
+    for (let i = 0; i < nPoints; i++) {
+        const theta = (2 * Math.PI * i) / nPoints;
+        const r = Math.cos(4 * theta);
+        const x = centerX + radius * r * Math.cos(theta);
+        const y = centerY + radius * r * Math.sin(theta);
+        points.push({ x, y });
+    }
+
+    return points;
+}
+
+function drawPoints(points) {
+    ctx.clearRect(0, 0, canvas.width, canvas.height);
+    ctx.fillStyle = 'blue';
+
+    for (const point of points) {
+        ctx.beginPath();
+        ctx.arc(point.x, point.y, 3, 0, 2 * Math.PI);
+        ctx.fill();
+    }
+}
+
+function drawLines(points, step) {
+    ctx.strokeStyle = 'blue';
+
+    for (let i = 0; i < points.length; i++) {
+        const j = (i + step) % points.length;
+        ctx.beginPath();
+        ctx.moveTo(points[i].x, points[i].y);
+        ctx.lineTo(points[j].x, points[j].y);
+        ctx.stroke();
+    }
+}
+
+function animate() {
+    const points = getPoints();
+    drawPoints(points);
+    drawLines(points, step);
+    step = (step % (nPoints - 1)) + 1; // Increment step from 1 to 59
+
+    setTimeout(animate, 200); // Control animation speed
+}
+
+animate();
+
diff --git a/four_petal_double.html b/four_petal_double.html
new file mode 100644
index 0000000..4c2bde2
--- /dev/null
+++ b/four_petal_double.html
@@ -0,0 +1,28 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Four Petal Lines Animation</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            background-color: white;
+            border: 1px solid #ccc;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="animationCanvas" width="600" height="600"></canvas>
+    <script src="four_petal_double.js"></script>
+</body>
+</html>
+
diff --git a/four_petal_double.js b/four_petal_double.js
new file mode 100644
index 0000000..fb4cdef
--- /dev/null
+++ b/four_petal_double.js
@@ -0,0 +1,77 @@
+
+const canvas = document.getElementById('animationCanvas');
+const ctx = canvas.getContext('2d');
+const nPoints = 240;
+const bigA = 200; // Semi-major axis length of the big ellipse
+const bigB = 100; // Semi-minor axis length of the big ellipse
+const smallA = 100; // Semi-major axis length of the small ellipse
+const smallB = 50;  // Semi-minor axis length of the small ellipse
+let bigRotationAngle = 0; // Initialize rotation angle for the big ellipse
+let smallRotationAngle = 0; // Initialize rotation angle for the small ellipse
+
+function getPoints(a, b, rotationAngle) {
+    const points = [];
+    const centerX = canvas.width / 2;
+    const centerY = canvas.height / 2;
+    const rotationRadians = rotationAngle * Math.PI / 180; // Convert degrees to radians
+
+    for (let i = 0; i < nPoints; i++) {
+        const theta = (2 * Math.PI * i) / nPoints;
+        const x = centerX + (a * Math.cos(4*theta) * Math.cos(rotationRadians) - b * Math.sin(4*theta) * Math.sin(rotationRadians));
+        const y = centerY + (a * Math.cos(4*theta) * Math.sin(rotationRadians) + b * Math.sin(4*theta) * Math.cos(rotationRadians));
+        points.push({ x, y });
+    }
+
+    return points;
+}
+
+function drawPoints(points, color) {
+    ctx.fillStyle = color;
+
+    for (const point of points) {
+        ctx.beginPath();
+        ctx.arc(point.x, point.y, 3, 0, 2 * Math.PI);
+        ctx.fill();
+    }
+}
+
+function drawLines(points1, points2) {
+    ctx.strokeStyle = 'blue';
+
+    //for (let step = 0; step < points1.length; step += 3) {
+    step = 2;
+    for (let i = 0; i < points1.length; i++) {
+	const j = (i + step) % points1.length;
+        ctx.beginPath();
+        ctx.moveTo(points1[i].x, points1[i].y);
+        ctx.lineTo(points2[j].x, points2[j].y);
+        ctx.stroke();
+    }
+    //}
+}
+
+function animate() {
+    // Get points for both ellipses
+    const bigEllipsePoints = getPoints(bigA, bigB, bigRotationAngle);
+    const smallEllipsePoints = getPoints(smallA, smallB, smallRotationAngle);
+
+    // Clear the canvas
+    ctx.clearRect(0, 0, canvas.width, canvas.height);
+
+    // Draw the points on both ellipses
+    drawPoints(bigEllipsePoints, 'red');
+    drawPoints(smallEllipsePoints, 'green');
+
+    // Draw lines connecting corresponding points of the two ellipses
+    drawLines(bigEllipsePoints, smallEllipsePoints);
+
+    // Increment rotation angles for the next frame
+    bigRotationAngle += 5;  // Rotate the big ellipse by 5 degrees
+    smallRotationAngle += 10; // Rotate the small ellipse by 10 degrees
+
+    // Control animation speed and repeat
+    setTimeout(animate, 200);
+}
+
+animate();
+
diff --git a/four_petal_rotate.html b/four_petal_rotate.html
new file mode 100644
index 0000000..8676bcb
--- /dev/null
+++ b/four_petal_rotate.html
@@ -0,0 +1,28 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Four Petal Lines Animation</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            background-color: white;
+            border: 1px solid #ccc;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="animationCanvas" width="600" height="600"></canvas>
+    <script src="four_petal_rotate.js"></script>
+</body>
+</html>
+
diff --git a/four_petal_rotate.js b/four_petal_rotate.js
new file mode 100644
index 0000000..2d43d9a
--- /dev/null
+++ b/four_petal_rotate.js
@@ -0,0 +1,83 @@
+
+const canvas = document.getElementById('animationCanvas');
+const ctx = canvas.getContext('2d');
+const nPoints = 240;
+let step = 1;
+let rotationAngle = 0;
+
+function getPoints() {
+    const points = [];
+    const centerX = canvas.width / 2;
+    const centerY = canvas.height / 2;
+    const radius = Math.min(centerX, centerY) * 0.9;
+
+    for (let i = 0; i < nPoints; i++) {
+        const theta = (2 * Math.PI * i) / nPoints;
+        const r = Math.cos(4 * theta);
+        const x = centerX + radius * r * Math.cos(theta);
+        const y = centerY + radius * r * Math.sin(theta);
+        points.push({ x, y });
+    }
+
+    return points;
+}
+
+function rotatePoints(points, angle) {
+    const rotatedPoints = [];
+    const centerX = canvas.width / 2;
+    const centerY = canvas.height / 2;
+    const rad = angle * (Math.PI / 180); // Convert degrees to radians
+
+    for (const point of points) {
+        const x = point.x - centerX;
+        const y = point.y - centerY;
+
+        const newX = x * Math.cos(rad) - y * Math.sin(rad);
+        const newY = x * Math.sin(rad) + y * Math.cos(rad);
+
+        rotatedPoints.push({
+            x: newX + centerX,
+            y: newY + centerY,
+        });
+    }
+
+    return rotatedPoints;
+}
+
+function drawPoints(points) {
+    ctx.clearRect(0, 0, canvas.width, canvas.height);
+    ctx.fillStyle = 'blue';
+
+    for (const point of points) {
+        ctx.beginPath();
+        ctx.arc(point.x, point.y, 3, 0, 2 * Math.PI);
+        ctx.fill();
+    }
+}
+
+function drawLines(points, step) {
+    ctx.strokeStyle = 'blue';
+
+    for (let i = 0; i < points.length; i++) {
+        const j = (i + step) % points.length;
+        ctx.beginPath();
+        ctx.moveTo(points[i].x, points[i].y);
+        ctx.lineTo(points[j].x, points[j].y);
+        ctx.stroke();
+    }
+}
+
+function animate() {
+    const points = getPoints();
+    const rotatedPoints = rotatePoints(points, rotationAngle);
+    drawPoints(rotatedPoints);
+    drawLines(rotatedPoints, step);
+    
+    step = (step % (nPoints - 1)) + 1; // Increment step from 1 to 59
+    rotationAngle += 3; // Rotate by 3 degrees each time
+
+    setTimeout(animate, 200); // Control animation speed
+}
+
+animate();
+
diff --git a/index.html b/index.html
new file mode 100644
index 0000000..8080f18
--- /dev/null
+++ b/index.html
@@ -0,0 +1,80 @@
+<li><a href="four_petal_rotate.html"> four_petal_rotate.html </a></li>
+<li><a href="four_petal_double.html"> four_petal_double.html </a></li>
+<li><a href="two_ellipse.html"> two_ellipse.html </a></li>
+<li><a href="ellipsical_line_rotate.html"> ellipsical_line_rotate.html </a></li>
+<li><a href="ellipsical_line.html"> ellipsical_line.html </a></li>
+<li><a href="three_petal.html"> three_petal.html </a></li>
+<li><a href="four_petal.html"> four_petal.html </a></li>
+<li><a href="two_petal.html"> two_petal.html </a></li>
+<li><a href="chasing_square2.html"> chasing_square2.html </a></li>
+<li><a href="concentric.html"> concentric.html </a></li>
+<li><a href="static_concentric.html"> static_concentric.html </a></li>
+<li><a href="2d_surface.html"> 2d_surface.html </a></li>
+<li><a href="chasing_square1.html"> chasing_square1.html </a></li>
+<li><a href="chasing_square.html"> chasing_square.html </a></li>
+<li><a href="spherical_sinusoid3.html"> spherical_sinusoid3.html </a></li>
+<li><a href="spherical_sinusoid2.html"> spherical_sinusoid2.html </a></li>
+<li><a href="spherical_sinusoid.html"> spherical_sinusoid.html </a></li>
+<li><a href="spherical_sinusoid1.html"> spherical_sinusoid1.html </a></li>
+<li><a href="sinsoidal5.html"> sinsoidal5.html </a></li>
+<li><a href="sinusoidal.html"> sinusoidal.html </a></li>
+<li><a href="solid_torus1.html"> solid_torus1.html </a></li>
+<li><a href="solid_torus.html"> solid_torus.html </a></li>
+<li><a href="ellipse4.html"> ellipse4.html </a></li>
+<li><a href="o.html"> o.html </a></li>
+<li><a href="torus.html"> torus.html </a></li>
+<li><a href="circle2.html"> circle2.html </a></li>
+<li><a href="css_circle1.html"> css_circle1.html </a></li>
+<li><a href="css_circle.html"> css_circle.html </a></li>
+<li><a href="d3_graph.html"> d3_graph.html </a></li>
+<li><a href="ellipse2.html"> ellipse2.html </a></li>
+<li><a href="ellipse3.html"> ellipse3.html </a></li>
+<li><a href="figure_eight2.html"> figure_eight2.html </a></li>
+<li><a href="figure_eight.html"> figure_eight.html </a></li>
+<li><a href="klein3.html"> klein3.html </a></li>
+<li><a href="klein4.html"> klein4.html </a></li>
+<li><a href="klein5.html"> klein5.html </a></li>
+<li><a href="klein6.html"> klein6.html </a></li>
+<li><a href="klein7.html"> klein7.html </a></li>
+<li><a href="mobius.html"> mobius.html </a></li>
+<li><a href="webgl_3dcube.html"> webgl_3dcube.html </a></li>
+<li><a href="css_3dcube.html"> css_3dcube.html </a></li>
+<li><a href="line_drawing.html"> line_drawing.html </a></li>
+<li><a href="webgl.html"> webgl.html </a></li>
+<li><a href="circle_color.html"> circle_color.html </a></li>
+<li><a href="circle.html"> circle.html </a></li>
+<li><a href="double1.html"> double1.html </a></li>
+<li><a href="double3.html"> double3.html </a></li>
+<li><a href="double4.html"> double4.html </a></li>
+<li><a href="double5.html"> double5.html </a></li>
+<li><a href="double_globe.html"> double_globe.html </a></li>
+<li><a href="double.html"> double.html </a></li>
+<li><a href="double_motion.html"> double_motion.html </a></li>
+<li><a href="drawsector.html"> drawsector.html </a></li>
+<li><a href="ellipse_color2.html"> ellipse_color2.html </a></li>
+<li><a href="ellipse_color.html"> ellipse_color.html </a></li>
+<li><a href="ellipse.html"> ellipse.html </a></li>
+<li><a href="klein2_animation2.html"> klein2_animation2.html </a></li>
+<li><a href="klein2_animation3.html"> klein2_animation3.html </a></li>
+<li><a href="klein2_animation.html"> klein2_animation.html </a></li>
+<li><a href="klein2.html"> klein2.html </a></li>
+<li><a href="klein.html"> klein.html </a></li>
+<li><a href="quart_motion.html"> quart_motion.html </a></li>
+<li><a href="special.html"> special.html </a></li>
+<li><a href="triple_motion.html"> triple_motion.html </a></li>
+<li><a href="mywebgl.html"> mywebgl.html </a></li>
+<li><a href="counter_rotating_sector.html"> counter_rotating_sector.html </a></li>
+<li><a href="rotating_sector.html"> rotating_sector.html </a></li>
+<li><a href="five_rotate_spoke_sector.html"> five_rotate_spoke_sector.html </a></li>
+<li><a href="not_working.html"> not_working.html </a></li>
+<li><a href="five_rotate_spoke.html"> five_rotate_spoke.html </a></li>
+<li><a href="rotating_spoke.html"> rotating_spoke.html </a></li>
+<li><a href="rotating_spiral.html"> rotating_spiral.html </a></li>
+<li><a href="spiral.html"> spiral.html </a></li>
+<li><a href="spoke_subspokes.html"> spoke_subspokes.html </a></li>
+<li><a href="moving_square5.html"> moving_square5.html </a></li>
+<li><a href="moving_square4.html"> moving_square4.html </a></li>
+<li><a href="moving_square3.html"> moving_square3.html </a></li>
+<li><a href="moving_square2.html"> moving_square2.html </a></li>
+<li><a href="moving_square.html"> moving_square.html </a></li>
+<li><a href="line.html"> line.html </a></li>
diff --git a/klein.html b/klein.html
new file mode 100644
index 0000000..f7f2339
--- /dev/null
+++ b/klein.html
@@ -0,0 +1,81 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Klein Bottle Line Drawing</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+            background-color: #fff;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="kleinBottleCanvas" width="600" height="600"></canvas>
+    <script>
+        const canvas = document.getElementById('kleinBottleCanvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const scale = 60;
+        const numU = 50;
+        const numV = 50;
+
+        function drawKleinBottle() {
+            ctx.clearRect(0, 0, canvas.width, canvas.height);
+            ctx.strokeStyle = '#000000';
+            ctx.lineWidth = 0.5;
+
+            for (let i = 0; i <= numU; i++) {
+                const u = (i / numU) * 2 * Math.PI;
+                ctx.beginPath();
+                for (let j = 0; j <= numV; j++) {
+                    const v = (j / numV) * 2 * Math.PI;
+                    const x = (scale * (Math.cos(u) * (1 + Math.sin(u)) + (v - Math.PI) * Math.cos(u) / 2));
+                    const y = (scale * (Math.sin(u) * (1 + Math.sin(u)) + (v - Math.PI) * Math.sin(u) / 2));
+                    const z = scale * (Math.cos(u) * Math.sin(u) + Math.cos(v));
+                    const xProj = centerX + x * Math.cos(u) - z * Math.sin(u);
+                    const yProj = centerY + y * Math.cos(v) - z * Math.sin(v);
+                    if (j === 0) {
+                        ctx.moveTo(xProj, yProj);
+                    } else {
+                        ctx.lineTo(xProj, yProj);
+                    }
+                }
+                ctx.stroke();
+            }
+
+            for (let j = 0; j <= numV; j++) {
+                const v = (j / numV) * 2 * Math.PI;
+                ctx.beginPath();
+                for (let i = 0; i <= numU; i++) {
+                    const u = (i / numU) * 2 * Math.PI;
+                    const x = (scale * (Math.cos(u) * (1 + Math.sin(u)) + (v - Math.PI) * Math.cos(u) / 2));
+                    const y = (scale * (Math.sin(u) * (1 + Math.sin(u)) + (v - Math.PI) * Math.sin(u) / 2));
+                    const z = scale * (Math.cos(u) * Math.sin(u) + Math.cos(v));
+                    const xProj = centerX + x * Math.cos(u) - z * Math.sin(u);
+                    const yProj = centerY + y * Math.cos(v) - z * Math.sin(v);
+                    if (i === 0) {
+                        ctx.moveTo(xProj, yProj);
+                    } else {
+                        ctx.lineTo(xProj, yProj);
+                    }
+                }
+                ctx.stroke();
+            }
+        }
+
+        drawKleinBottle();
+    </script>
+</body>
+</html>
+
diff --git a/klein2.html b/klein2.html
new file mode 100644
index 0000000..673538d
--- /dev/null
+++ b/klein2.html
@@ -0,0 +1,111 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Klein Bottle Line Drawing</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+            background-color: #fff;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="kleinBottleCanvas" width="600" height="600"></canvas>
+    <script>
+        const canvas = document.getElementById('kleinBottleCanvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const scale = 100;
+        const numU = 60;
+        const numV = 60;
+
+        function drawKleinBottle() {
+            ctx.clearRect(0, 0, canvas.width, canvas.height);
+            ctx.strokeStyle = '#000000';
+            ctx.lineWidth = 0.5;
+
+            function kleinBottleX(u, v) {
+                if (u < Math.PI) {
+                    return 3 * Math.cos(u) * (1 + Math.sin(u)) + scale * Math.cos(u) * Math.cos(v);
+                } else {
+                    return 3 * Math.cos(u) * (1 + Math.sin(u)) + scale * Math.cos(v + Math.PI);
+                }
+            }
+
+            function kleinBottleY(u, v) {
+                if (u < Math.PI) {
+                    return 3 * Math.sin(u) * (1 + Math.sin(u)) + scale * Math.sin(u) * Math.cos(v);
+                } else {
+                    return 3 * Math.sin(u) * (1 + Math.sin(u));
+                }
+            }
+
+            function kleinBottleZ(u, v) {
+                if (u < Math.PI) {
+                    return scale * Math.sin(v);
+                } else {
+                    return scale * Math.sin(v + Math.PI);
+                }
+            }
+
+            for (let i = 0; i <= numU; i++) {
+                const u = (i / numU) * 2 * Math.PI;
+                ctx.beginPath();
+                for (let j = 0; j <= numV; j++) {
+                    const v = (j / numV) * 2 * Math.PI;
+                    const x = kleinBottleX(u, v);
+                    const y = kleinBottleY(u, v);
+                    const z = kleinBottleZ(u, v);
+
+                    // Simple 2D projection
+                    const xProj = centerX + x - z * 0.5;
+                    const yProj = centerY + y - z * 0.5;
+
+                    if (j === 0) {
+                        ctx.moveTo(xProj, yProj);
+                    } else {
+                        ctx.lineTo(xProj, yProj);
+                    }
+                }
+                ctx.stroke();
+            }
+
+            for (let j = 0; j <= numV; j++) {
+                const v = (j / numV) * 2 * Math.PI;
+                ctx.beginPath();
+                for (let i = 0; i <= numU; i++) {
+                    const u = (i / numU) * 2 * Math.PI;
+                    const x = kleinBottleX(u, v);
+                    const y = kleinBottleY(u, v);
+                    const z = kleinBottleZ(u, v);
+
+                    // Simple 2D projection
+                    const xProj = centerX + x - z * 0.5;
+                    const yProj = centerY + y - z * 0.5;
+
+                    if (i === 0) {
+                        ctx.moveTo(xProj, yProj);
+                    } else {
+                        ctx.lineTo(xProj, yProj);
+                    }
+                }
+                ctx.stroke();
+            }
+        }
+
+        drawKleinBottle();
+    </script>
+</body>
+</html>
+
diff --git a/klein2_animation.html b/klein2_animation.html
new file mode 100644
index 0000000..c530c75
--- /dev/null
+++ b/klein2_animation.html
@@ -0,0 +1,121 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Klein Bottle Line Drawing</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+            background-color: #fff;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="kleinBottleCanvas" width="600" height="600"></canvas>
+    <script>
+        const canvas = document.getElementById('kleinBottleCanvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        let scale = 50;
+        let scale2 = 50;
+        const numU = 60;
+        const numV = 60;
+        let time = 0;
+
+        function drawKleinBottle() {
+            ctx.clearRect(0, 0, canvas.width, canvas.height);
+            ctx.strokeStyle = '#000000';
+            ctx.lineWidth = 0.5;
+
+            function kleinBottleX(u, v) {
+                if (u < Math.PI) {
+                    return scale2 * Math.cos(u) * (1 + Math.sin(u)) + scale * Math.cos(u) * Math.cos(v + time);
+                } else {
+                    return scale2 * Math.cos(u) * (1 + Math.sin(u)) + scale * Math.cos(v + Math.PI + time);
+                }
+            }
+
+            function kleinBottleY(u, v) {
+                if (u < Math.PI) {
+                    return scale2 * Math.sin(u) * (1 + Math.sin(u)) + scale * Math.sin(u) * Math.cos(v + time);
+                } else {
+                    return scale2 * Math.sin(u) * (1 + Math.sin(u));
+                }
+            }
+
+            function kleinBottleZ(u, v) {
+                if (u < Math.PI) {
+                    return scale * Math.sin(v + time);
+                } else {
+                    return scale * Math.sin(v + Math.PI + time);
+                }
+            }
+
+            for (let i = 0; i <= numU; i++) {
+                const u = (i / numU) * 2 * Math.PI;
+                ctx.beginPath();
+                for (let j = 0; j <= numV; j++) {
+                    const v = (j / numV) * 2 * Math.PI;
+                    const x = kleinBottleX(u, v);
+                    const y = kleinBottleY(u, v);
+                    const z = kleinBottleZ(u, v);
+
+                    // Simple 2D projection
+                    const xProj = centerX + x - z * 0.5;
+                    const yProj = centerY + y - z * 0.5;
+
+                    if (j === 0) {
+                        ctx.moveTo(xProj, yProj);
+                    } else {
+                        ctx.lineTo(xProj, yProj);
+                    }
+                }
+                ctx.stroke();
+            }
+
+            for (let j = 0; j <= numV; j++) {
+                const v = (j / numV) * 2 * Math.PI;
+                ctx.beginPath();
+                for (let i = 0; i <= numU; i++) {
+                    const u = (i / numU) * 2 * Math.PI;
+                    const x = kleinBottleX(u, v);
+                    const y = kleinBottleY(u, v);
+                    const z = kleinBottleZ(u, v);
+
+                    // Simple 2D projection
+                    const xProj = centerX + x - z * 0.5;
+                    const yProj = centerY + y - z * 0.5;
+
+                    if (i === 0) {
+                        ctx.moveTo(xProj, yProj);
+                    } else {
+                        ctx.lineTo(xProj, yProj);
+                    }
+                }
+                ctx.stroke();
+            }
+        }
+
+        function animate() {
+            time += 0.01;
+            scale = 50 + 50 * Math.sin(time * Math.PI);
+            scale2 = 50 + 50 * Math.cos(2 * time * Math.PI);
+            drawKleinBottle();
+            requestAnimationFrame(animate);
+        }
+
+        animate();
+    </script>
+</body>
+</html>
+
diff --git a/klein2_animation2.html b/klein2_animation2.html
new file mode 100644
index 0000000..673538d
--- /dev/null
+++ b/klein2_animation2.html
@@ -0,0 +1,111 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Klein Bottle Line Drawing</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+            background-color: #fff;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="kleinBottleCanvas" width="600" height="600"></canvas>
+    <script>
+        const canvas = document.getElementById('kleinBottleCanvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const scale = 100;
+        const numU = 60;
+        const numV = 60;
+
+        function drawKleinBottle() {
+            ctx.clearRect(0, 0, canvas.width, canvas.height);
+            ctx.strokeStyle = '#000000';
+            ctx.lineWidth = 0.5;
+
+            function kleinBottleX(u, v) {
+                if (u < Math.PI) {
+                    return 3 * Math.cos(u) * (1 + Math.sin(u)) + scale * Math.cos(u) * Math.cos(v);
+                } else {
+                    return 3 * Math.cos(u) * (1 + Math.sin(u)) + scale * Math.cos(v + Math.PI);
+                }
+            }
+
+            function kleinBottleY(u, v) {
+                if (u < Math.PI) {
+                    return 3 * Math.sin(u) * (1 + Math.sin(u)) + scale * Math.sin(u) * Math.cos(v);
+                } else {
+                    return 3 * Math.sin(u) * (1 + Math.sin(u));
+                }
+            }
+
+            function kleinBottleZ(u, v) {
+                if (u < Math.PI) {
+                    return scale * Math.sin(v);
+                } else {
+                    return scale * Math.sin(v + Math.PI);
+                }
+            }
+
+            for (let i = 0; i <= numU; i++) {
+                const u = (i / numU) * 2 * Math.PI;
+                ctx.beginPath();
+                for (let j = 0; j <= numV; j++) {
+                    const v = (j / numV) * 2 * Math.PI;
+                    const x = kleinBottleX(u, v);
+                    const y = kleinBottleY(u, v);
+                    const z = kleinBottleZ(u, v);
+
+                    // Simple 2D projection
+                    const xProj = centerX + x - z * 0.5;
+                    const yProj = centerY + y - z * 0.5;
+
+                    if (j === 0) {
+                        ctx.moveTo(xProj, yProj);
+                    } else {
+                        ctx.lineTo(xProj, yProj);
+                    }
+                }
+                ctx.stroke();
+            }
+
+            for (let j = 0; j <= numV; j++) {
+                const v = (j / numV) * 2 * Math.PI;
+                ctx.beginPath();
+                for (let i = 0; i <= numU; i++) {
+                    const u = (i / numU) * 2 * Math.PI;
+                    const x = kleinBottleX(u, v);
+                    const y = kleinBottleY(u, v);
+                    const z = kleinBottleZ(u, v);
+
+                    // Simple 2D projection
+                    const xProj = centerX + x - z * 0.5;
+                    const yProj = centerY + y - z * 0.5;
+
+                    if (i === 0) {
+                        ctx.moveTo(xProj, yProj);
+                    } else {
+                        ctx.lineTo(xProj, yProj);
+                    }
+                }
+                ctx.stroke();
+            }
+        }
+
+        drawKleinBottle();
+    </script>
+</body>
+</html>
+
diff --git a/klein2_animation3.html b/klein2_animation3.html
new file mode 100644
index 0000000..5b9113d
--- /dev/null
+++ b/klein2_animation3.html
@@ -0,0 +1,121 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Klein Bottle Line Drawing</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+            background-color: #fff;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="kleinBottleCanvas" width="600" height="600"></canvas>
+    <script>
+        const canvas = document.getElementById('kleinBottleCanvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        let scale = 50;
+        let scale2 = 50;
+        const numU = 60;
+        const numV = 60;
+        let time = 0;
+
+        function drawKleinBottle() {
+            ctx.clearRect(0, 0, canvas.width, canvas.height);
+            ctx.strokeStyle = '#000000';
+            ctx.lineWidth = 0.5;
+
+            function kleinBottleX(u, v) {
+                if (u < Math.PI) {
+                    return scale2 * Math.cos(u) * (1 + Math.sin(u)) + scale * Math.cos(u) * Math.cos(v + time);
+                } else {
+                    return scale2 * Math.cos(u) * (1 + Math.sin(u)) + scale * Math.cos(v + Math.PI + time);
+                }
+            }
+
+            function kleinBottleY(u, v) {
+                if (u < Math.PI) {
+                    return scale2 * Math.sin(u) * (1 + Math.sin(u)) + scale * Math.sin(u) * Math.cos(v + time);
+                } else {
+                    return scale2 * Math.sin(u) * (1 + Math.sin(u));
+                }
+            }
+
+            function kleinBottleZ(u, v) {
+                if (u < Math.PI) {
+                    return scale * Math.sin(v + time);
+                } else {
+                    return scale * Math.sin(v + Math.PI + time);
+                }
+            }
+
+            for (let i = 0; i <= numU; i++) {
+                const u = (i / numU) * 2 * Math.PI;
+                ctx.beginPath();
+                for (let j = 0; j <= numV; j++) {
+                    const v = (j / numV) * 2 * Math.PI;
+                    const x = kleinBottleX(u, v);
+                    const y = kleinBottleY(u, v);
+                    const z = kleinBottleZ(u, v);
+
+                    // Simple 2D projection
+                    const xProj = centerX + x - z * 0.5;
+                    const yProj = centerY + y - z * 0.5;
+
+                    if (j === 0) {
+                        ctx.moveTo(xProj, yProj);
+                    } else {
+                        ctx.lineTo(xProj, yProj);
+                    }
+                }
+                ctx.stroke();
+            }
+
+            for (let j = 0; j <= numV; j++) {
+                const v = (j / numV) * 2 * Math.PI;
+                ctx.beginPath();
+                for (let i = 0; i <= numU; i++) {
+                    const u = (i / numU) * 2 * Math.PI;
+                    const x = kleinBottleX(u, v);
+                    const y = kleinBottleY(u, v);
+                    const z = kleinBottleZ(u, v);
+
+                    // Simple 2D projection
+                    const xProj = centerX + x - z * 0.5;
+                    const yProj = centerY + y - z * 0.5;
+
+                    if (i === 0) {
+                        ctx.moveTo(xProj, yProj);
+                    } else {
+                        ctx.lineTo(xProj, yProj);
+                    }
+                }
+                ctx.stroke();
+            }
+        }
+
+        function animate() {
+            time += 0.005;
+            scale = 90 + 80 * Math.sin(4*time * Math.PI);
+            scale2 = 90 + 80 * Math.cos(2 * time * Math.PI);
+            drawKleinBottle();
+            requestAnimationFrame(animate);
+        }
+
+        animate();
+    </script>
+</body>
+</html>
+
diff --git a/klein3.html b/klein3.html
new file mode 100644
index 0000000..e1a8341
--- /dev/null
+++ b/klein3.html
@@ -0,0 +1,112 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Klein Bottle Wireframe</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="canvas" width="800" height="800"></canvas>
+    <script>
+        const canvas = document.getElementById('canvas');
+        const ctx = canvas.getContext('2d');
+        const width = canvas.width;
+        const height = canvas.height;
+        const centerX = width / 2;
+        const centerY = height / 2;
+        const scale = 80;
+
+        // Rotation angles
+        const angleX = Math.PI / 6; // Rotate around the X-axis
+        const angleY = Math.PI / 6; // Rotate around the Y-axis
+        const angleZ = Math.PI / 6; // Rotate around the Z-axis
+
+        function rotateX(x, y, z, angle) {
+            const cos = Math.cos(angle);
+            const sin = Math.sin(angle);
+            return [x, y * cos - z * sin, y * sin + z * cos];
+        }
+
+        function rotateY(x, y, z, angle) {
+            const cos = Math.cos(angle);
+            const sin = Math.sin(angle);
+            return [x * cos + z * sin, y, -x * sin + z * cos];
+        }
+
+        function rotateZ(x, y, z, angle) {
+            const cos = Math.cos(angle);
+            const sin = Math.sin(angle);
+            return [x * cos - y * sin, x * sin + y * cos, z];
+        }
+
+        function drawKleinBottle() {
+            const uStep = Math.PI / 18;
+            const vStep = 2 * Math.PI / 36;
+
+            for (let u = 0; u < 2 * Math.PI; u += uStep) {
+                for (let v = 0; v < 2 * Math.PI; v += vStep) {
+                    let x = (4 + 2 * Math.cos(u)) * Math.cos(v);
+                    let y = (4 + 2 * Math.cos(u)) * Math.sin(v);
+                    let z = 2 * Math.sin(u) * Math.cos(v / 2);
+
+                    [x, y, z] = rotateX(x, y, z, angleX);
+                    [x, y, z] = rotateY(x, y, z, angleY);
+                    [x, y, z] = rotateZ(x, y, z, angleZ);
+
+                    let nextX = (4 + 2 * Math.cos(u + uStep)) * Math.cos(v);
+                    let nextY = (4 + 2 * Math.cos(u + uStep)) * Math.sin(v);
+                    let nextZ = 2 * Math.sin(u + uStep) * Math.cos(v / 2);
+
+                    [nextX, nextY, nextZ] = rotateX(nextX, nextY, nextZ, angleX);
+                    [nextX, nextY, nextZ] = rotateY(nextX, nextY, nextZ, angleY);
+                    [nextX, nextY, nextZ] = rotateZ(nextX, nextY, nextZ, angleZ);
+
+                    let nextX2 = (4 + 2 * Math.cos(u)) * Math.cos(v + vStep);
+                    let nextY2 = (4 + 2 * Math.cos(u)) * Math.sin(v + vStep);
+                    let nextZ2 = 2 * Math.sin(u) * Math.cos((v + vStep) / 2);
+
+                    [nextX2, nextY2, nextZ2] = rotateX(nextX2, nextY2, nextZ2, angleX);
+                    [nextX2, nextY2, nextZ2] = rotateY(nextX2, nextY2, nextZ2, angleY);
+                    [nextX2, nextY2, nextZ2] = rotateZ(nextX2, nextY2, nextZ2, angleZ);
+
+                    drawLine(project(x, y, z), project(nextX, nextY, nextZ));
+                    drawLine(project(x, y, z), project(nextX2, nextY2, nextZ2));
+                }
+            }
+        }
+
+        function project(x, y, z) {
+            const perspective = 500 / (500 + z);
+            return [
+                centerX + x * scale * perspective,
+                centerY - y * scale * perspective
+            ];
+        }
+
+        function drawLine(start, end) {
+            ctx.beginPath();
+            ctx.moveTo(start[0], start[1]);
+            ctx.lineTo(end[0], end[1]);
+            ctx.stroke();
+        }
+
+        ctx.clearRect(0, 0, width, height);
+        ctx.strokeStyle = 'black';
+        drawKleinBottle();
+    </script>
+</body>
+</html>
+
diff --git a/klein4.html b/klein4.html
new file mode 100644
index 0000000..7ac464e
--- /dev/null
+++ b/klein4.html
@@ -0,0 +1,115 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Klein Bottle Transformation</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="canvas" width="800" height="800"></canvas>
+    <script>
+        const canvas = document.getElementById('canvas');
+        const ctx = canvas.getContext('2d');
+        const width = canvas.width;
+        const height = canvas.height;
+        const centerX = width / 2;
+        const centerY = height / 2;
+        const scale = 80;
+
+        // Rotation angles
+        const angleX = Math.PI / 6; // Rotate around the X-axis
+        const angleY = Math.PI / 6; // Rotate around the Y-axis
+        const angleZ = Math.PI / 6; // Rotate around the Z-axis
+
+        function rotateX(x, y, z, angle) {
+            const cos = Math.cos(angle);
+            const sin = Math.sin(angle);
+            return [x, y * cos - z * sin, y * sin + z * cos];
+        }
+
+        function rotateY(x, y, z, angle) {
+            const cos = Math.cos(angle);
+            const sin = Math.sin(angle);
+            return [x * cos + z * sin, y, -x * sin + z * cos];
+        }
+
+        function rotateZ(x, y, z, angle) {
+            const cos = Math.cos(angle);
+            const sin = Math.sin(angle);
+            return [x * cos - y * sin, x * sin + y * cos, z];
+        }
+
+        function drawKleinBottle() {
+            const uStep = Math.PI / 18;
+            const vStep = 2 * Math.PI / 36;
+
+            for (let u = 0; u < 2 * Math.PI; u += uStep) {
+                for (let v = 0; v < 2 * Math.PI; v += vStep) {
+                    const [x, y, z] = torusToKleinBottle(u, v);
+                    const [nextX, nextY, nextZ] = torusToKleinBottle(u + uStep, v);
+                    const [nextX2, nextY2, nextZ2] = torusToKleinBottle(u, v + vStep);
+
+                    drawLine(project(x, y, z), project(nextX, nextY, nextZ));
+                    drawLine(project(x, y, z), project(nextX2, nextY2, nextZ2));
+                }
+            }
+        }
+
+        function torusToKleinBottle(u, v) {
+            const R = 4; // Major radius
+            const r = 2; // Minor radius
+
+            // Parametric equations for a torus
+            let x = (R + r * Math.cos(v)) * Math.cos(u);
+            let y = (R + r * Math.cos(v)) * Math.sin(u);
+            let z = r * Math.sin(v);
+
+            // Transformation to create a Klein bottle
+            if (u > Math.PI) {
+                x = (R + r * Math.cos(v)) * Math.cos(u);
+                y = (R + r * Math.cos(v)) * Math.sin(u);
+                z = r * Math.sin(v);
+            }
+
+            [x, y, z] = rotateX(x, y, z, angleX);
+            [x, y, z] = rotateY(x, y, z, angleY);
+            [x, y, z] = rotateZ(x, y, z, angleZ);
+
+            return [x, y, z];
+        }
+
+        function project(x, y, z) {
+            const perspective = 500 / (500 + z);
+            return [
+                centerX + x * scale * perspective,
+                centerY - y * scale * perspective
+            ];
+        }
+
+        function drawLine(start, end) {
+            ctx.beginPath();
+            ctx.moveTo(start[0], start[1]);
+            ctx.lineTo(end[0], end[1]);
+            ctx.stroke();
+        }
+
+        ctx.clearRect(0, 0, width, height);
+        ctx.strokeStyle = 'black';
+        drawKleinBottle();
+    </script>
+</body>
+</html>
+
diff --git a/klein5.html b/klein5.html
new file mode 100644
index 0000000..7ac464e
--- /dev/null
+++ b/klein5.html
@@ -0,0 +1,115 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Klein Bottle Transformation</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="canvas" width="800" height="800"></canvas>
+    <script>
+        const canvas = document.getElementById('canvas');
+        const ctx = canvas.getContext('2d');
+        const width = canvas.width;
+        const height = canvas.height;
+        const centerX = width / 2;
+        const centerY = height / 2;
+        const scale = 80;
+
+        // Rotation angles
+        const angleX = Math.PI / 6; // Rotate around the X-axis
+        const angleY = Math.PI / 6; // Rotate around the Y-axis
+        const angleZ = Math.PI / 6; // Rotate around the Z-axis
+
+        function rotateX(x, y, z, angle) {
+            const cos = Math.cos(angle);
+            const sin = Math.sin(angle);
+            return [x, y * cos - z * sin, y * sin + z * cos];
+        }
+
+        function rotateY(x, y, z, angle) {
+            const cos = Math.cos(angle);
+            const sin = Math.sin(angle);
+            return [x * cos + z * sin, y, -x * sin + z * cos];
+        }
+
+        function rotateZ(x, y, z, angle) {
+            const cos = Math.cos(angle);
+            const sin = Math.sin(angle);
+            return [x * cos - y * sin, x * sin + y * cos, z];
+        }
+
+        function drawKleinBottle() {
+            const uStep = Math.PI / 18;
+            const vStep = 2 * Math.PI / 36;
+
+            for (let u = 0; u < 2 * Math.PI; u += uStep) {
+                for (let v = 0; v < 2 * Math.PI; v += vStep) {
+                    const [x, y, z] = torusToKleinBottle(u, v);
+                    const [nextX, nextY, nextZ] = torusToKleinBottle(u + uStep, v);
+                    const [nextX2, nextY2, nextZ2] = torusToKleinBottle(u, v + vStep);
+
+                    drawLine(project(x, y, z), project(nextX, nextY, nextZ));
+                    drawLine(project(x, y, z), project(nextX2, nextY2, nextZ2));
+                }
+            }
+        }
+
+        function torusToKleinBottle(u, v) {
+            const R = 4; // Major radius
+            const r = 2; // Minor radius
+
+            // Parametric equations for a torus
+            let x = (R + r * Math.cos(v)) * Math.cos(u);
+            let y = (R + r * Math.cos(v)) * Math.sin(u);
+            let z = r * Math.sin(v);
+
+            // Transformation to create a Klein bottle
+            if (u > Math.PI) {
+                x = (R + r * Math.cos(v)) * Math.cos(u);
+                y = (R + r * Math.cos(v)) * Math.sin(u);
+                z = r * Math.sin(v);
+            }
+
+            [x, y, z] = rotateX(x, y, z, angleX);
+            [x, y, z] = rotateY(x, y, z, angleY);
+            [x, y, z] = rotateZ(x, y, z, angleZ);
+
+            return [x, y, z];
+        }
+
+        function project(x, y, z) {
+            const perspective = 500 / (500 + z);
+            return [
+                centerX + x * scale * perspective,
+                centerY - y * scale * perspective
+            ];
+        }
+
+        function drawLine(start, end) {
+            ctx.beginPath();
+            ctx.moveTo(start[0], start[1]);
+            ctx.lineTo(end[0], end[1]);
+            ctx.stroke();
+        }
+
+        ctx.clearRect(0, 0, width, height);
+        ctx.strokeStyle = 'black';
+        drawKleinBottle();
+    </script>
+</body>
+</html>
+
diff --git a/klein6.html b/klein6.html
new file mode 100644
index 0000000..3b110b0
--- /dev/null
+++ b/klein6.html
@@ -0,0 +1,84 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Klein Bottle Wireframe</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="canvas" width="800" height="800"></canvas>
+    <script>
+        const canvas = document.getElementById('canvas');
+        const ctx = canvas.getContext('2d');
+        const width = canvas.width;
+        const height = canvas.height;
+        const centerX = width / 2;
+        const centerY = height / 2;
+        const scale = 50;
+
+        function drawKleinBottle() {
+            const uStep = Math.PI / 18;
+            const vStep = 2 * Math.PI / 36;
+
+            for (let u = 0; u < 2 * Math.PI; u += uStep) {
+                for (let v = 0; v < 2 * Math.PI; v += vStep) {
+                    const [x, y, z] = kleinCoordinates(u, v);
+                    const [nextX, nextY, nextZ] = kleinCoordinates(u + uStep, v);
+                    const [nextX2, nextY2, nextZ2] = kleinCoordinates(u, v + vStep);
+
+                    drawLine(project(x, y, z), project(nextX, nextY, nextZ));
+                    drawLine(project(x, y, z), project(nextX2, nextY2, nextZ2));
+                }
+            }
+        }
+
+        function kleinCoordinates(u, v) {
+            let x, y, z;
+            if (u < Math.PI) {
+                x = 3 * Math.cos(u) * (1 + Math.sin(u)) + 2 * (1 - Math.cos(u) / 2) * Math.cos(v);
+                y = 8 * Math.sin(u) + 2 * (1 - Math.cos(u) / 2) * Math.sin(v);
+                z = 2 * (1 - Math.cos(u) / 2) * Math.sin(v);
+            } else {
+                x = 3 * Math.cos(u) * (1 + Math.sin(u)) + 2 * (1 - Math.cos(u) / 2) * Math.cos(v + Math.PI);
+                y = 8 * Math.sin(u);
+                z = 2 * (1 - Math.cos(u) / 2) * Math.sin(v + Math.PI);
+            }
+            return [x, y, z];
+        }
+
+        function project(x, y, z) {
+            const perspective = 500 / (500 + z);
+            return [
+                centerX + x * scale * perspective,
+                centerY - y * scale * perspective
+            ];
+        }
+
+        function drawLine(start, end) {
+            ctx.beginPath();
+            ctx.moveTo(start[0], start[1]);
+            ctx.lineTo(end[0], end[1]);
+            ctx.stroke();
+        }
+
+        ctx.clearRect(0, 0, width, height);
+        ctx.strokeStyle = 'black';
+        drawKleinBottle();
+    </script>
+</body>
+</html>
+
diff --git a/klein7.html b/klein7.html
new file mode 100644
index 0000000..5663326
--- /dev/null
+++ b/klein7.html
@@ -0,0 +1,78 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Klein Bottle Wireframe</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="canvas" width="800" height="800"></canvas>
+    <script>
+        const canvas = document.getElementById('canvas');
+        const ctx = canvas.getContext('2d');
+        const width = canvas.width;
+        const height = canvas.height;
+        const centerX = width / 2;
+        const centerY = height / 2;
+        const scale = 50;
+
+        function drawKleinBottle() {
+            const uStep = Math.PI / 18;
+            const vStep = 2 * Math.PI / 36;
+
+            for (let u = 0; u < 2 * Math.PI; u += uStep) {
+                for (let v = 0; v < 2 * Math.PI; v += vStep) {
+                    const [x, y, z] = kleinCoordinates(u, v);
+                    const [nextX, nextY, nextZ] = kleinCoordinates(u + uStep, v);
+                    const [nextX2, nextY2, nextZ2] = kleinCoordinates(u, v + vStep);
+
+                    drawLine(project(x, y, z), project(nextX, nextY, nextZ));
+                    drawLine(project(x, y, z), project(nextX2, nextY2, nextZ2));
+                }
+            }
+        }
+
+        function kleinCoordinates(u, v) {
+            let x, y, z;
+                x = (1 + Math.cos(u/2) * Math.sin(v) - Math.sin(u/2) * Math.sin(2*v))*Math.cos(u);
+                y = (1 + Math.cos(u/2) * Math.sin(v) - Math.sin(u/2) * Math.sin(2*v))*Math.sin(u);
+                z = Math.sin(u/2) * Math.sin(v) + Math.cos(u/2) * Math.sin(2*v);
+            return [x, y, z];
+        }
+
+        function project(x, y, z) {
+            const perspective = 500 / (200 + z);
+            return [
+                centerX + x * scale * perspective,
+                centerY - y * scale * perspective
+            ];
+        }
+
+        function drawLine(start, end) {
+            ctx.beginPath();
+            ctx.moveTo(start[0], start[1]);
+            ctx.lineTo(end[0], end[1]);
+            ctx.stroke();
+        }
+
+        ctx.clearRect(0, 0, width, height);
+        ctx.strokeStyle = 'black';
+        drawKleinBottle();
+    </script>
+</body>
+</html>
+
diff --git a/line.html b/line.html
new file mode 100644
index 0000000..4b8775e
--- /dev/null
+++ b/line.html
@@ -0,0 +1,47 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+<meta charset="UTF-8">
+<title>Animated Line Drawing</title>
+<style>
+    canvas {
+        border: 1px solid black;
+    }
+</style>
+</head>
+<body>
+
+<canvas id="myCanvas" width="480" height="320"></canvas>
+
+<script>
+    var canvas = document.getElementById('myCanvas');
+    var ctx = canvas.getContext('2d');
+
+    var startX = 0;
+    var startY = 160;
+    var endX = 0;
+    var endY = 160;
+    var speed = 2;
+
+    function drawLine() {
+        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
+
+        ctx.beginPath();
+        ctx.moveTo(startX, startY);
+        ctx.lineTo(endX, endY);
+        ctx.stroke();
+
+        endX += speed; // Update the end X position for animation
+
+        if (endX < canvas.width) {
+            window.requestAnimationFrame(drawLine); // Recursively call drawLine to animate
+        }
+    }
+
+    drawLine(); // Initial call to start the animation
+</script>
+
+</body>
+</html>
+
diff --git a/line_drawing.html b/line_drawing.html
new file mode 100644
index 0000000..4c49352
--- /dev/null
+++ b/line_drawing.html
@@ -0,0 +1,57 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Geometric Line Drawing</title>
+    <style>
+        body {
+            margin: 0;
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            background-color: black;
+        }
+        canvas {
+            display: block;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="lineCanvas"></canvas>
+    <script>
+        const canvas = document.getElementById('lineCanvas');
+        const ctx = canvas.getContext('2d');
+        canvas.width = window.innerWidth;
+        canvas.height = window.innerHeight;
+
+        function drawLines() {
+            ctx.clearRect(0, 0, canvas.width, canvas.height);
+            const numLines = 50;
+            const spacing = canvas.width / numLines;
+            const colors = ['#FF4500', '#FF6347', '#FF7F50', '#FFA07A'];
+
+            for (let i = 0; i < numLines; i++) {
+                const color = colors[i % colors.length];
+                ctx.strokeStyle = color;
+                ctx.beginPath();
+                ctx.moveTo(i * spacing, 0);
+                ctx.lineTo(canvas.width / 2, canvas.height / 2);
+                ctx.lineTo(canvas.width - i * spacing, canvas.height);
+                ctx.stroke();
+            }
+        }
+
+        drawLines();
+
+        window.addEventListener('resize', () => {
+            canvas.width = window.innerWidth;
+            canvas.height = window.innerHeight;
+            drawLines();
+        });
+    </script>
+</body>
+</html>
+
diff --git a/main.js b/main.js
new file mode 100644
index 0000000..9978fba
--- /dev/null
+++ b/main.js
@@ -0,0 +1,144 @@
+// Get canvas element and create a WebGL rendering context
+const canvas = document.getElementById("glCanvas");
+const gl = canvas.getContext("webgl");
+
+// Check if WebGL is supported
+if (!gl) {
+    alert("WebGL isn't supported in this browser.");
+}
+
+// Vertex shader program
+const vsSource = `
+    attribute vec4 aVertexPosition;
+    void main(void) {
+        gl_Position = aVertexPosition;
+    }
+`;
+
+// Fragment shader program
+const fsSource = `
+    void main(void) {
+        gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
+    }
+`;
+
+// Initialize a shader program, so WebGL knows how to draw our data
+const shaderProgram = initShaderProgram(gl, vsSource, fsSource);
+
+// Collect all the info needed to use the shader program.
+const programInfo = {
+    program: shaderProgram,
+    attribLocations: {
+        vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
+    },
+};
+
+// Here's where we call the routine that builds all the objects we'll be drawing.
+const buffers = initBuffers(gl);
+
+// Draw the scene
+drawScene(gl, programInfo, buffers);
+
+// Initialize the buffers we'll need. For this demo, we just have one object -- a simple triangle.
+function initBuffers(gl) {
+    // Create a buffer for the triangle's positions.
+    const positionBuffer = gl.createBuffer();
+
+    // Select the positionBuffer as the one to apply buffer operations to from here out.
+    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
+
+    // Create an array of positions for the triangle.
+    const positions = [
+        0.0,  1.0,
+       -1.0, -1.0,
+        1.0, -1.0,
+    ];
+
+    // Pass the list of positions into WebGL to build the shape. We do this by creating a Float32Array from the JavaScript array, then use it to fill the current buffer.
+    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
+
+    return {
+        position: positionBuffer,
+    };
+}
+
+function initShaderProgram(gl, vsSource, fsSource) {
+    const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
+    const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
+
+    // Create the shader program
+    const shaderProgram = gl.createProgram();
+    gl.attachShader(shaderProgram, vertexShader);
+    gl.attachShader(shaderProgram, fragmentShader);
+    gl.linkProgram(shaderProgram);
+
+    // If creating the shader program failed, alert
+    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
+        alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
+        return null;
+    }
+
+    return shaderProgram;
+}
+
+function loadShader(gl, type, source) {
+    const shader = gl.createShader(type);
+
+    // Send the source to the shader object
+    gl.shaderSource(shader, source);
+
+    // Compile the shader program
+    gl.compileShader(shader);
+
+    // See if it compiled successfully
+    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
+        alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
+        gl.deleteShader(shader);
+        return null;
+    }
+
+    return shader;
+}
+
+function drawScene(gl, programInfo, buffers) {
+    // Clear the canvas before we start drawing on it.
+    gl.clearColor(0.0, 0.0, 0.0, 1.0);  // Clear to black, fully opaque
+    gl.clearDepth(1.0);                 // Clear everything
+    gl.enable(gl.DEPTH_TEST);           // Enable depth testing
+    gl.depthFunc(gl.LEQUAL);            // Near things obscure far things
+
+    // Clear the canvas before we start drawing on it.
+    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
+
+    // Tell WebGL how to pull out the positions from the position buffer into the vertexPosition attribute.
+    {
+        const numComponents = 2;  // pull out 2 values per iteration
+        const type = gl.FLOAT;    // the data in the buffer is 32bit floats
+        const normalize = false;  // don't normalize
+        const stride = 0;         // how many bytes to get from one set of values to the next
+                                   // 0 = use type and numComponents above
+        const offset = 0;         // how many bytes inside the buffer to start from
+        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
+        gl.vertexAttribPointer(
+            programInfo.attribLocations.vertexPosition,
+            numComponents,
+            type,
+            normalize,
+            stride,
+            offset);
+        gl.enableVertexAttribArray(
+            programInfo.attribLocations.vertexPosition);
+    }
+
+    // Tell WebGL to use our program when drawing
+    gl.useProgram(programInfo.program);
+
+    // Set the shader uniforms
+
+    {
+        const offset = 0;
+        const vertexCount = 3;
+        gl.drawArrays(gl.TRIANGLES, offset, vertexCount);
+    }
+}
+
diff --git a/mobius.html b/mobius.html
new file mode 100644
index 0000000..74a806c
--- /dev/null
+++ b/mobius.html
@@ -0,0 +1,76 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Mbius Strip Wireframe</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="canvas" width="800" height="800"></canvas>
+    <script>
+        const canvas = document.getElementById('canvas');
+        const ctx = canvas.getContext('2d');
+        const width = canvas.width;
+        const height = canvas.height;
+        const centerX = width / 2;
+        const centerY = height / 2;
+        const scale = 150;
+
+        function drawMobiusStrip() {
+            const uStep = Math.PI / 36; // u step
+            const vStep = 0.1; // v step
+
+            for (let u = 0; u < 2 * Math.PI; u += uStep) {
+                for (let v = -0.5; v <= 0.5; v += vStep) {
+                    const [x, y, z] = mobiusCoordinates(u, v);
+                    const [nextX, nextY, nextZ] = mobiusCoordinates(u + uStep, v);
+                    const [nextX2, nextY2, nextZ2] = mobiusCoordinates(u, v + vStep);
+
+                    drawLine(project(x, y, z), project(nextX, nextY, nextZ));
+                    drawLine(project(x, y, z), project(nextX2, nextY2, nextZ2));
+                }
+            }
+        }
+
+        function mobiusCoordinates(u, v) {
+            const x = Math.cos(u) * (1 + v * Math.cos(u / 2));
+            const y = Math.sin(u) * (1 + v * Math.cos(u / 2));
+            const z = v * Math.sin(u / 2);
+            return [x, y, z];
+        }
+
+        function project(x, y, z) {
+            const perspective = 500 / (500 + z);
+            return [
+                centerX + x * scale * perspective,
+                centerY - y * scale * perspective
+            ];
+        }
+
+        function drawLine(start, end) {
+            ctx.beginPath();
+            ctx.moveTo(start[0], start[1]);
+            ctx.lineTo(end[0], end[1]);
+            ctx.stroke();
+        }
+
+        ctx.clearRect(0, 0, width, height);
+        ctx.strokeStyle = 'black';
+        drawMobiusStrip();
+    </script>
+</body>
+</html>
+
diff --git a/moving_square.html b/moving_square.html
new file mode 100644
index 0000000..5bdb27d
--- /dev/null
+++ b/moving_square.html
@@ -0,0 +1,47 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+<meta charset="UTF-8">
+<title>Animated Expanding Square</title>
+<style>
+    canvas {
+        border: 1px solid black;
+    }
+</style>
+</head>
+<body>
+
+<canvas id="myCanvas" width="480" height="320"></canvas>
+
+<script>
+    var canvas = document.getElementById('myCanvas');
+    var ctx = canvas.getContext('2d');
+
+    var size = 20; // Initial size of the square
+    var maxSize = 300; // Maximum size of the square
+    var increase = 2; // Amount to increase the size of the square each frame
+
+    function drawSquare() {
+        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
+
+        var x = (canvas.width - size) / 2; // Calculate the x position to keep the square centered
+        var y = (canvas.height - size) / 2; // Calculate the y position to keep the square centered
+
+        ctx.beginPath();
+        ctx.rect(x, y, size, size);
+        ctx.stroke();
+
+        size += increase; // Increase the size for the next frame
+
+        if (size < maxSize) {
+            window.requestAnimationFrame(drawSquare); // Continue the animation if the square is not yet at its max size
+        }
+    }
+
+    drawSquare(); // Initial call to start the animation
+</script>
+
+</body>
+</html>
+
diff --git a/moving_square2.html b/moving_square2.html
new file mode 100644
index 0000000..971c9fc
--- /dev/null
+++ b/moving_square2.html
@@ -0,0 +1,51 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+<meta charset="UTF-8">
+<title>Animated Expanding Square</title>
+<style>
+    canvas {
+        border: 1px solid black;
+    }
+</style>
+</head>
+<body>
+
+<canvas id="myCanvas" width="480" height="320"></canvas>
+
+<script>
+    var canvas = document.getElementById('myCanvas');
+    var ctx = canvas.getContext('2d');
+
+    var size = 20; // Initial size of the square
+    var maxSize = 300; // Maximum size of the square
+    var increase = 2; // Amount to increase the size of the square each frame
+
+    function drawSquare() {
+        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
+
+        var x = (canvas.width - size) / 2; // Calculate the x position to keep the square centered
+        var y = (canvas.height - size) / 2; // Calculate the y position to keep the square centered
+
+        ctx.beginPath();
+        ctx.rect(x, y, size, size);
+        ctx.stroke();
+
+        size += increase; // Increase the size for the next frame
+
+        if (size < maxSize) {
+            window.requestAnimationFrame(drawSquare); // Continue the animation if the square is not yet at its max size
+        }
+	    else {
+		size=0;
+            	window.requestAnimationFrame(drawSquare); // Continue the animation if the square is not yet at its max size
+	   }
+    }
+
+    drawSquare(); // Initial call to start the animation
+</script>
+
+</body>
+</html>
+
diff --git a/moving_square3.html b/moving_square3.html
new file mode 100644
index 0000000..6f9edc0
--- /dev/null
+++ b/moving_square3.html
@@ -0,0 +1,55 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+<meta charset="UTF-8">
+<title>Animated Expanding Square</title>
+<style>
+    canvas {
+        border: 1px solid black;
+    }
+</style>
+</head>
+<body>
+
+<canvas id="myCanvas" width="480" height="320"></canvas>
+
+<script>
+    var canvas = document.getElementById('myCanvas');
+    var ctx = canvas.getContext('2d');
+
+    var size = 20; // Initial size of the square
+    var maxSize = 300; // Maximum size of the square
+    var increase = 10; // Amount to increase the size of the square each frame
+
+    function drawSquare() {
+        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
+
+        var x = (canvas.width - size) / 2; // Calculate the x position to keep the square centered
+        var y = (canvas.height - size) / 2; // Calculate the y position to keep the square centered
+
+        ctx.beginPath();
+        ctx.rect(x, y, size, size);
+        ctx.rect(x, y, size+10, size+10);
+        ctx.rect(x, y, size+20, size+20);
+        ctx.rect(x, y, size+30, size+30);
+        ctx.rect(x, y, size+40, size+40);
+        ctx.stroke();
+
+        size += increase; // Increase the size for the next frame
+
+        if (size < maxSize) {
+            window.requestAnimationFrame(drawSquare); // Continue the animation if the square is not yet at its max size
+        }
+	    else {
+		size=0;
+            	window.requestAnimationFrame(drawSquare); // Continue the animation if the square is not yet at its max size
+	   }
+    }
+
+    drawSquare(); // Initial call to start the animation
+</script>
+
+</body>
+</html>
+
diff --git a/moving_square4.html b/moving_square4.html
new file mode 100644
index 0000000..cb12a09
--- /dev/null
+++ b/moving_square4.html
@@ -0,0 +1,55 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+<meta charset="UTF-8">
+<title>Animated Expanding Square</title>
+<style>
+    canvas {
+        border: 1px solid black;
+    }
+</style>
+</head>
+<body>
+
+<canvas id="myCanvas" width="480" height="320"></canvas>
+
+<script>
+    var canvas = document.getElementById('myCanvas');
+    var ctx = canvas.getContext('2d');
+
+    var size = 20; // Initial size of the square
+    var maxSize = 300; // Maximum size of the square
+    var increase = 10; // Amount to increase the size of the square each frame
+
+    function drawSquare() {
+        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
+
+        var x = (canvas.width - size) / 2; // Calculate the x position to keep the square centered
+        var y = (canvas.height - size) / 2; // Calculate the y position to keep the square centered
+
+        ctx.beginPath();
+        ctx.rect(x, y, size, size);
+        ctx.rect(x-10, y-10, size+10, size+10);
+        ctx.rect(x-20, y-20, size+20, size+20);
+        ctx.rect(x-30, y-30, size+30, size+30);
+        ctx.rect(x-40, y-40, size+40, size+40);
+        ctx.stroke();
+
+        size += increase; // Increase the size for the next frame
+
+        if (size < maxSize) {
+            window.requestAnimationFrame(drawSquare); // Continue the animation if the square is not yet at its max size
+        }
+	    else {
+		size=0;
+            	window.requestAnimationFrame(drawSquare); // Continue the animation if the square is not yet at its max size
+	   }
+    }
+
+    drawSquare(); // Initial call to start the animation
+</script>
+
+</body>
+</html>
+
diff --git a/moving_square5.html b/moving_square5.html
new file mode 100644
index 0000000..74d7769
--- /dev/null
+++ b/moving_square5.html
@@ -0,0 +1,55 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+<meta charset="UTF-8">
+<title>Animated Expanding Square</title>
+<style>
+    canvas {
+        border: 1px solid black;
+    }
+</style>
+</head>
+<body>
+
+<canvas id="myCanvas" width="480" height="320"></canvas>
+
+<script>
+    var canvas = document.getElementById('myCanvas');
+    var ctx = canvas.getContext('2d');
+
+    var size = 20; // Initial size of the square
+    var maxSize = 300; // Maximum size of the square
+    var increase = 10; // Amount to increase the size of the square each frame
+
+    function drawSquare() {
+        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
+
+        var x = (canvas.width - size) / 2; // Calculate the x position to keep the square centered
+        var y = (canvas.height - size) / 2; // Calculate the y position to keep the square centered
+
+        ctx.beginPath();
+        ctx.rect(x, y, size, size);
+        ctx.rect(x-5, y-5, size+10, size+10);
+        ctx.rect(x-10, y-10, size+20, size+20);
+        ctx.rect(x-15, y-15, size+30, size+30);
+        ctx.rect(x-20, y-20, size+40, size+40);
+        ctx.stroke();
+
+        size += increase; // Increase the size for the next frame
+
+        if (size < maxSize) {
+            window.requestAnimationFrame(drawSquare); // Continue the animation if the square is not yet at its max size
+        }
+	    else {
+		size=0;
+            	window.requestAnimationFrame(drawSquare); // Continue the animation if the square is not yet at its max size
+	   }
+    }
+
+    drawSquare(); // Initial call to start the animation
+</script>
+
+</body>
+</html>
+
diff --git a/mywebgl.html b/mywebgl.html
new file mode 100644
index 0000000..a57b06d
--- /dev/null
+++ b/mywebgl.html
@@ -0,0 +1,13 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <title>Sector of a Circle</title>
+</head>
+<body>
+    <canvas id="webgl-canvas" width="400" height="400"></canvas>
+    <script src="mywebgl.js"></script>
+</body>
+</html>
+
diff --git a/mywebgl.js b/mywebgl.js
new file mode 100644
index 0000000..d9f62fd
--- /dev/null
+++ b/mywebgl.js
@@ -0,0 +1,135 @@
+// Initialize WebGL context
+const canvas = document.getElementById('webgl-canvas');
+const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
+
+if (!gl) {
+  alert('Your browser does not support WebGL');
+}
+
+let xrot = 0.2, yrot = 0.0, zrot = 0.0;
+let mouseDown = false, fullscreen = false;
+let xdiff = 0.0, ydiff = 0.0;
+
+const PI = 3.141592653;
+const ngon = 30;
+const angle_step = 2 * PI / ngon;
+const r1_step = 0.005;
+const r2_step = 0.001;
+const delta = 0.6;
+const theta1 = 2 * PI / ngon;
+
+const ndisc = 20;
+
+function initGL() {
+  gl.clearColor(0.0, 0.0, 0.0, 1.0);
+  gl.enable(gl.DEPTH_TEST);
+  gl.depthFunc(gl.LEQUAL);
+  gl.clearDepth(1.0);
+}
+
+function drawBilope(uistacks, uislices, radius) {
+  const tstep = Math.PI / uislices;
+  const sstep = Math.PI / uistacks;
+  let cx = 0.1, cy = 0.2, cz = 0.3;
+  
+  gl.polygonMode(gl.FRONT_AND_BACK, gl.LINE);
+  
+  for (let i = 0; i < 2 * uislices; i++) {
+    const t = tstep * i;
+    gl.begin(gl.LINES);
+    
+    for (let j = 0; j < uistacks; j++) {
+      const s = sstep * j;
+      gl.vertex3f(0.0, 0.0, 0.0);
+      gl.vertex3f(radius * Math.cos(2 * t) * Math.cos(t) * Math.cos(s), 
+                  radius * Math.sin(2 * t) * Math.cos(t) * Math.sin(s), 
+                  radius * Math.sin(2 * t) * Math.sin(t));
+      gl.color3f(cx, cy, cz);
+      cx = (cx + 0.1) % 1.0;
+      cy = (cy + 0.1) % 1.0;
+      cz = (cz + 0.1) % 1.0;
+    }
+    gl.end();
+  }
+}
+
+function display() {
+  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
+  gl.loadIdentity();
+  
+  glu.lookAt(0.0, 0.0, 10.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);
+  
+  gl.rotatef(xrot, 1.0, 0.0, 0.0);
+  gl.rotatef(yrot, 0.0, 1.0, 0.0);
+  gl.rotatef(zrot, 0.0, 0.0, 1.0);
+  
+  gl.color3f(0.5, 0.0, 1.0);
+  drawBilope(30, 60, 2.0);
+  
+  gl.flush();
+  gl.swapBuffers();
+}
+
+function resize() {
+  gl.matrixMode(gl.PROJECTION);
+  gl.loadIdentity();
+  gl.viewport(0, 0, canvas.width, canvas.height);
+  glu.perspective(45.0, canvas.width / canvas.height, 1.0, 100.0);
+  gl.matrixMode(gl.MODELVIEW);
+  gl.loadIdentity();
+}
+
+function idle() {
+  if (!mouseDown) {
+    xrot += 0.3;
+    yrot += 0.3;
+    zrot += 1.0;
+  }
+  display();
+}
+
+function keydown(event) {
+  if (event.keyCode === 27) { // Escape key
+    window.close();
+  } else if (event.keyCode === 112) { // F1 key
+    fullscreen = !fullscreen;
+    if (fullscreen) {
+      canvas.requestFullscreen();
+    } else {
+      document.exitFullscreen();
+    }
+  }
+}
+
+function mousedown(event) {
+  mouseDown = true;
+  xdiff = event.clientX - yrot;
+  ydiff = -event.clientY + xrot;
+}
+
+function mouseup() {
+  mouseDown = false;
+}
+
+function mousemove(event) {
+  if (mouseDown) {
+    yrot = event.clientX - xdiff;
+    xrot = event.clientY + ydiff;
+  }
+  display();
+}
+
+function main() {
+  initGL();
+  
+  canvas.addEventListener('mousedown', mousedown, false);
+  canvas.addEventListener('mouseup', mouseup, false);
+  canvas.addEventListener('mousemove', mousemove, false);
+  document.addEventListener('keydown', keydown, false);
+  
+  resize();
+  display();
+}
+
+window.onload = main;
+
diff --git a/not_working.html b/not_working.html
new file mode 100644
index 0000000..00703e1
--- /dev/null
+++ b/not_working.html
@@ -0,0 +1,58 @@
+<!DOCTYPE html>
+<html>
+<body>
+
+<canvas id="illusionCanvas" width="1200" height="1200"></canvas>
+
+<script>
+const canvas = document.getElementById('illusionCanvas');
+const ctx = canvas.getContext('2d');
+
+const centerX = canvas.width / 2;
+const centerY = canvas.height / 2;
+const sector = 30;
+const star_ngon = 5;
+const maxRadius = Math.min(canvas.width, canvas.height) / 2;
+var sub_shift_angle = 0;
+
+	sub_shift_angle += 2*Math.PI/sector/10;
+function draw_main_spoke(cx, cy, sub_shift_angle) {
+        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
+for (let i = 0; i < star_ngon; i++) {
+	let angle = (i / star_ngon) * 2 * Math.PI;
+    let x = centerX + maxRadius * Math.cos(angle+sub_shift_angle);
+    let y = centerY + maxRadius * Math.sin(angle+sub_shift_angle);
+
+    ctx.strokeStyle = (i % 2 === 0) ? 'black' : 'blue';
+    ctx.lineWidth = 2;
+
+    ctx.beginPath();
+    ctx.moveTo(centerX, centerY);
+    ctx.lineTo(x, y);
+    ctx.stroke();
+}
+        window.requestAnimationFrame(draw_main_spoke); // Continue the animation if the square is not yet at its max size
+}
+
+function draw_spoke(myx, myy, radius, mysector) {
+    for (let i = 0; i < mysector; i++) {
+        let angle = (i / mysector) * 2 * Math.PI;
+
+        let x = myx + radius * Math.cos(angle);
+        let y = myy + radius * Math.sin(angle);
+
+        ctx.strokeStyle = (i % 2 === 0) ? 'black' : 'red';
+
+        ctx.beginPath();
+        ctx.moveTo(myx, myy);
+        ctx.lineTo(x, y);
+        ctx.stroke();
+    }
+}
+
+draw_main_spoke();
+</script>
+
+</body>
+</html>
+
diff --git a/o.html b/o.html
new file mode 100644
index 0000000..673538d
--- /dev/null
+++ b/o.html
@@ -0,0 +1,111 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Klein Bottle Line Drawing</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+            background-color: #fff;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="kleinBottleCanvas" width="600" height="600"></canvas>
+    <script>
+        const canvas = document.getElementById('kleinBottleCanvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const scale = 100;
+        const numU = 60;
+        const numV = 60;
+
+        function drawKleinBottle() {
+            ctx.clearRect(0, 0, canvas.width, canvas.height);
+            ctx.strokeStyle = '#000000';
+            ctx.lineWidth = 0.5;
+
+            function kleinBottleX(u, v) {
+                if (u < Math.PI) {
+                    return 3 * Math.cos(u) * (1 + Math.sin(u)) + scale * Math.cos(u) * Math.cos(v);
+                } else {
+                    return 3 * Math.cos(u) * (1 + Math.sin(u)) + scale * Math.cos(v + Math.PI);
+                }
+            }
+
+            function kleinBottleY(u, v) {
+                if (u < Math.PI) {
+                    return 3 * Math.sin(u) * (1 + Math.sin(u)) + scale * Math.sin(u) * Math.cos(v);
+                } else {
+                    return 3 * Math.sin(u) * (1 + Math.sin(u));
+                }
+            }
+
+            function kleinBottleZ(u, v) {
+                if (u < Math.PI) {
+                    return scale * Math.sin(v);
+                } else {
+                    return scale * Math.sin(v + Math.PI);
+                }
+            }
+
+            for (let i = 0; i <= numU; i++) {
+                const u = (i / numU) * 2 * Math.PI;
+                ctx.beginPath();
+                for (let j = 0; j <= numV; j++) {
+                    const v = (j / numV) * 2 * Math.PI;
+                    const x = kleinBottleX(u, v);
+                    const y = kleinBottleY(u, v);
+                    const z = kleinBottleZ(u, v);
+
+                    // Simple 2D projection
+                    const xProj = centerX + x - z * 0.5;
+                    const yProj = centerY + y - z * 0.5;
+
+                    if (j === 0) {
+                        ctx.moveTo(xProj, yProj);
+                    } else {
+                        ctx.lineTo(xProj, yProj);
+                    }
+                }
+                ctx.stroke();
+            }
+
+            for (let j = 0; j <= numV; j++) {
+                const v = (j / numV) * 2 * Math.PI;
+                ctx.beginPath();
+                for (let i = 0; i <= numU; i++) {
+                    const u = (i / numU) * 2 * Math.PI;
+                    const x = kleinBottleX(u, v);
+                    const y = kleinBottleY(u, v);
+                    const z = kleinBottleZ(u, v);
+
+                    // Simple 2D projection
+                    const xProj = centerX + x - z * 0.5;
+                    const yProj = centerY + y - z * 0.5;
+
+                    if (i === 0) {
+                        ctx.moveTo(xProj, yProj);
+                    } else {
+                        ctx.lineTo(xProj, yProj);
+                    }
+                }
+                ctx.stroke();
+            }
+        }
+
+        drawKleinBottle();
+    </script>
+</body>
+</html>
+
diff --git a/quart_motion.html b/quart_motion.html
new file mode 100644
index 0000000..e63c35a
--- /dev/null
+++ b/quart_motion.html
@@ -0,0 +1,73 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Dynamic Complex Line Drawing</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #333;
+        }
+        canvas {
+            border: 1px solid black;
+            background-color: #333;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="complexLineCanvas" width="600" height="600"></canvas>
+    <script>
+        const canvas = document.getElementById('complexLineCanvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const numLines = 360;
+
+        let angleMultiplier1 = 2;
+        let angleMultiplier2 = 4;
+        let radius1 = 100;
+        let radius2 = 400;
+        let radius_multiplier = 10;
+        let angleOffset = 0;
+
+        // Function to draw the complex pattern
+        function drawComplexPattern() {
+            ctx.clearRect(0, 0, canvas.width, canvas.height);
+            ctx.strokeStyle = '#ffffff';
+            ctx.lineWidth = 0.5;
+
+            for (let i = 0; i < numLines; i++) {
+                const angle1 = (i / numLines) * 2 * Math.PI;
+                const angle2 = ((i + 180) / numLines) * 2 * Math.PI;
+                const x1 = centerX + radius_multiplier * radius1 * Math.cos(angleMultiplier1 * (angle1 + angleOffset)) * Math.sin(angle2 + angleOffset);
+                const y1 = centerY + radius_multiplier * radius1 * Math.sin(angleMultiplier2 * (angle1 + angleOffset)) * Math.sin(angle2 + angleOffset);
+                const x2 = centerX + radius2 * Math.cos(angle2 + angleOffset) * Math.sin(angle1 + angleOffset);
+                const y2 = centerY + radius2 * Math.sin(angle2 + angleOffset) * Math.sin(angle1 + angleOffset);
+
+                ctx.beginPath();
+                ctx.moveTo(x1, y1);
+                ctx.lineTo(x2, y2);
+                ctx.stroke();
+            }
+
+            // Update parameters to create animation
+            angleOffset += 0.01;
+            radius_multiplier = 10*Math.sin(angleOffset);
+            angleMultiplier1 = 2 + Math.sin(angleOffset) * 2;
+            angleMultiplier2 = 4 + Math.cos(angleOffset) * 2;
+            radius1 = 100 + Math.sin(3*angleOffset) * 50;
+            radius2 = 400 + Math.cos(angleOffset) * 50;
+
+            requestAnimationFrame(drawComplexPattern);
+        }
+
+        drawComplexPattern();
+    </script>
+</body>
+</html>
+
diff --git a/rotating_sector.html b/rotating_sector.html
new file mode 100644
index 0000000..84cc14b
--- /dev/null
+++ b/rotating_sector.html
@@ -0,0 +1,60 @@
+<!DOCTYPE html>
+<html>
+<body>
+
+<canvas id="illusionCanvas" width="1200" height="1200"></canvas>
+
+<script>
+
+
+
+// Function to draw a sector of a circle and radially cut it into half
+function drawSector(ctx, x, y, radius, startAngle, endAngle, fillColor) {
+    ctx.beginPath(); // Start a new path
+    ctx.moveTo(x, y); // Move to the center of the circle
+    ctx.arc(x, y, radius, startAngle, endAngle); // Draw the outer arc
+    ctx.closePath(); // Create a straight line back to the center of the circle
+    ctx.fillStyle = fillColor; // Set the fill color
+    ctx.fill(); // Fill the sector with color
+    ctx.strokeStyle = 'white'; // Fill the sector with color
+
+    ctx.stroke(); // Draw the line
+}
+
+// Get the canvas element and its context
+const canvas = document.getElementById('illusionCanvas');
+const ctx = canvas.getContext('2d');
+var shift_angle = 0;
+var sub_shift_angle = 2 * Math.PI / 180; // Slow rotation for the pentagon
+
+function draw() {
+
+    shift_angle += sub_shift_angle;
+    ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
+
+    //draw_rotating_spoke(spokeCenterX, spokeCenterY, maxRadius / 5, sub_shift_angle); // Draw each spoke
+// Example usage: Draw a sector of a circle and radially cut it into half
+// Parameters: context, centerX, centerY, radius, startAngle, endAngle, fillColor
+var ngon = 6;
+var mysize = Math.PI * 2/ngon;
+var mysize_diff = mysize/10;
+
+for (let angle = 0.0; angle < 2*Math.PI; angle += mysize) {
+drawSector(ctx, 200, 200, 100, angle+shift_angle, angle+mysize-mysize_diff+shift_angle, 'blue'); // Drawing and cutting a quarter circle sector
+drawSector(ctx, 200, 200, 3*100/4, angle+shift_angle, angle+mysize-mysize_diff+shift_angle, 'white'); // Drawing and cutting a quarter circle sector
+drawSector(ctx, 200, 200, 100/2, angle+shift_angle, angle+mysize-mysize_diff+shift_angle, 'blue'); // Drawing and cutting a quarter circle sector
+drawSector(ctx, 200, 200, 100/4, angle+shift_angle, angle+mysize-mysize_diff+shift_angle, 'white'); // Drawing and cutting a quarter circle sector
+}
+
+    window.requestAnimationFrame(draw); // Continue the animation
+}
+
+
+
+
+draw();
+</script>
+
+</body>
+</html>
+
diff --git a/rotating_spiral.html b/rotating_spiral.html
new file mode 100644
index 0000000..e5fca82
--- /dev/null
+++ b/rotating_spiral.html
@@ -0,0 +1,101 @@
+<!DOCTYPE html>
+<html>
+<body>
+
+<canvas id="illusionCanvas" width="1200" height="1200"></canvas>
+
+<script>
+const canvas = document.getElementById('illusionCanvas');
+const ctx = canvas.getContext('2d');
+
+const centerX = canvas.width / 2;
+const centerY = canvas.height / 2;
+const sector = 30;
+const maxRadius = Math.min(canvas.width, canvas.height) / 2;
+
+var sub_shift_angle = 0;
+
+function multi_spiral() {
+
+	sub_shift_angle += 2*Math.PI/sector/10;
+        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
+	for (let shift_angle = 0; shift_angle < 4*Math.PI; shift_angle += 2*Math.PI/sector) {
+		draw_spiral(centerX, centerY, maxRadius/20, maxRadius/6, sector, shift_angle);
+	}
+        window.requestAnimationFrame(multi_spiral); // Continue the animation if the square is not yet at its max size
+}
+
+function myloop() {
+
+for (let i = 0; i < sector; i++) {
+    let angle = (i / sector) * 2 * Math.PI;
+    let x = centerX + maxRadius * Math.cos(angle);
+    let y = centerY + maxRadius * Math.sin(angle);
+
+    ctx.strokeStyle = (i % 2 === 0) ? 'black' : 'blue';
+    ctx.lineWidth = 2;
+
+    ctx.beginPath();
+    ctx.moveTo(centerX, centerY);
+    ctx.lineTo(x, y);
+    ctx.stroke();
+
+}
+}
+
+function draw_center_spiral(centerx, centery, small_rad, large_rad, mysector) {
+    for (let i = 0; i < mysector; i++) {
+        let angle = (i / mysector) * 2 * Math.PI;
+
+        let x = centerx + (small_rad+large_rad*angle) * Math.cos(angle);
+        let y = centery + (small_rad+large_rad*angle) * Math.sin(angle);
+
+        ctx.strokeStyle = (i % 2 === 0) ? 'black' : 'red';
+
+        ctx.beginPath();
+        ctx.moveTo(centerx, centery);
+        ctx.lineTo(x, y);
+        ctx.stroke();
+    }
+}
+
+function draw_spiral(centerx, centery, small_rad, large_rad, mysector, shift_angle) {
+
+        ctx.strokeStyle = 'black';
+        ctx.beginPath();
+        ctx.moveTo(centerx, centery);
+    for (let i = 0; i < mysector; i++) {
+        let angle = (i / mysector) * 2 * Math.PI;
+
+        let x = centerx + (small_rad+large_rad*angle) * Math.cos(angle+shift_angle+sub_shift_angle);
+        let y = centery + (small_rad+large_rad*angle) * Math.sin(angle+shift_angle+sub_shift_angle);
+
+
+        ctx.lineTo(x, y);
+    }
+        ctx.stroke();
+}
+
+function draw_spoke(myx, myy, radius, mysector) {
+    for (let i = 0; i < mysector; i++) {
+        let angle = (i / mysector) * 2 * Math.PI;
+
+        let x = myx + radius * Math.cos(angle);
+        let y = myy + radius * Math.sin(angle);
+
+        ctx.strokeStyle = (i % 2 === 0) ? 'black' : 'red';
+
+        ctx.beginPath();
+        ctx.moveTo(myx, myy);
+        ctx.lineTo(x, y);
+        ctx.stroke();
+    }
+}
+
+multi_spiral();
+
+</script>
+
+</body>
+</html>
+
diff --git a/rotating_spoke.html b/rotating_spoke.html
new file mode 100644
index 0000000..e4c949f
--- /dev/null
+++ b/rotating_spoke.html
@@ -0,0 +1,57 @@
+<!DOCTYPE html>
+<html>
+<body>
+
+<canvas id="illusionCanvas" width="1200" height="1200"></canvas>
+
+<script>
+const canvas = document.getElementById('illusionCanvas');
+const ctx = canvas.getContext('2d');
+
+const centerX = canvas.width / 2;
+const centerY = canvas.height / 2;
+const sector = 30;
+const maxRadius = Math.min(canvas.width, canvas.height) / 2;
+var sub_shift_angle = 0;
+
+function draw_main_spoke() {
+	sub_shift_angle += 2*Math.PI/sector/10;
+        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
+for (let i = 0; i < sector; i++) {
+    let angle = (i / sector) * 2 * Math.PI;
+    let x = centerX + maxRadius * Math.cos(angle+sub_shift_angle);
+    let y = centerY + maxRadius * Math.sin(angle+sub_shift_angle);
+
+    ctx.strokeStyle = (i % 2 === 0) ? 'black' : 'blue';
+    ctx.lineWidth = 2;
+
+    ctx.beginPath();
+    ctx.moveTo(centerX, centerY);
+    ctx.lineTo(x, y);
+    ctx.stroke();
+}
+        window.requestAnimationFrame(draw_main_spoke); // Continue the animation if the square is not yet at its max size
+}
+
+function draw_spoke(myx, myy, radius, mysector) {
+    for (let i = 0; i < mysector; i++) {
+        let angle = (i / mysector) * 2 * Math.PI;
+
+        let x = myx + radius * Math.cos(angle);
+        let y = myy + radius * Math.sin(angle);
+
+        ctx.strokeStyle = (i % 2 === 0) ? 'black' : 'red';
+
+        ctx.beginPath();
+        ctx.moveTo(myx, myy);
+        ctx.lineTo(x, y);
+        ctx.stroke();
+    }
+}
+
+draw_main_spoke();
+</script>
+
+</body>
+</html>
+
diff --git a/sinsoidal5.html b/sinsoidal5.html
new file mode 100644
index 0000000..b129226
--- /dev/null
+++ b/sinsoidal5.html
@@ -0,0 +1,73 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Sinusoidal Wave Animation</title>
+    <style>
+        body, html {
+            margin: 0;
+            padding: 0;
+            overflow: hidden;
+            background-color: #000;
+        }
+        canvas {
+            display: block;
+            background-color: #111;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="waveCanvas"></canvas>
+
+    <script>
+        const canvas = document.getElementById('waveCanvas');
+        const ctx = canvas.getContext('2d');
+
+        canvas.width = window.innerWidth;
+        canvas.height = window.innerHeight;
+
+        let waveOffset1 = 0;
+        let waveOffset2 = 0;
+        let waveOffset3 = 0;
+        let waveOffset4 = 0;
+        let waveOffset5 = 0;
+
+        function drawWave(frequency, amplitude, offset, speed, color, shift) {
+            ctx.beginPath();
+            ctx.moveTo(0, canvas.height / 2);
+
+            for (let x = 0; x < canvas.width; x++) {
+                let y = amplitude * Math.sin((x + offset + shift) * frequency) + (canvas.height / 2);
+                ctx.lineTo(x, y);
+            }
+
+            ctx.strokeStyle = color;
+            ctx.stroke();
+        }
+
+        function animate() {
+            ctx.clearRect(0, 0, canvas.width, canvas.height);
+
+            // Draw 5 different waves with different frequencies, amplitudes, speeds, and colors
+            drawWave(0.01, 50, waveOffset1, 0.5, 'rgba(255, 255, 255, 0.5)', 0);
+            drawWave(0.02, 40, waveOffset2, 1, 'rgba(0, 255, 0, 0.5)', 100);
+            drawWave(0.03, 30, waveOffset3, 1.5, 'rgba(0, 0, 255, 0.5)', 200);
+            drawWave(0.04, 20, waveOffset4, 2, 'rgba(255, 0, 255, 0.5)', 300);
+            drawWave(0.05, 10, waveOffset5, 2.5, 'rgba(255, 255, 0, 0.5)', 400);
+
+            // Increment the offsets at different speeds
+            waveOffset1 += 0.5; 
+            waveOffset2 += 1; 
+            waveOffset3 += 1.5; 
+            waveOffset4 += 2; 
+            waveOffset5 += 2.5;
+
+            requestAnimationFrame(animate);
+        }
+
+        animate();
+    </script>
+</body>
+</html>
+
diff --git a/sinusoidal.html b/sinusoidal.html
new file mode 100644
index 0000000..6d10017
--- /dev/null
+++ b/sinusoidal.html
@@ -0,0 +1,62 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Sinusoidal Wave Animation</title>
+    <style>
+        body, html {
+            margin: 0;
+            padding: 0;
+            overflow: hidden;
+            background-color: #000;
+        }
+        canvas {
+            display: block;
+            background-color: #111;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="waveCanvas"></canvas>
+
+    <script>
+        const canvas = document.getElementById('waveCanvas');
+        const ctx = canvas.getContext('2d');
+
+        canvas.width = window.innerWidth;
+        canvas.height = window.innerHeight;
+
+        let waveOffset = 0;
+
+        function drawWave(frequency, amplitude, speed, color, shift) {
+            ctx.beginPath();
+            ctx.moveTo(0, canvas.height / 2);
+
+            for (let x = 0; x < canvas.width; x++) {
+                let y = amplitude * Math.sin((x + waveOffset + shift) * frequency) + (canvas.height / 2);
+                ctx.lineTo(x, y);
+            }
+
+            ctx.strokeStyle = color;
+            ctx.stroke();
+        }
+
+        function animate() {
+            ctx.clearRect(0, 0, canvas.width, canvas.height);
+
+            // Draw multiple waves with different frequencies, amplitudes, and colors
+            drawWave(0.01, 50, 0.5, 'rgba(255, 255, 255, 0.5)', 0); // base wave
+            drawWave(0.02, 30, 1, 'rgba(0, 255, 0, 0.5)', 100); // secondary wave
+            drawWave(0.03, 20, 1.5, 'rgba(0, 0, 255, 0.5)', 200); // tertiary wave
+
+            waveOffset += 2; // Increase to make the wave move faster
+
+            requestAnimationFrame(animate);
+        }
+
+        animate();
+    </script>
+</body>
+</html>
+
diff --git a/solid_torus.html b/solid_torus.html
new file mode 100644
index 0000000..4af7c1d
--- /dev/null
+++ b/solid_torus.html
@@ -0,0 +1,157 @@
+
+
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>3D Shapes with Three.js</title>
+    <style>
+        body { margin: 0; }
+        canvas { display: block; }
+    </style>
+</head>
+<body>
+    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
+    <script>
+        let scene, camera, renderer;
+        let xrot = 0.2, yrot = 0.0, zrot = 0.0;
+        let mouseDown = false;
+        let xdiff = 0.0, ydiff = 0.0;
+        let counter = 0;
+
+        function init() {
+            scene = new THREE.Scene();
+            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 100);
+            camera.position.z = 10;
+
+            renderer = new THREE.WebGLRenderer();
+            renderer.setSize(window.innerWidth, window.innerHeight);
+            document.body.appendChild(renderer.domElement);
+
+            // Wireframe sphere
+            const wireframeSphere = new THREE.Mesh(
+                new THREE.SphereGeometry(2, 10, 10),
+                new THREE.MeshBasicMaterial({ color: 0x800080, wireframe: true })
+            );
+            scene.add(wireframeSphere);
+
+            // Wireframe cube
+            const wireframeCube = new THREE.Mesh(
+                new THREE.BoxGeometry(1, 1, 1),
+                new THREE.MeshBasicMaterial({ color: 0x805050, wireframe: true })
+            );
+            scene.add(wireframeCube);
+
+            // Wireframe torus
+            const wireframeTorus = new THREE.Mesh(
+                new THREE.TorusGeometry(3, 1, 5, 5),
+                new THREE.MeshBasicMaterial({ color: 0x809999, wireframe: true })
+            );
+            scene.add(wireframeTorus);
+
+            // Solid torus
+            const solidTorus = new THREE.Mesh(
+                new THREE.TorusGeometry(4, 2, 6, 18),
+                new THREE.MeshBasicMaterial({ color: 0x80e6ff })
+            );
+            scene.add(solidTorus);
+
+            // Solid shapes
+            const solidDodecahedron = new THREE.Mesh(
+                new THREE.DodecahedronGeometry(),
+                new THREE.MeshBasicMaterial({ color: 0xff0000 })
+            );
+            scene.add(solidDodecahedron);
+
+            const solidOctahedron = new THREE.Mesh(
+                new THREE.OctahedronGeometry(),
+                new THREE.MeshBasicMaterial({ color: 0x00ff00 })
+            );
+            scene.add(solidOctahedron);
+
+            const solidTetrahedron = new THREE.Mesh(
+                new THREE.TetrahedronGeometry(),
+                new THREE.MeshBasicMaterial({ color: 0xffff00 })
+            );
+            scene.add(solidTetrahedron);
+
+            const solidIcosahedron = new THREE.Mesh(
+                new THREE.IcosahedronGeometry(),
+                new THREE.MeshBasicMaterial({ color: 0xff0000 })
+            );
+            scene.add(solidIcosahedron);
+
+            // Conditional teapot shape (approximated with a torus knot for demo)
+            const teapotGeometry = new THREE.TorusKnotGeometry(0.5, 0.2, 100, 16);
+            const teapotMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
+            const solidTeapot = new THREE.Mesh(teapotGeometry, teapotMaterial);
+            scene.add(solidTeapot);
+
+            // Solid cone
+            const solidCone = new THREE.Mesh(
+                new THREE.ConeGeometry(1, 1, 10),
+                new THREE.MeshBasicMaterial({ color: 0x00ff00 })
+            );
+            scene.add(solidCone);
+
+            // Solid cube
+            const solidCube = new THREE.Mesh(
+                new THREE.BoxGeometry(1, 1, 1),
+                new THREE.MeshBasicMaterial({ color: 0xffff00 })
+            );
+            scene.add(solidCube);
+
+            window.addEventListener('resize', onWindowResize, false);
+            document.addEventListener('mousemove', onMouseMove, false);
+            document.addEventListener('mousedown', onMouseDown, false);
+            document.addEventListener('mouseup', onMouseUp, false);
+
+            animate();
+        }
+
+        function animate() {
+            requestAnimationFrame(animate);
+
+            if (!mouseDown) {
+                xrot += 0.3;
+                yrot += 0.3;
+                zrot += 1.0;
+            }
+
+            scene.rotation.x = xrot * Math.PI / 180;
+            scene.rotation.y = yrot * Math.PI / 180;
+            scene.rotation.z = zrot * Math.PI / 180;
+
+            renderer.render(scene, camera);
+        }
+
+        function onWindowResize() {
+            camera.aspect = window.innerWidth / window.innerHeight;
+            camera.updateProjectionMatrix();
+            renderer.setSize(window.innerWidth, window.innerHeight);
+        }
+
+        function onMouseMove(event) {
+            if (mouseDown) {
+                yrot = event.clientX - xdiff;
+                xrot = event.clientY + ydiff;
+            }
+        }
+
+        function onMouseDown(event) {
+            mouseDown = true;
+            xdiff = event.clientX - yrot;
+            ydiff = event.clientY - xrot;
+        }
+
+        function onMouseUp() {
+            mouseDown = false;
+        }
+
+        init();
+    </script>
+</body>
+</html>
+
diff --git a/solid_torus1.html b/solid_torus1.html
new file mode 100644
index 0000000..bec4a9b
--- /dev/null
+++ b/solid_torus1.html
@@ -0,0 +1,156 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>3D Wireframe Shapes with Three.js</title>
+    <style>
+        body { margin: 0; }
+        canvas { display: block; }
+    </style>
+</head>
+<body>
+    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
+    <script>
+        let scene, camera, renderer;
+        let xrot = 0.2, yrot = 0.0, zrot = 0.0;
+        let mouseDown = false;
+        let xdiff = 0.0, ydiff = 0.0;
+        let counter = 0;
+
+        function init() {
+            scene = new THREE.Scene();
+            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 100);
+            camera.position.z = 10;
+
+            renderer = new THREE.WebGLRenderer();
+            renderer.setSize(window.innerWidth, window.innerHeight);
+            document.body.appendChild(renderer.domElement);
+
+            // Wireframe materials
+            const wireframeMaterial = new THREE.MeshBasicMaterial({ color: 0x808080, wireframe: true });
+
+            // Wireframe sphere
+            const wireframeSphere = new THREE.Mesh(
+                new THREE.SphereGeometry(2, 10, 10),
+                wireframeMaterial
+            );
+            scene.add(wireframeSphere);
+
+            // Wireframe cube
+            const wireframeCube = new THREE.Mesh(
+                new THREE.BoxGeometry(1, 1, 1),
+                wireframeMaterial
+            );
+            scene.add(wireframeCube);
+
+            // Wireframe torus
+            const wireframeTorus = new THREE.Mesh(
+                new THREE.TorusGeometry(3, 1, 5, 5),
+                wireframeMaterial
+            );
+            scene.add(wireframeTorus);
+
+            // Solid torus (also wireframe for consistency)
+            const solidTorus = new THREE.Mesh(
+                new THREE.TorusGeometry(4, 2, 6, 18),
+                wireframeMaterial
+            );
+            scene.add(solidTorus);
+
+            // Solid shapes (all wireframe)
+            const solidDodecahedron = new THREE.Mesh(
+                new THREE.DodecahedronGeometry(),
+                wireframeMaterial
+            );
+            scene.add(solidDodecahedron);
+
+            const solidOctahedron = new THREE.Mesh(
+                new THREE.OctahedronGeometry(),
+                wireframeMaterial
+            );
+            scene.add(solidOctahedron);
+
+            const solidTetrahedron = new THREE.Mesh(
+                new THREE.TetrahedronGeometry(),
+                wireframeMaterial
+            );
+            scene.add(solidTetrahedron);
+
+            const solidIcosahedron = new THREE.Mesh(
+                new THREE.IcosahedronGeometry(),
+                wireframeMaterial
+            );
+            scene.add(solidIcosahedron);
+
+            // Conditional teapot shape (approximated with a torus knot for demo)
+            const teapotGeometry = new THREE.TorusKnotGeometry(0.5, 0.2, 100, 16);
+            const solidTeapot = new THREE.Mesh(teapotGeometry, wireframeMaterial);
+            scene.add(solidTeapot);
+
+            // Solid cone
+            const solidCone = new THREE.Mesh(
+                new THREE.ConeGeometry(1, 1, 10),
+                wireframeMaterial
+            );
+            scene.add(solidCone);
+
+            // Solid cube
+            const solidCube = new THREE.Mesh(
+                new THREE.BoxGeometry(1, 1, 1),
+                wireframeMaterial
+            );
+            scene.add(solidCube);
+
+            window.addEventListener('resize', onWindowResize, false);
+            document.addEventListener('mousemove', onMouseMove, false);
+            document.addEventListener('mousedown', onMouseDown, false);
+            document.addEventListener('mouseup', onMouseUp, false);
+
+            animate();
+        }
+
+        function animate() {
+            requestAnimationFrame(animate);
+
+            if (!mouseDown) {
+                xrot += 0.3;
+                yrot += 0.3;
+                zrot += 1.0;
+            }
+
+            scene.rotation.x = xrot * Math.PI / 180;
+            scene.rotation.y = yrot * Math.PI / 180;
+            scene.rotation.z = zrot * Math.PI / 180;
+
+            renderer.render(scene, camera);
+        }
+
+        function onWindowResize() {
+            camera.aspect = window.innerWidth / window.innerHeight;
+            camera.updateProjectionMatrix();
+            renderer.setSize(window.innerWidth, window.innerHeight);
+        }
+
+        function onMouseMove(event) {
+            if (mouseDown) {
+                yrot = event.clientX - xdiff;
+                xrot = event.clientY + ydiff;
+            }
+        }
+
+        function onMouseDown(event) {
+            mouseDown = true;
+            xdiff = event.clientX - yrot;
+            ydiff = event.clientY - xrot;
+        }
+
+        function onMouseUp() {
+            mouseDown = false;
+        }
+
+        init();
+    </script>
+</body>
+</html>
+
diff --git a/special.html b/special.html
new file mode 100644
index 0000000..1ae2119
--- /dev/null
+++ b/special.html
@@ -0,0 +1,99 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>3D Mesh Line Drawing</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+            background-color: #fff;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="meshCanvas" width="600" height="600"></canvas>
+    <script>
+        const canvas = document.getElementById('meshCanvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const scale = 100;
+        const numU = 200;
+        const numV = 100;
+
+        function drawMesh() {
+            ctx.clearRect(0, 0, canvas.width, canvas.height);
+            ctx.strokeStyle = '#FF0000';
+            ctx.lineWidth = 0.5;
+
+            function meshX(u, v) {
+                return Math.cos(2*u) * (3 + Math.cos(v));
+            }
+
+            function meshY(u, v) {
+                return Math.sin(6*u) * (3 + Math.cos(v));
+            }
+
+            function meshZ(u, v) {
+                return Math.sin(v) + Math.sin(u);
+            }
+
+            for (let i = 0; i <= numU; i++) {
+                const u = (i / numU) * 2 * Math.PI;
+                ctx.beginPath();
+                for (let j = 0; j <= numV; j++) {
+                    const v = (j / numV) * 2 * Math.PI;
+                    const x = meshX(u, v);
+                    const y = meshY(u, v);
+                    const z = meshZ(u, v);
+
+                    // Simple 2D projection
+                    const xProj = centerX + x * scale;
+                    const yProj = centerY - y * scale;
+
+                    if (j === 0) {
+                        ctx.moveTo(xProj, yProj);
+                    } else {
+                        ctx.lineTo(xProj, yProj);
+                    }
+                }
+                ctx.stroke();
+            }
+
+            for (let j = 0; j <= numV; j++) {
+                const v = (j / numV) * 2 * Math.PI;
+                ctx.beginPath();
+                for (let i = 0; i <= numU; i++) {
+                    const u = (i / numU) * 2 * Math.PI;
+                    const x = meshX(u, v);
+                    const y = meshY(u, v);
+                    const z = meshZ(u, v);
+
+                    // Simple 2D projection
+                    const xProj = centerX + x * scale;
+                    const yProj = centerY - y * scale;
+
+                    if (i === 0) {
+                        ctx.moveTo(xProj, yProj);
+                    } else {
+                        ctx.lineTo(xProj, yProj);
+                    }
+                }
+                ctx.stroke();
+            }
+        }
+
+        drawMesh();
+    </script>
+</body>
+</html>
+
diff --git a/spherical_sinusoid.html b/spherical_sinusoid.html
new file mode 100644
index 0000000..7d62879
--- /dev/null
+++ b/spherical_sinusoid.html
@@ -0,0 +1,94 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Sinusoidal Waves Around a Sphere with Perspective Control</title>
+    <style>
+        body, html {
+            margin: 0;
+            padding: 0;
+            overflow: hidden;
+            background-color: #000;
+        }
+        canvas {
+            display: block;
+            background-color: #111;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="waveCanvas"></canvas>
+
+    <script>
+        const canvas = document.getElementById('waveCanvas');
+        const ctx = canvas.getContext('2d');
+
+        canvas.width = window.innerWidth;
+        canvas.height = window.innerHeight;
+
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const radius = Math.min(canvas.width, canvas.height) / 3;
+
+        let waveOffset1 = 0;
+        let waveOffset2 = 0;
+        let waveOffset3 = 0;
+        let waveOffset4 = 0;
+        let waveOffset5 = 0;
+
+        let perspectiveAngle = 0; // Angle in radians
+
+        function drawWaveAroundSphere(frequency, amplitude, offset, speed, color, shift) {
+            ctx.beginPath();
+
+            for (let angle = 0; angle <= 360; angle += 1) {
+                let radian = angle * (Math.PI / 180);
+                let x = centerX + radius * Math.cos(radian) * Math.cos(perspectiveAngle);
+                let y = centerY + radius * Math.sin(radian) + amplitude * Math.sin((radian * frequency) + offset + shift);
+                
+                if (angle === 0) {
+                    ctx.moveTo(x, y);
+                } else {
+                    ctx.lineTo(x, y);
+                }
+            }
+
+            ctx.strokeStyle = color;
+            ctx.stroke();
+        }
+
+        function animate() {
+            ctx.clearRect(0, 0, canvas.width, canvas.height);
+
+            // Draw 5 different waves moving around the sphere with perspective
+            drawWaveAroundSphere(3, 20, waveOffset1, 0.5, 'rgba(255, 255, 255, 0.5)', 0);
+            drawWaveAroundSphere(4, 15, waveOffset2, 1, 'rgba(0, 255, 0, 0.5)', 100);
+            drawWaveAroundSphere(5, 10, waveOffset3, 1.5, 'rgba(0, 0, 255, 0.5)', 200);
+            drawWaveAroundSphere(6, 5, waveOffset4, 2, 'rgba(255, 0, 255, 0.5)', 300);
+            drawWaveAroundSphere(7, 3, waveOffset5, 2.5, 'rgba(255, 255, 0, 0.5)', 400);
+
+            // Increment the offsets at different speeds
+            waveOffset1 += 0.05; 
+            waveOffset2 += 0.08; 
+            waveOffset3 += 0.12; 
+            waveOffset4 += 0.15; 
+            waveOffset5 += 0.2;
+
+            requestAnimationFrame(animate);
+        }
+
+        function onMouseMove(event) {
+            const rect = canvas.getBoundingClientRect();
+            const mouseX = event.clientX - rect.left;
+            perspectiveAngle = (mouseX - centerX) / canvas.width * Math.PI * 2;
+        }
+
+        // Event listener to change perspective based on mouse movement
+        canvas.addEventListener('mousemove', onMouseMove);
+
+        animate();
+    </script>
+</body>
+</html>
+
diff --git a/spherical_sinusoid1.html b/spherical_sinusoid1.html
new file mode 100644
index 0000000..7d62879
--- /dev/null
+++ b/spherical_sinusoid1.html
@@ -0,0 +1,94 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Sinusoidal Waves Around a Sphere with Perspective Control</title>
+    <style>
+        body, html {
+            margin: 0;
+            padding: 0;
+            overflow: hidden;
+            background-color: #000;
+        }
+        canvas {
+            display: block;
+            background-color: #111;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="waveCanvas"></canvas>
+
+    <script>
+        const canvas = document.getElementById('waveCanvas');
+        const ctx = canvas.getContext('2d');
+
+        canvas.width = window.innerWidth;
+        canvas.height = window.innerHeight;
+
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const radius = Math.min(canvas.width, canvas.height) / 3;
+
+        let waveOffset1 = 0;
+        let waveOffset2 = 0;
+        let waveOffset3 = 0;
+        let waveOffset4 = 0;
+        let waveOffset5 = 0;
+
+        let perspectiveAngle = 0; // Angle in radians
+
+        function drawWaveAroundSphere(frequency, amplitude, offset, speed, color, shift) {
+            ctx.beginPath();
+
+            for (let angle = 0; angle <= 360; angle += 1) {
+                let radian = angle * (Math.PI / 180);
+                let x = centerX + radius * Math.cos(radian) * Math.cos(perspectiveAngle);
+                let y = centerY + radius * Math.sin(radian) + amplitude * Math.sin((radian * frequency) + offset + shift);
+                
+                if (angle === 0) {
+                    ctx.moveTo(x, y);
+                } else {
+                    ctx.lineTo(x, y);
+                }
+            }
+
+            ctx.strokeStyle = color;
+            ctx.stroke();
+        }
+
+        function animate() {
+            ctx.clearRect(0, 0, canvas.width, canvas.height);
+
+            // Draw 5 different waves moving around the sphere with perspective
+            drawWaveAroundSphere(3, 20, waveOffset1, 0.5, 'rgba(255, 255, 255, 0.5)', 0);
+            drawWaveAroundSphere(4, 15, waveOffset2, 1, 'rgba(0, 255, 0, 0.5)', 100);
+            drawWaveAroundSphere(5, 10, waveOffset3, 1.5, 'rgba(0, 0, 255, 0.5)', 200);
+            drawWaveAroundSphere(6, 5, waveOffset4, 2, 'rgba(255, 0, 255, 0.5)', 300);
+            drawWaveAroundSphere(7, 3, waveOffset5, 2.5, 'rgba(255, 255, 0, 0.5)', 400);
+
+            // Increment the offsets at different speeds
+            waveOffset1 += 0.05; 
+            waveOffset2 += 0.08; 
+            waveOffset3 += 0.12; 
+            waveOffset4 += 0.15; 
+            waveOffset5 += 0.2;
+
+            requestAnimationFrame(animate);
+        }
+
+        function onMouseMove(event) {
+            const rect = canvas.getBoundingClientRect();
+            const mouseX = event.clientX - rect.left;
+            perspectiveAngle = (mouseX - centerX) / canvas.width * Math.PI * 2;
+        }
+
+        // Event listener to change perspective based on mouse movement
+        canvas.addEventListener('mousemove', onMouseMove);
+
+        animate();
+    </script>
+</body>
+</html>
+
diff --git a/spherical_sinusoid2.html b/spherical_sinusoid2.html
new file mode 100644
index 0000000..4a1f7d8
--- /dev/null
+++ b/spherical_sinusoid2.html
@@ -0,0 +1,39 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Sinusoidal Waves Around a Sphere (Side View)</title>
+    <style>
+        body, html {
+            margin: 0;
+            padding: 0;
+            overflow: hidden;
+            background-color: #000;
+        }
+        canvas {
+            display: block;
+            background-color: #111;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="waveCanvas"></canvas>
+
+    <script>
+        const canvas = document.getElementById('waveCanvas');
+        const ctx = canvas.getContext('2d');
+
+        canvas.width = window.innerWidth;
+        canvas.height = window.innerHeight;
+
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const radius = Math.min(canvas.width, canvas.height) / 3;
+
+        let waveOffset1 = 0;
+        let waveOffset2 = 0;
+        let waveOffset3 = 0;
+        let waveOffset4 = 0;
+        let waveOffset5 =
+
diff --git a/spherical_sinusoid3.html b/spherical_sinusoid3.html
new file mode 100644
index 0000000..201344f
--- /dev/null
+++ b/spherical_sinusoid3.html
@@ -0,0 +1,94 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Sinusoidal Waves Around a Sphere (Side View)</title>
+    <style>
+        body, html {
+            margin: 0;
+            padding: 0;
+            overflow: hidden;
+            background-color: #000;
+        }
+        canvas {
+            display: block;
+            background-color: #111;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="waveCanvas"></canvas>
+
+    <script>
+        const canvas = document.getElementById('waveCanvas');
+        const ctx = canvas.getContext('2d');
+
+        canvas.width = window.innerWidth;
+        canvas.height = window.innerHeight;
+
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const radius = Math.min(canvas.width, canvas.height) / 3;
+
+        let waveOffset1 = 0;
+        let waveOffset2 = 0;
+        let waveOffset3 = 0;
+        let waveOffset4 = 0;
+        let waveOffset5 = 0;
+
+        let perspectiveAngle = 0; // Angle in radians
+
+        function drawWaveAroundSphere(frequency, amplitude, offset, speed, color, shift) {
+            ctx.beginPath();
+
+            for (let angle = 0; angle <= 360; angle += 1) {
+                let radian = angle * (Math.PI / 180);
+                let x = centerX + radius * Math.cos(radian + perspectiveAngle);
+                let y = centerY + amplitude * Math.sin((radian * frequency) + offset + shift) * Math.cos(radian);
+                
+                if (angle === 0) {
+                    ctx.moveTo(x, y);
+                } else {
+                    ctx.lineTo(x, y);
+                }
+            }
+
+            ctx.strokeStyle = color;
+            ctx.stroke();
+        }
+
+        function animate() {
+            ctx.clearRect(0, 0, canvas.width, canvas.height);
+
+            // Draw 5 different waves moving around the sphere with perspective
+            drawWaveAroundSphere(3, 20, waveOffset1, 0.5, 'rgba(255, 255, 255, 0.5)', 0);
+            drawWaveAroundSphere(4, 15, waveOffset2, 1, 'rgba(0, 255, 0, 0.5)', 100);
+            drawWaveAroundSphere(5, 10, waveOffset3, 1.5, 'rgba(0, 0, 255, 0.5)', 200);
+            drawWaveAroundSphere(6, 5, waveOffset4, 2, 'rgba(255, 0, 255, 0.5)', 300);
+            drawWaveAroundSphere(7, 3, waveOffset5, 2.5, 'rgba(255, 255, 0, 0.5)', 400);
+
+            // Increment the offsets at different speeds
+            waveOffset1 += 0.05; 
+            waveOffset2 += 0.08; 
+            waveOffset3 += 0.12; 
+            waveOffset4 += 0.15; 
+            waveOffset5 += 0.2;
+
+            requestAnimationFrame(animate);
+        }
+
+        function onMouseMove(event) {
+            const rect = canvas.getBoundingClientRect();
+            const mouseX = event.clientX - rect.left;
+            perspectiveAngle = (mouseX - centerX) / canvas.width * Math.PI * 2;
+        }
+
+        // Event listener to change perspective based on mouse movement
+        canvas.addEventListener('mousemove', onMouseMove);
+
+        animate();
+    </script>
+</body>
+</html>
+
diff --git a/spiral.html b/spiral.html
new file mode 100644
index 0000000..75e17e5
--- /dev/null
+++ b/spiral.html
@@ -0,0 +1,92 @@
+<!DOCTYPE html>
+<html>
+<body>
+
+<canvas id="illusionCanvas" width="1200" height="1200"></canvas>
+
+<script>
+const canvas = document.getElementById('illusionCanvas');
+const ctx = canvas.getContext('2d');
+
+const centerX = canvas.width / 2;
+const centerY = canvas.height / 2;
+const sector = 30;
+const maxRadius = Math.min(canvas.width, canvas.height) / 2;
+
+
+for (let shift_angle = 0; shift_angle < 4*Math.PI; shift_angle += 2*Math.PI/sector) {
+	draw_spiral(centerX, centerY, maxRadius/20, maxRadius/6, sector, shift_angle);
+}
+
+function myloop() {
+
+for (let i = 0; i < sector; i++) {
+    let angle = (i / sector) * 2 * Math.PI;
+    let x = centerX + maxRadius * Math.cos(angle);
+    let y = centerY + maxRadius * Math.sin(angle);
+
+    ctx.strokeStyle = (i % 2 === 0) ? 'black' : 'blue';
+    ctx.lineWidth = 2;
+
+    ctx.beginPath();
+    ctx.moveTo(centerX, centerY);
+    ctx.lineTo(x, y);
+    ctx.stroke();
+
+}
+}
+
+function draw_center_spiral(centerx, centery, small_rad, large_rad, mysector) {
+    for (let i = 0; i < mysector; i++) {
+        let angle = (i / mysector) * 2 * Math.PI;
+
+        let x = centerx + (small_rad+large_rad*angle) * Math.cos(angle);
+        let y = centery + (small_rad+large_rad*angle) * Math.sin(angle);
+
+        ctx.strokeStyle = (i % 2 === 0) ? 'black' : 'red';
+
+        ctx.beginPath();
+        ctx.moveTo(centerx, centery);
+        ctx.lineTo(x, y);
+        ctx.stroke();
+    }
+}
+
+function draw_spiral(centerx, centery, small_rad, large_rad, mysector, shift_angle) {
+
+        ctx.strokeStyle = 'black';
+        ctx.beginPath();
+        ctx.moveTo(centerx, centery);
+    for (let i = 0; i < mysector; i++) {
+        let angle = (i / mysector) * 2 * Math.PI;
+
+        let x = centerx + (small_rad+large_rad*angle) * Math.cos(angle+shift_angle);
+        let y = centery + (small_rad+large_rad*angle) * Math.sin(angle+shift_angle);
+
+
+        ctx.lineTo(x, y);
+    }
+        ctx.stroke();
+}
+
+function draw_spoke(myx, myy, radius, mysector) {
+    for (let i = 0; i < mysector; i++) {
+        let angle = (i / mysector) * 2 * Math.PI;
+
+        let x = myx + radius * Math.cos(angle);
+        let y = myy + radius * Math.sin(angle);
+
+        ctx.strokeStyle = (i % 2 === 0) ? 'black' : 'red';
+
+        ctx.beginPath();
+        ctx.moveTo(myx, myy);
+        ctx.lineTo(x, y);
+        ctx.stroke();
+    }
+}
+
+</script>
+
+</body>
+</html>
+
diff --git a/spoke_subspokes.html b/spoke_subspokes.html
new file mode 100644
index 0000000..2975321
--- /dev/null
+++ b/spoke_subspokes.html
@@ -0,0 +1,52 @@
+<!DOCTYPE html>
+<html>
+<body>
+
+<canvas id="illusionCanvas" width="1200" height="1200"></canvas>
+
+<script>
+const canvas = document.getElementById('illusionCanvas');
+const ctx = canvas.getContext('2d');
+
+const centerX = canvas.width / 2;
+const centerY = canvas.height / 2;
+const sector = 30;
+const maxRadius = Math.min(canvas.width, canvas.height) / 2;
+
+for (let i = 0; i < sector; i++) {
+    let angle = (i / sector) * 2 * Math.PI;
+    let x = centerX + maxRadius * Math.cos(angle);
+    let y = centerY + maxRadius * Math.sin(angle);
+
+    ctx.strokeStyle = (i % 2 === 0) ? 'black' : 'blue';
+    ctx.lineWidth = 2;
+
+    ctx.beginPath();
+    ctx.moveTo(centerX, centerY);
+    ctx.lineTo(x, y);
+    ctx.stroke();
+
+    draw_spoke(x, y, maxRadius/4, sector*3);
+}
+
+function draw_spoke(myx, myy, radius, mysector) {
+    for (let i = 0; i < mysector; i++) {
+        let angle = (i / mysector) * 2 * Math.PI;
+
+        let x = myx + radius * Math.cos(angle);
+        let y = myy + radius * Math.sin(angle);
+
+        ctx.strokeStyle = (i % 2 === 0) ? 'black' : 'red';
+
+        ctx.beginPath();
+        ctx.moveTo(myx, myy);
+        ctx.lineTo(x, y);
+        ctx.stroke();
+    }
+}
+
+</script>
+
+</body>
+</html>
+
diff --git a/static_concentric.html b/static_concentric.html
new file mode 100644
index 0000000..db59846
--- /dev/null
+++ b/static_concentric.html
@@ -0,0 +1,68 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Canvas Pattern</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #fff;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="patternCanvas" width="500" height="500"></canvas>
+    <script>
+        const canvas = document.getElementById('patternCanvas');
+        const ctx = canvas.getContext('2d');
+        const width = canvas.width;
+        const height = canvas.height;
+        const radius = 100;
+        const lineWidth = 2;
+
+        ctx.lineWidth = lineWidth;
+
+        const colors = ['#FF5733', '#33FF57', '#3357FF', '#FF33A1', '#A133FF']; // Array of colors
+        const numColors = colors.length;
+
+        function drawPattern() {
+            const offsetX = width / 2;
+            const offsetY = height / 2;
+            const spacing = 10;
+
+            drawArcs(offsetX, offsetY, radius, spacing);
+
+            /*for (let i = 0; i <= width / radius; i++) {
+                for (let j = 0; j <= height / radius; j++) {
+                }
+            }
+	    */
+        }
+
+        function drawArcs(x, y, radius, spacing) {
+            let colorIndex = Math.floor(Math.random() * 16);
+
+
+            for (let r = radius; r > 0; r -= spacing) {
+                ctx.strokeStyle = colors[colorIndex % numColors];
+                ctx.beginPath();
+                ctx.arc(x, y, r, 0, Math.PI * 2, false);
+                ctx.stroke();
+                
+                colorIndex++; // Move to the next color in the array
+            }
+        }
+
+        drawPattern();
+    </script>
+</body>
+</html>
+
diff --git a/three_petal.html b/three_petal.html
new file mode 100644
index 0000000..7ac0f88
--- /dev/null
+++ b/three_petal.html
@@ -0,0 +1,28 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Three Petal Shape Animation</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            background-color: white;
+            border: 1px solid #ccc;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="animationCanvas" width="600" height="600"></canvas>
+    <script src="three_petal.js"></script>
+</body>
+</html>
+
diff --git a/three_petal.js b/three_petal.js
new file mode 100644
index 0000000..4bd34f4
--- /dev/null
+++ b/three_petal.js
@@ -0,0 +1,57 @@
+
+const canvas = document.getElementById('animationCanvas');
+const ctx = canvas.getContext('2d');
+const nPoints = 240;
+let step = 1;
+
+function getPoints() {
+    const points = [];
+    const centerX = canvas.width / 2;
+    const centerY = canvas.height / 2;
+    const radius = Math.min(centerX, centerY) * 0.9;
+
+    for (let i = 0; i < nPoints; i++) {
+        const theta = (2 * Math.PI * i) / nPoints;
+        const r = Math.cos(3 * theta);
+        const x = centerX + radius * r * Math.cos(theta);
+        const y = centerY + radius * r * Math.sin(theta);
+        points.push({ x, y });
+    }
+
+    return points;
+}
+
+function drawPoints(points) {
+    ctx.clearRect(0, 0, canvas.width, canvas.height);
+    ctx.fillStyle = 'blue';
+
+    for (const point of points) {
+        ctx.beginPath();
+        ctx.arc(point.x, point.y, 3, 0, 2 * Math.PI);
+        ctx.fill();
+    }
+}
+
+function drawLines(points, step) {
+    ctx.strokeStyle = 'blue';
+
+    for (let i = 0; i < points.length; i++) {
+        const j = (i + step) % points.length;
+        ctx.beginPath();
+        ctx.moveTo(points[i].x, points[i].y);
+        ctx.lineTo(points[j].x, points[j].y);
+        ctx.stroke();
+    }
+}
+
+function animate() {
+    const points = getPoints();
+    drawPoints(points);
+    drawLines(points, step);
+    step = (step % (nPoints - 1)) + 1; // Increment step from 1 to 59
+
+    setTimeout(animate, 200); // Control animation speed
+}
+
+animate();
+
diff --git a/torus.html b/torus.html
new file mode 100644
index 0000000..efc0ec9
--- /dev/null
+++ b/torus.html
@@ -0,0 +1,118 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>3D Shapes Wireframe</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            border: 1px solid black;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="canvas" width="800" height="800"></canvas>
+    <script>
+        const canvas = document.getElementById('canvas');
+        const ctx = canvas.getContext('2d');
+        const width = canvas.width;
+        const height = canvas.height;
+        const centerX = width / 2;
+        const centerY = height / 2;
+        const scale = 50;
+
+        function drawShapes() {
+            //drawMobiusStrip(centerX - 250, centerY - 250);
+            //drawKleinBottle(centerX + 250, centerY - 250);
+            drawTorus(centerX, centerY); 
+        }
+
+        function drawMobiusStrip(offsetX, offsetY) {
+            const uStep = Math.PI / 18;
+            const vStep = 2 * Math.PI / 36;
+
+            for (let u = 0; u < 4 * Math.PI; u += uStep) {
+                for (let v = 1.0; v < 12.5; v += vStep) {
+                    const x = (1 + v * Math.cos(u / 2)) * Math.cos(u);
+                    const y = (1 + v * Math.cos(u / 2)) * Math.sin(u);
+                    const z = v * Math.sin(u / 2);
+
+                    const nextX = (1 + v * Math.cos((u + uStep) / 2)) * Math.cos(u + uStep);
+                    const nextY = (1 + v * Math.cos((u + uStep) / 2)) * Math.sin(u + uStep);
+                    const nextZ = v * Math.sin((u + uStep) / 2);
+
+                    drawLine(offsetX, offsetY, project(x, y, z), project(nextX, nextY, nextZ));
+                }
+            }
+        }
+
+        function drawKleinBottle(offsetX, offsetY) {
+            const uStep = Math.PI / 18;
+            const vStep = 2 * Math.PI / 36;
+
+            for (let u = 0; u < 4 * Math.PI; u += uStep) {
+                for (let v = 0; v < 4 * Math.PI; v += vStep) {
+                    const x = (10 + 20 * Math.cos(u)) * Math.cos(v);
+                    const y = (30 + 10* Math.cos(u)) * Math.sin(v);
+                    const z = 20 * Math.sin(u) * Math.cos(v / 2);
+
+                    const nextX = (40 + 2 * Math.cos(u + uStep)) * Math.cos(v);
+                    const nextY = (40 + 2 * Math.cos(u + uStep)) * Math.sin(v);
+                    const nextZ = 2 * Math.sin(u + uStep) * Math.cos(v / 2);
+
+                    drawLine(offsetX, offsetY, project(x, y, z), project(nextX, nextY, nextZ));
+                }
+            }
+        }
+
+        function drawTorus(offsetX, offsetY) {
+            const uStep = Math.PI / 18;
+            const vStep = 2 * Math.PI / 36;
+
+            for (let u = 0; u < 4 * Math.PI; u += uStep) {
+                for (let v = 0; v < 4 * Math.PI; v += vStep) {
+                    const R = 40;
+                    const r = 10;
+                    const x = (R + r * Math.cos(v)) * Math.cos(u);
+                    const y = (R + r * Math.cos(v)) * Math.sin(u);
+                    const z = r * Math.sin(v);
+
+                    const nextX = (R + r * Math.cos(v + vStep)) * Math.cos(u);
+                    const nextY = (R + r * Math.cos(v + vStep)) * Math.sin(u);
+                    const nextZ = r * Math.sin(v + vStep);
+
+                    drawLine(offsetX, offsetY, project(x, y, z), project(nextX, nextY, nextZ));
+                }
+            }
+        }
+
+        function project(x, y, z) {
+            const perspective = 500 / (500 + z);
+            return [
+                centerX + x * scale * perspective,
+                centerY - y * scale * perspective
+            ];
+        }
+
+        function drawLine(offsetX, offsetY, start, end) {
+            ctx.beginPath();
+            ctx.moveTo(start[0] + offsetX, start[1] + offsetY);
+            ctx.lineTo(end[0] + offsetX, end[1] + offsetY);
+            ctx.stroke();
+        }
+
+        ctx.clearRect(0, 0, width, height);
+        ctx.strokeStyle = 'black';
+        drawShapes();
+    </script>
+</body>
+</html>
+
diff --git a/torus2.html b/torus2.html
new file mode 100644
index 0000000..c7712b0
--- /dev/null
+++ b/torus2.html
@@ -0,0 +1,273 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Dynamic 3D Spiral Surface - WebGL</title>
+    <style>
+        body, html { margin: 0; padding: 0; overflow: hidden; background-color: black; }
+        canvas { display: block; cursor: pointer; }
+    </style>
+</head>
+<body>
+    <canvas id="glCanvas"></canvas>
+
+    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
+    <script>
+        let canvas = document.getElementById('glCanvas');
+        let gl = canvas.getContext('webgl');
+
+        if (!gl) {
+            alert('WebGL not supported, falling back on experimental-webgl');
+            gl = canvas.getContext('experimental-webgl');
+        }
+
+        if (!gl) {
+            alert('Your browser does not support WebGL');
+        }
+
+        function resizeCanvas() {
+            canvas.width = window.innerWidth;
+            canvas.height = window.innerHeight;
+            gl.viewport(0, 0, canvas.width, canvas.height);
+        }
+
+        window.addEventListener('resize', resizeCanvas);
+        resizeCanvas();
+
+        // Variables for rotation control
+        let rotationX = 0;
+        let rotationY = 0;
+        let isDragging = false;
+        let lastMouseX = 0;
+        let lastMouseY = 0;
+
+        // Event listeners for mouse interactions
+        canvas.addEventListener('mousedown', (event) => {
+            isDragging = true;
+            lastMouseX = event.clientX;
+            lastMouseY = event.clientY;
+        });
+
+        canvas.addEventListener('mousemove', (event) => {
+            if (isDragging) {
+                let deltaX = event.clientX - lastMouseX;
+                let deltaY = event.clientY - lastMouseY;
+
+                rotationX += deltaY * 0.01;
+                rotationY += deltaX * 0.01;
+
+                lastMouseX = event.clientX;
+                lastMouseY = event.clientY;
+            }
+        });
+
+        canvas.addEventListener('mouseup', () => {
+            isDragging = false;
+        });
+
+        canvas.addEventListener('mouseleave', () => {
+            isDragging = false;
+        });
+
+        // Vertex shader program
+        const vsSource = `
+            attribute vec4 aVertexPosition;
+            uniform mat4 uModelViewMatrix;
+            uniform mat4 uProjectionMatrix;
+            void main(void) {
+                gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
+            }
+        `;
+
+        // Fragment shader program
+        const fsSource = `
+            void main(void) {
+                gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
+            }
+        `;
+
+        // Initialize a shader program; this is where all the lighting
+        // for the vertices and so forth is established.
+        const shaderProgram = initShaderProgram(gl, vsSource, fsSource);
+
+        // Collect all the info needed to use the shader program.
+        const programInfo = {
+            program: shaderProgram,
+            attribLocations: {
+                vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
+            },
+            uniformLocations: {
+                projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
+                modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
+            },
+        };
+
+        // Here's where we call the routine that builds all the objects
+        // we'll be drawing.
+        const buffers = initBuffers(gl);
+
+        let then = 0;
+
+        // Draw the scene repeatedly
+        function render(now) {
+            now *= 0.001;  // convert to seconds
+            const deltaTime = now - then;
+            then = now;
+
+            drawScene(gl, programInfo, buffers, deltaTime);
+
+            requestAnimationFrame(render);
+        }
+        requestAnimationFrame(render);
+
+        function initShaderProgram(gl, vsSource, fsSource) {
+            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
+            const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
+
+            // Create the shader program
+            const shaderProgram = gl.createProgram();
+            gl.attachShader(shaderProgram, vertexShader);
+            gl.attachShader(shaderProgram, fragmentShader);
+            gl.linkProgram(shaderProgram);
+
+            // If creating the shader program failed, alert
+            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
+                alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
+                return null;
+            }
+
+            return shaderProgram;
+        }
+
+        function loadShader(gl, type, source) {
+            const shader = gl.createShader(type);
+
+            // Send the source to the shader object
+            gl.shaderSource(shader, source);
+
+            // Compile the shader program
+            gl.compileShader(shader);
+
+            // See if it compiled successfully
+            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
+                alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
+                gl.deleteShader(shader);
+                return null;
+            }
+
+            return shader;
+        }
+
+        function initBuffers(gl) {
+            // Create a buffer for the spiral's vertex positions.
+            const positionBuffer = gl.createBuffer();
+
+            // Select the positionBuffer as the one to apply buffer
+            // operations to from here out.
+            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
+
+            // Now create an array of positions for the spiral surface.
+            const positions = createSpiralSurface();
+
+            // Now pass the list of positions into WebGL to build the
+            // shape. We do this by creating a Float32Array from the
+            // JavaScript array, then use it to fill the current buffer.
+            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
+
+            return {
+                position: positionBuffer,
+                vertexCount: positions.length / 3
+            };
+        }
+
+        function createSpiralSurface(radius1 = 2.0, radius2 = 2.0, turns1 = 30, turns2 = 30) {
+            const positions = [];
+            const itheta = 2 * Math.PI / turns1;
+            const jtheta = 2 * Math.PI / turns2;
+
+            for (let i = 0; i < turns1; i++) {
+                for (let j = 0; j < turns2; j++) {
+                    const x = radius1 * Math.cos(j * jtheta);
+                    const y = radius2 * Math.sin(i * itheta);
+                    const z = radius1 * Math.cos(i * itheta) + radius2 * Math.sin(j * jtheta);
+                    positions.push(x, y, z);
+                }
+            }
+
+            return positions;
+        }
+
+        function drawScene(gl, programInfo, buffers, deltaTime) {
+            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
+
+            const fieldOfView = 45 * Math.PI / 180;   // in radians
+            const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
+            const zNear = 0.1;
+            const zFar = 100.0;
+            const projectionMatrix = mat4.create();
+
+            mat4.perspective(projectionMatrix,
+                             fieldOfView,
+                             aspect,
+                             zNear,
+                             zFar);
+
+            const modelViewMatrix = mat4.create();
+
+            mat4.translate(modelViewMatrix,    // destination matrix
+                           modelViewMatrix,    // matrix to translate
+                           [0.0, 0.0, -10.0]); // amount to translate
+
+            // Apply rotations based on user input
+            mat4.rotate(modelViewMatrix,  // destination matrix
+                        modelViewMatrix,  // matrix to rotate
+                        rotationX,        // rotation around the X axis
+                        [1, 0, 0]);       // X axis
+            mat4.rotate(modelViewMatrix,  // destination matrix
+                        modelViewMatrix,  // matrix to rotate
+                        rotationY,        // rotation around the Y axis
+                        [0, 1, 0]);       // Y axis
+
+            // Tell WebGL how to pull out the positions from the position buffer into the vertexPosition attribute
+            {
+                const numComponents = 3;
+                const type = gl.FLOAT;
+                const normalize = false;
+                const stride = 0;
+                const offset = 0;
+                gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
+                gl.vertexAttribPointer(
+                    programInfo.attribLocations.vertexPosition,
+                    numComponents,
+                    type,
+                    normalize,
+                    stride,
+                    offset);
+                gl.enableVertexAttribArray(
+                    programInfo.attribLocations.vertexPosition);
+            }
+
+            // Tell WebGL to use our program when drawing
+            gl.useProgram(programInfo.program);
+
+            // Set the shader uniforms
+            gl.uniformMatrix4fv(
+                programInfo.uniformLocations.projectionMatrix,
+                false,
+                projectionMatrix);
+            gl.uniformMatrix4fv(
+                programInfo.uniformLocations.modelViewMatrix,
+                false,
+                modelViewMatrix);
+
+            {
+                const offset = 0;
+                gl.drawArrays(gl.LINE_STRIP, offset, buffers.vertexCount);
+            }
+        }
+    </script>
+</body>
+</html>
+
diff --git a/triple_motion.html b/triple_motion.html
new file mode 100644
index 0000000..94ba80f
--- /dev/null
+++ b/triple_motion.html
@@ -0,0 +1,71 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Dynamic Complex Line Drawing</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #333;
+        }
+        canvas {
+            border: 1px solid black;
+            background-color: #333;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="complexLineCanvas" width="600" height="600"></canvas>
+    <script>
+        const canvas = document.getElementById('complexLineCanvas');
+        const ctx = canvas.getContext('2d');
+        const centerX = canvas.width / 2;
+        const centerY = canvas.height / 2;
+        const numLines = 360;
+
+        let angleMultiplier1 = 2;
+        let angleMultiplier2 = 4;
+        let radius1 = 100;
+        let radius2 = 400;
+        let angleOffset = 0;
+
+        // Function to draw the complex pattern
+        function drawComplexPattern() {
+            ctx.clearRect(0, 0, canvas.width, canvas.height);
+            ctx.strokeStyle = '#ffffff';
+            ctx.lineWidth = 0.5;
+
+            for (let i = 0; i < numLines; i++) {
+                const angle1 = (i / numLines) * 2 * Math.PI;
+                const angle2 = ((i + 180) / numLines) * 2 * Math.PI;
+                const x1 = centerX + radius1 * Math.cos(angleMultiplier1 * (angle1 + angleOffset)) * Math.sin(angle2 + angleOffset);
+                const y1 = centerY + radius1 * Math.sin(angleMultiplier2 * (angle1 + angleOffset)) * Math.sin(angle2 + angleOffset);
+                const x2 = centerX + radius2 * Math.cos(angle2 + angleOffset) * Math.sin(angle1 + angleOffset);
+                const y2 = centerY + radius2 * Math.sin(angle2 + angleOffset) * Math.sin(angle1 + angleOffset);
+
+                ctx.beginPath();
+                ctx.moveTo(x1, y1);
+                ctx.lineTo(x2, y2);
+                ctx.stroke();
+            }
+
+            // Update parameters to create animation
+            angleOffset += 0.01;
+            angleMultiplier1 = 2 + Math.sin(angleOffset) * 2;
+            angleMultiplier2 = 4 + Math.cos(angleOffset) * 2;
+            radius1 = 100 + Math.sin(3*angleOffset) * 50;
+            radius2 = 400 + Math.cos(angleOffset) * 50;
+
+            requestAnimationFrame(drawComplexPattern);
+        }
+
+        drawComplexPattern();
+    </script>
+</body>
+</html>
+
diff --git a/try.html b/try.html
new file mode 100644
index 0000000..483a050
--- /dev/null
+++ b/try.html
@@ -0,0 +1,83 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Enneper Surface Visualization</title>
+    <style>
+        body { margin: 0; }
+        canvas { display: block; }
+    </style>
+</head>
+<body>
+    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
+
+    <script>
+        function enneperSurface(u, v, n) {
+            const x = u - Math.pow(u, 2*n+1) / (2*n+1) + u * v * v;
+            const y = -v + Math.pow(v, 2*n+1) / (2*n+1) + v * u * u;
+            const z = u * u - v * v;
+            return { x, y, z };
+        }
+
+        function createSurfaceGeometry(n, resolution = 50) {
+            const geometry = new THREE.BufferGeometry();
+            const vertices = [];
+
+            for (let i = 0; i < resolution; i++) {
+                for (let j = 0; j < resolution; j++) {
+                    const u = (i / resolution) * 4 - 2;  // Map i to range [-2, 2]
+                    const v = (j / resolution) * 4 - 2;  // Map j to range [-2, 2]
+                    const point = enneperSurface(u, v, n);
+                    vertices.push(point.x, point.y, point.z);
+                }
+            }
+
+            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
+            return geometry;
+        }
+
+        function createScene() {
+            const scene = new THREE.Scene();
+            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
+            const renderer = new THREE.WebGLRenderer({ antialias: true });
+            renderer.setSize(window.innerWidth, window.innerHeight);
+            document.body.appendChild(renderer.domElement);
+
+            const light = new THREE.DirectionalLight(0xffffff, 1);
+            light.position.set(5, 5, 5).normalize();
+            scene.add(light);
+
+            const material = new THREE.MeshPhongMaterial({ color: 0x00cccc, side: THREE.DoubleSide, wireframe: false, transparent: true, opacity: 0.6 });
+
+            const surfaces = [];
+            const nValues = [1, 2, 3, 4];
+
+            nValues.forEach((n) => {
+                const geometry = createSurfaceGeometry(n);
+                const surface = new THREE.Mesh(geometry, material);
+                surfaces.push(surface);
+                scene.add(surface);
+            });
+
+            camera.position.z = 5;
+
+            function animate() {
+                requestAnimationFrame(animate);
+
+                surfaces.forEach((surface, index) => {
+                    surface.rotation.x += 0.01;
+                    surface.rotation.y += 0.01;
+                });
+
+                renderer.render(scene, camera);
+            }
+
+            animate();
+        }
+
+        createScene();
+    </script>
+</body>
+</html>
+
diff --git a/try5.html b/try5.html
new file mode 100644
index 0000000..7c231d9
--- /dev/null
+++ b/try5.html
@@ -0,0 +1,219 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Interactive 3D Ellipsoid - WebGL</title>
+    <style>
+        body, html { margin: 0; padding: 0; overflow: hidden; background-color: black; }
+        canvas { display: block; cursor: pointer; }
+    </style>
+</head>
+<body>
+    <canvas id="glCanvas"></canvas>
+
+    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
+    <script>
+        let canvas = document.getElementById('glCanvas');
+        let gl = canvas.getContext('webgl');
+
+        if (!gl) {
+            alert('WebGL not supported, falling back on experimental-webgl');
+            gl = canvas.getContext('experimental-webgl');
+        }
+
+        if (!gl) {
+            alert('Your browser does not support WebGL');
+        }
+
+        function resizeCanvas() {
+            canvas.width = window.innerWidth;
+            canvas.height = window.innerHeight;
+            gl.viewport(0, 0, canvas.width, canvas.height);
+        }
+
+        window.addEventListener('resize', resizeCanvas);
+        resizeCanvas();
+
+        let xrot = 0.2;
+        let yrot = 0.0;
+        let zrot = 0.0;
+
+        let xdiff = 0.0;
+        let ydiff = 0.0;
+        let mouseDown = false;
+
+        // Event listeners for mouse interactions
+        canvas.addEventListener('mousedown', (event) => {
+            mouseDown = true;
+            xdiff = event.clientX - yrot;
+            ydiff = event.clientY + xrot;
+        });
+
+        canvas.addEventListener('mousemove', (event) => {
+            if (mouseDown) {
+                yrot = event.clientX - xdiff;
+                xrot = event.clientY + ydiff;
+            }
+        });
+
+        canvas.addEventListener('mouseup', () => {
+            mouseDown = false;
+        });
+
+        canvas.addEventListener('mouseleave', () => {
+            mouseDown = false;
+        });
+
+        // Vertex shader program
+        const vsSource = `
+            attribute vec4 aVertexPosition;
+            uniform mat4 uModelViewMatrix;
+            uniform mat4 uProjectionMatrix;
+            void main(void) {
+                gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
+            }
+        `;
+
+        // Fragment shader program
+        const fsSource = `
+            void main(void) {
+                gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
+            }
+        `;
+
+        const shaderProgram = initShaderProgram(gl, vsSource, fsSource);
+
+        const programInfo = {
+            program: shaderProgram,
+            attribLocations: {
+                vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
+            },
+            uniformLocations: {
+                projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
+                modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
+            },
+        };
+
+        const buffers = initBuffers(gl);
+
+        function render() {
+            drawScene(gl, programInfo, buffers);
+            requestAnimationFrame(render);
+        }
+        requestAnimationFrame(render);
+
+        function initShaderProgram(gl, vsSource, fsSource) {
+            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
+            const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
+
+            const shaderProgram = gl.createProgram();
+            gl.attachShader(shaderProgram, vertexShader);
+            gl.attachShader(shaderProgram, fragmentShader);
+            gl.linkProgram(shaderProgram);
+
+            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
+                alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
+                return null;
+            }
+
+            return shaderProgram;
+        }
+
+        function loadShader(gl, type, source) {
+            const shader = gl.createShader(type);
+            gl.shaderSource(shader, source);
+            gl.compileShader(shader);
+
+            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
+                alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
+                gl.deleteShader(shader);
+                return null;
+            }
+
+            return shader;
+        }
+
+        function initBuffers(gl) {
+            const positionBuffer = gl.createBuffer();
+            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
+
+            const positions = createEllipsoid(12, 40, 1.1, 2.1, 5.1);
+
+            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
+
+            return {
+                position: positionBuffer,
+                vertexCount: positions.length / 3
+            };
+        }
+
+        function createEllipsoid(uistacks, uislices, fA, fB, fC) {
+            const positions = [];
+            const tstep = Math.PI / uislices;
+            const sstep = Math.PI / uistacks;
+
+            for (let i = 0; i < 2 * uislices; i++) {
+                const t = tstep * i;
+                for (let j = 0; j <= 2 * uistacks; j++) {
+                    const s = sstep * j;
+
+                    const x1 = fA * Math.sin(t * 3) * Math.cos(t) * Math.cos(s);
+                    const y1 = fB * Math.sin(t / 2) * Math.cos(t) * Math.sin(s);
+                    const z1 = fC * Math.sin(t / 2) * Math.sin(t);
+
+                    const x2 = fA * Math.sin((t + tstep) * 3) * Math.cos(t + tstep) * Math.cos(s);
+                    const y2 = fB * Math.sin((t + tstep) / 2) * Math.cos(t + tstep) * Math.sin(s);
+                    const z2 = fC * Math.sin((t + tstep) / 2) * Math.sin(t + tstep);
+
+                    positions.push(x1, y1, z1, x2, y2, z2);
+                }
+            }
+
+            return positions;
+        }
+
+        function drawScene(gl, programInfo, buffers) {
+            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
+
+            const fieldOfView = 45 * Math.PI / 180;
+            const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
+            const zNear = 0.1;
+            const zFar = 100.0;
+            const projectionMatrix = mat4.create();
+
+            mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);
+
+            const modelViewMatrix = mat4.create();
+
+            mat4.translate(modelViewMatrix, modelViewMatrix, [0.0, 0.0, -10.0]);
+
+            mat4.rotate(modelViewMatrix, modelViewMatrix, xrot, [1, 0, 0]);
+            mat4.rotate(modelViewMatrix, modelViewMatrix, yrot, [0, 1, 0]);
+            mat4.rotate(modelViewMatrix, modelViewMatrix, zrot, [0, 0, 1]);
+
+            {
+                const numComponents = 3;
+                const type = gl.FLOAT;
+                const normalize = false;
+                const stride = 0;
+                const offset = 0;
+                gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
+                gl.vertexAttribPointer(programInfo.attribLocations.vertexPosition, numComponents, type, normalize, stride, offset);
+                gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);
+            }
+
+            gl.useProgram(programInfo.program);
+
+            gl.uniformMatrix4fv(programInfo.uniformLocations.projectionMatrix, false, projectionMatrix);
+            gl.uniformMatrix4fv(programInfo.uniformLocations.modelViewMatrix, false, modelViewMatrix);
+
+            {
+                const offset = 0;
+                gl.drawArrays(gl.LINE_STRIP, offset, buffers.vertexCount);
+            }
+        }
+    </script>
+</body>
+</html>
+
diff --git a/two_ellipse.html b/two_ellipse.html
new file mode 100644
index 0000000..bc65fed
--- /dev/null
+++ b/two_ellipse.html
@@ -0,0 +1,28 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Two Ellipse Lines Animation</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            background-color: white;
+            border: 1px solid #ccc;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="animationCanvas" width="600" height="600"></canvas>
+    <script src="two_ellipse.js"></script>
+</body>
+</html>
+
diff --git a/two_ellipse.js b/two_ellipse.js
new file mode 100644
index 0000000..45193e9
--- /dev/null
+++ b/two_ellipse.js
@@ -0,0 +1,73 @@
+
+const canvas = document.getElementById('animationCanvas');
+const ctx = canvas.getContext('2d');
+const nPoints = 60;
+const bigA = 200; // Semi-major axis length of the big ellipse
+const bigB = 100; // Semi-minor axis length of the big ellipse
+const smallA = 100; // Semi-major axis length of the small ellipse
+const smallB = 50;  // Semi-minor axis length of the small ellipse
+let bigRotationAngle = 0; // Initialize rotation angle for the big ellipse
+let smallRotationAngle = 0; // Initialize rotation angle for the small ellipse
+
+function getPoints(a, b, rotationAngle) {
+    const points = [];
+    const centerX = canvas.width / 2;
+    const centerY = canvas.height / 2;
+    const rotationRadians = rotationAngle * Math.PI / 180; // Convert degrees to radians
+
+    for (let i = 0; i < nPoints; i++) {
+        const theta = (2 * Math.PI * i) / nPoints;
+        const x = centerX + (a * Math.cos(theta) * Math.cos(rotationRadians) - b * Math.sin(theta) * Math.sin(rotationRadians));
+        const y = centerY + (a * Math.cos(theta) * Math.sin(rotationRadians) + b * Math.sin(theta) * Math.cos(rotationRadians));
+        points.push({ x, y });
+    }
+
+    return points;
+}
+
+function drawPoints(points, color) {
+    ctx.fillStyle = color;
+
+    for (const point of points) {
+        ctx.beginPath();
+        ctx.arc(point.x, point.y, 3, 0, 2 * Math.PI);
+        ctx.fill();
+    }
+}
+
+function drawLines(points1, points2) {
+    ctx.strokeStyle = 'blue';
+
+    for (let i = 0; i < points1.length; i++) {
+        ctx.beginPath();
+        ctx.moveTo(points1[i].x, points1[i].y);
+        ctx.lineTo(points2[i].x, points2[i].y);
+        ctx.stroke();
+    }
+}
+
+function animate() {
+    // Get points for both ellipses
+    const bigEllipsePoints = getPoints(bigA, bigB, bigRotationAngle);
+    const smallEllipsePoints = getPoints(smallA, smallB, smallRotationAngle);
+
+    // Clear the canvas
+    ctx.clearRect(0, 0, canvas.width, canvas.height);
+
+    // Draw the points on both ellipses
+    drawPoints(bigEllipsePoints, 'red');
+    drawPoints(smallEllipsePoints, 'green');
+
+    // Draw lines connecting corresponding points of the two ellipses
+    drawLines(bigEllipsePoints, smallEllipsePoints);
+
+    // Increment rotation angles for the next frame
+    bigRotationAngle += 5;  // Rotate the big ellipse by 5 degrees
+    smallRotationAngle += 10; // Rotate the small ellipse by 10 degrees
+
+    // Control animation speed and repeat
+    setTimeout(animate, 200);
+}
+
+animate();
+
diff --git a/two_petal.html b/two_petal.html
new file mode 100644
index 0000000..f3a75f8
--- /dev/null
+++ b/two_petal.html
@@ -0,0 +1,28 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Two-Petal Shape Animation</title>
+    <style>
+        body {
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+            margin: 0;
+            background-color: #f0f0f0;
+        }
+        canvas {
+            background-color: white;
+            border: 1px solid #ccc;
+        }
+    </style>
+</head>
+<body>
+    <canvas id="animationCanvas" width="600" height="600"></canvas>
+    <script src="two_petal.js"></script>
+</body>
+</html>
+
diff --git a/two_petal.js b/two_petal.js
new file mode 100644
index 0000000..be66534
--- /dev/null
+++ b/two_petal.js
@@ -0,0 +1,57 @@
+
+const canvas = document.getElementById('animationCanvas');
+const ctx = canvas.getContext('2d');
+const nPoints = 120;
+let step = 1;
+
+function getPoints() {
+    const points = [];
+    const centerX = canvas.width / 2;
+    const centerY = canvas.height / 2;
+    const radius = Math.min(centerX, centerY) * 0.9;
+
+    for (let i = 0; i < nPoints; i++) {
+        const theta = (2 * Math.PI * i) / nPoints;
+        const r = Math.cos(2 * theta);
+        const x = centerX + radius * r * Math.cos(theta);
+        const y = centerY + radius * r * Math.sin(theta);
+        points.push({ x, y });
+    }
+
+    return points;
+}
+
+function drawPoints(points) {
+    ctx.clearRect(0, 0, canvas.width, canvas.height);
+    ctx.fillStyle = 'blue';
+
+    for (const point of points) {
+        ctx.beginPath();
+        ctx.arc(point.x, point.y, 3, 0, 2 * Math.PI);
+        ctx.fill();
+    }
+}
+
+function drawLines(points, step) {
+    ctx.strokeStyle = 'blue';
+
+    for (let i = 0; i < points.length; i++) {
+        const j = (i + step) % points.length;
+        ctx.beginPath();
+        ctx.moveTo(points[i].x, points[i].y);
+        ctx.lineTo(points[j].x, points[j].y);
+        ctx.stroke();
+    }
+}
+
+function animate() {
+    const points = getPoints();
+    drawPoints(points);
+    drawLines(points, step);
+    step = (step % (nPoints - 1)) + 1; // Increment step from 1 to 59
+
+    setTimeout(animate, 200); // Control animation speed
+}
+
+animate();
+
diff --git a/webgl.html b/webgl.html
new file mode 100644
index 0000000..33572f4
--- /dev/null
+++ b/webgl.html
@@ -0,0 +1,18 @@
+
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>WebGL Example</title>
+    <style>
+        body { margin: 0; }
+        canvas { display: block; width: 100vw; height: 100vh; }
+    </style>
+</head>
+<body>
+    <canvas id="glCanvas"></canvas>
+    <script src="main.js"></script>
+</body>
+</html>
+
diff --git a/webgl_3dcube.html b/webgl_3dcube.html
new file mode 100644
index 0000000..9f6f63e
--- /dev/null
+++ b/webgl_3dcube.html
@@ -0,0 +1,344 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+  <meta charset="UTF-8">
+  <meta name="viewport" content="width=device-width, initial-scale=1.0">
+  <title>3D Rotating Cube with WebGL</title>
+  <style>
+    body {
+      margin: 0;
+      display: flex;
+      justify-content: center;
+      align-items: center;
+      height: 100vh;
+      background-color: #f0f0f0;
+    }
+    canvas {
+      border: 1px solid #000;
+    }
+  </style>
+</head>
+<body>
+  <canvas id="glCanvas" width="640" height="480"></canvas>
+  <script>
+    // Add the JavaScript code here
+
+const canvas = document.getElementById('glCanvas');
+const gl = canvas.getContext('webgl');
+
+if (!gl) {
+  console.log('WebGL not supported, falling back on experimental-webgl');
+  gl = canvas.getContext('experimental-webgl');
+}
+
+if (!gl) {
+  alert('Your browser does not support WebGL');
+}
+
+// Vertex shader program
+const vsSource = `
+  attribute vec4 aVertexPosition;
+  attribute vec4 aVertexColor;
+  uniform mat4 uModelViewMatrix;
+  uniform mat4 uProjectionMatrix;
+  varying lowp vec4 vColor;
+  void main(void) {
+    gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
+    vColor = aVertexColor;
+  }
+`;
+
+// Fragment shader program
+const fsSource = `
+  varying lowp vec4 vColor;
+  void main(void) {
+    gl_FragColor = vColor;
+  }
+`;
+
+// Initialize a shader program; this is where all the lighting for the vertices and so forth is established.
+const shaderProgram = initShaderProgram(gl, vsSource, fsSource);
+
+// Collect all the info needed to use the shader program.
+const programInfo = {
+  program: shaderProgram,
+  attribLocations: {
+    vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
+    vertexColor: gl.getAttribLocation(shaderProgram, 'aVertexColor'),
+  },
+  uniformLocations: {
+    projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
+    modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
+  },
+};
+
+// Here's where we call the routine that builds all the objects we'll be drawing.
+const buffers = initBuffers(gl);
+
+let then = 0;
+
+// Draw the scene repeatedly
+function render(now) {
+  now *= 0.001;  // convert to seconds
+  const deltaTime = now - then;
+  then = now;
+
+  drawScene(gl, programInfo, buffers, deltaTime);
+
+  requestAnimationFrame(render);
+}
+requestAnimationFrame(render);
+
+// Initialize the buffers we'll need. For this demo, we just have one object -- a simple three-dimensional cube.
+function initBuffers(gl) {
+
+  // Create a buffer for the cube's vertex positions.
+  const positionBuffer = gl.createBuffer();
+
+  // Select the positionBuffer as the one to apply buffer operations to from here out.
+  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
+
+  // Now create an array of positions for the cube.
+  const positions = [
+     // Front face
+     -1.0, -1.0,  1.0,
+      1.0, -1.0,  1.0,
+      1.0,  1.0,  1.0,
+     -1.0,  1.0,  1.0,
+
+     // Back face
+     -1.0, -1.0, -1.0,
+     -1.0,  1.0, -1.0,
+      1.0,  1.0, -1.0,
+      1.0, -1.0, -1.0,
+
+     // Top face
+     -1.0,  1.0, -1.0,
+     -1.0,  1.0,  1.0,
+      1.0,  1.0,  1.0,
+      1.0,  1.0, -1.0,
+
+     // Bottom face
+     -1.0, -1.0, -1.0,
+      1.0, -1.0, -1.0,
+      1.0, -1.0,  1.0,
+     -1.0, -1.0,  1.0,
+
+     // Right face
+      1.0, -1.0, -1.0,
+      1.0,  1.0, -1.0,
+      1.0,  1.0,  1.0,
+      1.0, -1.0,  1.0,
+
+     // Left face
+     -1.0, -1.0, -1.0,
+     -1.0, -1.0,  1.0,
+     -1.0,  1.0,  1.0,
+     -1.0,  1.0, -1.0,
+  ];
+
+  // Now pass the list of positions into WebGL to build the shape. We do this by creating a Float32Array from the JavaScript array, then use it to fill the current buffer.
+  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
+
+  // Now set up the colors for the faces. We'll use solid colors for each face.
+  const faceColors = [
+    [1.0,  1.0,  1.0,  1.0],    // Front face: white
+    [1.0,  0.0,  0.0,  1.0],    // Back face: red
+    [0.0,  1.0,  0.0,  1.0],    // Top face: green
+    [0.0,  0.0,  1.0,  1.0],    // Bottom face: blue
+    [1.0,  1.0,  0.0,  1.0],    // Right face: yellow
+    [1.0,  0.0,  1.0,  1.0],    // Left face: purple
+  ];
+
+  // Convert the array of colors into a table for all the vertices.
+  var colors = [];
+
+  for (var j = 0; j < faceColors.length; ++j) {
+    const c = faceColors[j];
+
+    // Repeat each color four times for the four vertices of the face
+    colors = colors.concat(c, c, c, c);
+  }
+
+  const colorBuffer = gl.createBuffer();
+  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
+  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
+
+  // Build the element array buffer; this specifies the indices into the vertex arrays for each face's vertices.
+  const indexBuffer = gl.createBuffer();
+  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
+
+  // This array defines each face as two triangles, using the indices into the vertex array to specify each triangle's position.
+  const indices = [
+    0,  1,  2,      0,  2,  3,    // front
+    4,  5,  6,      4,  6,  7,    // back
+    8,  9,  10,     8,  10, 11,   // top
+    12, 13, 14,     12, 14, 15,   // bottom
+    16, 17, 18,     16, 18, 19,   // right
+    20, 21, 22,     20, 22, 23,   // left
+  ];
+
+  // Now send the element array to GL
+  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
+
+  return {
+    position: positionBuffer,
+    color: colorBuffer,
+    indices: indexBuffer,
+  };
+}
+
+// Draw the scene.
+function drawScene(gl, programInfo, buffers, deltaTime) {
+  gl.clearColor(0.0, 0.0, 0.0, 1.0);  // Clear to black, fully opaque
+  gl.clearDepth(1.0);                 // Clear everything
+  gl.enable(gl.DEPTH_TEST);           // Enable depth testing
+  gl.depthFunc(gl.LEQUAL);            // Near things obscure far things
+
+  // Clear the canvas before we start drawing on it.
+  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
+
+  // Create a perspective matrix, a special matrix that is used to simulate the distortion of perspective in a camera. Our field of view is 45 degrees, with a width/height ratio that matches the display size of the canvas and we only want to see objects between 0.1 units and 100 units away from the camera.
+  const fieldOfView = 45 * Math.PI / 180;   // in radians
+  const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
+  const zNear = 0.1;
+  const zFar = 100.0;
+  const projectionMatrix = mat4.create();
+
+  mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);
+
+  // Set the drawing position to the "identity" point, which is the center of the scene.
+  const modelViewMatrix = mat4.create();
+
+  // Now move the drawing position a bit to where we want to start drawing the square.
+  mat4.translate(modelViewMatrix,     // destination matrix
+                 modelViewMatrix,     // matrix to translate
+                 [-0.0, 0.0, -6.0]);  // amount to translate
+
+  mat4.rotate(modelViewMatrix,  // destination matrix
+              modelViewMatrix,  // matrix to rotate
+              cubeRotation,     // amount to rotate in radians
+              [0, 0, 1]);       // axis to rotate around (Z)
+
+  mat4.rotate(modelViewMatrix,  // destination matrix
+              modelViewMatrix,  // matrix to rotate
+              cubeRotation * .7,// amount to rotate in radians
+              [0, 1, 0]);       // axis to rotate around (Y)
+
+  mat4.rotate(modelViewMatrix,  // destination matrix
+              modelViewMatrix,  // matrix to rotate
+              cubeRotation * .3,// amount to rotate in radians
+              [1, 0, 0]);       // axis to rotate around (X)
+
+  // Tell WebGL how to pull out the positions from the position buffer into the vertexPosition attribute.
+  {
+    const numComponents = 3;
+    const type = gl.FLOAT;
+    const normalize = false;
+    const stride = 0;
+    const offset = 0;
+    gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
+    gl.vertexAttribPointer(
+        programInfo.attribLocations.vertexPosition,
+        numComponents,
+        type,
+        normalize,
+        stride,
+        offset);
+    gl.enableVertexAttribArray(
+        programInfo.attribLocations.vertexPosition);
+  }
+
+  // Tell WebGL how to pull out the colors from the color buffer into the vertexColor attribute.
+  {
+    const numComponents = 4;
+    const type = gl.FLOAT;
+    const normalize = false;
+    const stride = 0;
+    const offset = 0;
+    gl.bindBuffer(gl.ARRAY_BUFFER, buffers.color);
+    gl.vertexAttribPointer(
+        programInfo.attribLocations.vertexColor,
+        numComponents,
+        type,
+        normalize,
+        stride,
+        offset);
+    gl.enableVertexAttribArray(
+        programInfo.attribLocations.vertexColor);
+  }
+
+  // Tell WebGL which indices to use to index the vertices
+  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);
+
+  // Tell WebGL to use our program when drawing
+  gl.useProgram(programInfo.program);
+
+  // Set the shader uniforms
+  gl.uniformMatrix4fv(
+      programInfo.uniformLocations.projectionMatrix,
+      false,
+      projectionMatrix);
+  gl.uniformMatrix4fv(
+      programInfo.uniformLocations.modelViewMatrix,
+      false,
+      modelViewMatrix);
+
+  {
+    const vertexCount = 36;
+    const type = gl.UNSIGNED_SHORT;
+    const offset = 0;
+    gl.drawElements(gl.TRIANGLES, vertexCount, type, offset);
+  }
+
+  // Update the rotation for the next draw
+  cubeRotation += deltaTime;
+}
+
+// Initialize a shader program, so WebGL knows how to draw our data
+function initShaderProgram(gl, vsSource, fsSource) {
+  const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
+  const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
+
+  // Create the shader program
+  const shaderProgram = gl.createProgram();
+  gl.attachShader(shaderProgram, vertexShader);
+  gl.attachShader(shaderProgram, fragmentShader);
+  gl.linkProgram(shaderProgram);
+
+  // If creating the shader program failed, alert
+  if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
+    alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
+    return null;
+  }
+
+  return shaderProgram;
+}
+
+// creates a shader of the given type, uploads the source and compiles it.
+function loadShader(gl, type, source) {
+  const shader = gl.createShader(type);
+
+  // Send the source to the shader object
+  gl.shaderSource(shader, source);
+
+  // Compile the shader program
+  gl.compileShader(shader);
+
+  // See if it compiled successfully
+  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
+    alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
+    gl.deleteShader(shader);
+    return null;
+  }
+
+  return shader;
+}
+
+var cubeRotation = 0.0;
+
+
+  </script>
+</body>
+</html>
+

commit 193777c6037abcdea37de0f5bedc51b49d1c1bb1
Author: tthtlc <htmldeveloper@gmail.com>
Date:   Sat Aug 31 09:59:03 2024 +0800

    first commit

diff --git a/README.md b/README.md
new file mode 100644
index 0000000..a75a82d
--- /dev/null
+++ b/README.md
@@ -0,0 +1 @@
+# tthtlc.github.io
