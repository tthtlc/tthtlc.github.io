<!DOCTYPE html>
<html>
<head>
    <style>
        canvas {
            border: 1px solid #ccc;
            margin: 20px;
        }
        .controls {
            margin: 20px;
        }
        label {
            margin-right: 10px;
        }
        input {
            margin-right: 20px;
        }
    </style>
</head>
<body>
    <div class="controls">
        <label for="rotation">Rotation (degrees):</label>
        <input type="range" id="rotation" min="0" max="90" value="30" oninput="updateParams()">
        <span id="rotationValue">30°</span>
        
        <label for="depth">Recursion Depth:</label>
        <input type="range" id="depth" min="1" max="15" value="8" oninput="updateParams()">
        <span id="depthValue">8</span>
    </div>
    <canvas id="canvas" width="800" height="800"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let rotation = 30;
        let depth = 8;
        const initialSize = 200;

        // Helper function to rotate a point around a center point
        function rotatePoint(x, y, cx, cy, angle) {
            const radians = angle * Math.PI / 180;
            const cos = Math.cos(radians);
            const sin = Math.sin(radians);
            const nx = (cos * (x - cx)) - (sin * (y - cy)) + cx;
            const ny = (sin * (x - cx)) + (cos * (y - cy)) + cy;
            return { x: nx, y: ny };
        }

        function drawSquare(points) {
            ctx.beginPath();
            ctx.moveTo(points.a.x, points.a.y);
            ctx.lineTo(points.b.x, points.b.y);
            ctx.lineTo(points.c.x, points.c.y);
            ctx.lineTo(points.d.x, points.d.y);
            ctx.closePath();
            ctx.stroke();
        }

        //function calculateSquarePoints(mypoints, size, rotation) {
        //    const radians = rotation * Math.PI / 180;
        //    const cos = Math.cos(radians);
        //    const sin = Math.sin(radians);

            // Calculate square points relative to top-left corner
        //    const points = {
        //        a: { x, y },  // top-left
        //        b: { x: x + size * cos, y: y - size * sin },  // top-right
        //        c: { x: x + size * cos + size * sin, y: y + size * cos - size * sin },  // bottom-right
        //        d: { x: x + size * sin, y: y + size * cos }  // bottom-left
        //    };

        //    return points;
        //}

        function drawRecursiveSquares(points, size, rotation, currentDepth) {
            if (currentDepth <= 0) return;

            // Calculate current square points
            //const points = calculateSquarePoints(x, y, size, rotation);
            
            // Draw current square
            drawSquare(points);

            // Vector from c to b (we need to move along this direction)
            const vectorAB = {
                x: points.b.x - points.a.x,
                y: points.b.y - points.a.y
            };
            // Normalize and scale the vector by the current size
            const vectorLength = Math.sqrt(vectorAB.x * vectorAB.x + vectorAB.y * vectorAB.y);
            const normalizedVectorAB = {
                x: (vectorAB.x / vectorLength) * size,
                y: (vectorAB.y / vectorLength) * size
            };

            const vectorAD = {
                x: points.d.x - points.a.x,
                y: points.d.y - points.a.y
            };
            // Normalize and scale the vector by the current size
            const vectorLength = Math.sqrt(vectorAD.x * vectorAD.x + vectorAD.y * vectorAD.y);
            const normalizedVectorAD = {
                x: (vectorAD.x / vectorLength) * size,
                y: (vectorAD.y / vectorLength) * size
            };

            // Calculate new size using cosine
            const newSize = size * Math.cos(rotation * Math.PI / 180);
            
            const newpoints = {
                a: { points.a.x + (normalizedVectorAD.x + normalizedVectorAB.x) * (size-newsize), points.a.y + (normalizedVectorAD.y + normalizedVectorAB.y) * (size-newsize) },  // top-left 
                b: { points.b.x + (normalizedVectorAD.x) * (size-newsize), points.b.y + (normalizedVectorAD.y) * (size-newsize) },  // top-left 
                c: { points.c.x, points.c.y },  // top-left 
                d: { points.d.x + (normalizedVectorAB.x) * (size-newsize), points.d.y + (normalizedVectorAB.y) * (size-newsize) }  // top-left 
            };

            // Vector from c to b (we need to move along this direction)
            const vectorCB = {
                x: points.b.x - points.c.x,
                y: points.b.y - points.c.y
            };

            // Normalize and scale the vector by the current size
            const vectorLength = Math.sqrt(vectorCB.x * vectorCB.x + vectorCB.y * vectorCB.y);
            const normalizedVector = {
                x: (vectorCB.x / vectorLength) * size,
                y: (vectorCB.y / vectorLength) * size
            };

            // Calculate the starting point of the next square by moving from point c along cb direction
            let nextStartX = newpoints.a.x + normalizedVector.x;
            let nextStartY = newpoints.a.y + normalizedVector.y;
            // Rotate this point around c by the specified angle
            const rotatedStarta = rotatePoint(nextStartX, nextStartY, points.c.x, points.c.y, rotation);

            // Calculate the starting point of the next square by moving from point c along c->b direction
            nextStartX = newpoints.b.x + normalizedVector.x;
            nextStartY = newpoints.b.y + normalizedVector.y;
            // Rotate this point around c by the specified angle
            const rotatedStartb = rotatePoint(nextStartX, nextStartY, points.c.x, points.c.y, rotation);

            // Calculate the starting point of the next square by moving from point c along c->b direction
            nextStartX = newpoints.c.x + normalizedVector.x;
            nextStartY = newpoints.c.y + normalizedVector.y;
            // Rotate this point around c by the specified angle
            const rotatedStartc = rotatePoint(nextStartX, nextStartY, points.c.x, points.c.y, rotation);

            // Calculate the starting point of the next square by moving from point c along c->b direction
            nextStartX = newpoints.d.x + normalizedVector.x;
            nextStartY = newpoints.d.y + normalizedVector.y;
            // Rotate this point around c by the specified angle
            const rotatedStartd = rotatePoint(nextStartX, nextStartY, points.c.x, points.c.y, rotation);

            const rotatedStartpoint = { a: rotatedStarta, b: rotatedStartb, c: rotatedStartc, d: rotatedStartd };

            // Draw next square
            drawRecursiveSquares(
                rotatedStartpoint,
                newSize,
                rotation,
                currentDepth - 1
            );
        }

	function draw() {
	    ctx.clearRect(0, 0, canvas.width, canvas.height);
	    ctx.strokeStyle = 'black';
	    ctx.lineWidth = 2;

	    // Start drawing from a position that keeps the pattern visible
	    const startX = canvas.width / 2 - initialSize / 2;
	    const startY = canvas.height - 200;

	    // Calculate square points relative to top-left corner
	    const points = {
		a: { x: startX, y: startY },  // top-left
		b: { x: startX + initialSize, y: startY },  // top-right
		c: { x: startX + initialSize, y: startY + initialSize },  // bottom-right
		d: { x: startX, y: startY + initialSize }  // bottom-left
	    };

	    drawRecursiveSquares(points, initialSize, rotation, depth);
	}

        function updateParams() {
            rotation = parseFloat(document.getElementById('rotation').value);
            depth = parseInt(document.getElementById('depth').value);
            document.getElementById('rotationValue').textContent = rotation+ '°';
            document.getElementById('depthValue').textContent = depth;
            draw();
        }

        // Initial draw
        draw();
    </script>
</body>
</html>
